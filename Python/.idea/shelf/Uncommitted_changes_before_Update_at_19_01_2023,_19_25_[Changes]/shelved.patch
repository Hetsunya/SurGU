Index: lab15/Lab_15/task_1.build/__loader.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/__loader.c b/lab15/Lab_15/task_1.build/__loader.c
new file mode 100644
--- /dev/null	(date 1673971998336)
+++ b/lab15/Lab_15/task_1.build/__loader.c	(date 1673971998336)
@@ -0,0 +1,101 @@
+
+/* Code to register embedded modules for meta path based loading if any. */
+
+#include <Python.h>
+
+/* Use a hex version of our own to compare for versions. We do not care about pre-releases */
+#if PY_MICRO_VERSION < 16
+#define PYTHON_VERSION (PY_MAJOR_VERSION * 256 + PY_MINOR_VERSION * 16 + PY_MICRO_VERSION)
+#else
+#define PYTHON_VERSION (PY_MAJOR_VERSION * 256 + PY_MINOR_VERSION * 16 + 15)
+#endif
+
+#include "nuitka/constants_blob.h"
+
+#include "nuitka/unfreezing.h"
+
+/* Type bool */
+#ifndef __cplusplus
+#include "stdbool.h"
+#endif
+
+#if 0 > 0
+static unsigned char *bytecode_data[0];
+#else
+static unsigned char **bytecode_data = NULL;
+#endif
+
+/* Table for lookup to find compiled or bytecode modules included in this
+ * binary or module, or put along this binary as extension modules. We do
+ * our own loading for each of these.
+ */
+extern PyObject *modulecode___main__(PyObject *, struct Nuitka_MetaPathBasedLoaderEntry const *);
+
+static struct Nuitka_MetaPathBasedLoaderEntry meta_path_loader_entries[] = {
+    {"__main__", modulecode___main__, 0, 0, NUITKA_TRANSLATED_FLAG
+#if defined(_NUITKA_FREEZER_HAS_FILE_PATH)
+, "/home/hetsu/\320\240\320\260\320\261\320\276\321\207\320\270\320\271 \321\201\321\202\320\276\320\273/Python/lab15/Lab_15/task_1.py"
+#endif
+},
+    {NULL, NULL, 0, 0, 0}
+};
+
+static void _loadBytesCodesBlob(void) {
+    static bool init_done = false;
+
+    if (init_done == false) {
+        loadConstantsBlob((PyObject **)bytecode_data, ".bytecode");
+
+        init_done = true;
+    }
+}
+
+
+void setupMetaPathBasedLoader(void) {
+    static bool init_done = false;
+    if (init_done == false) {
+        _loadBytesCodesBlob();
+        registerMetaPathBasedUnfreezer(meta_path_loader_entries, bytecode_data);
+
+        init_done = true;
+    }
+}
+
+// This provides the frozen (compiled bytecode) files that are included if
+// any.
+
+// These modules should be loaded as bytecode. They may e.g. have to be loadable
+// during "Py_Initialize" already, or for irrelevance, they are only included
+// in this un-optimized form. These are not compiled by Nuitka, and therefore
+// are not accelerated at all, merely bundled with the binary or module, so
+// that CPython library can start out finding them.
+
+struct frozen_desc {
+    char const *name;
+    int index;
+    int size;
+};
+
+static struct frozen_desc _frozen_modules[] = {
+
+    {NULL, 0, 0}
+};
+
+
+void copyFrozenModulesTo(struct _frozen *destination) {
+    _loadBytesCodesBlob();
+
+    struct frozen_desc *current = _frozen_modules;
+
+    for (;;) {
+        destination->name = (char *)current->name;
+        destination->code = bytecode_data[current->index];
+        destination->size = current->size;
+
+        if (destination->name == NULL) break;
+
+        current += 1;
+        destination += 1;
+    };
+}
+
Index: lab15/Lab_15/task_1.build/__constants.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/__constants.h b/lab15/Lab_15/task_1.build/__constants.h
new file mode 100644
--- /dev/null	(date 1673971998336)
+++ b/lab15/Lab_15/task_1.build/__constants.h	(date 1673971998336)
@@ -0,0 +1,165 @@
+#ifndef __NUITKA_GLOBAL_CONSTANTS_H__
+#define __NUITKA_GLOBAL_CONSTANTS_H__
+
+extern PyObject *global_constants[79];
+// ()
+#define const_tuple_empty global_constants[0]
+// {}
+#define const_dict_empty global_constants[1]
+// 0
+#define const_int_0 global_constants[2]
+// 1
+#define const_int_pos_1 global_constants[3]
+// -1
+#define const_int_neg_1 global_constants[4]
+// 0.0
+#define const_float_0_0 global_constants[5]
+// -0.0
+#define const_float_minus_0_0 global_constants[6]
+// 1.0
+#define const_float_1_0 global_constants[7]
+// -1.0
+#define const_float_minus_1_0 global_constants[8]
+// 0
+#define const_int_0 global_constants[2]
+// ''
+#define const_str_empty global_constants[9]
+// b''
+#define const_bytes_empty global_constants[10]
+// '__module__'
+#define const_str_plain___module__ global_constants[11]
+// '__class__'
+#define const_str_plain___class__ global_constants[12]
+// '__name__'
+#define const_str_plain___name__ global_constants[13]
+// '__package__'
+#define const_str_plain___package__ global_constants[14]
+// '__metaclass__'
+#define const_str_plain___metaclass__ global_constants[15]
+// '__abstractmethods__'
+#define const_str_plain___abstractmethods__ global_constants[16]
+// '__dict__'
+#define const_str_plain___dict__ global_constants[17]
+// '__doc__'
+#define const_str_plain___doc__ global_constants[18]
+// '__file__'
+#define const_str_plain___file__ global_constants[19]
+// '__path__'
+#define const_str_plain___path__ global_constants[20]
+// '__enter__'
+#define const_str_plain___enter__ global_constants[21]
+// '__exit__'
+#define const_str_plain___exit__ global_constants[22]
+// '__builtins__'
+#define const_str_plain___builtins__ global_constants[23]
+// '__all__'
+#define const_str_plain___all__ global_constants[24]
+// '__init__'
+#define const_str_plain___init__ global_constants[25]
+// '__cmp__'
+#define const_str_plain___cmp__ global_constants[26]
+// '__iter__'
+#define const_str_plain___iter__ global_constants[27]
+// '__compiled__'
+#define const_str_plain___compiled__ global_constants[28]
+// '__nuitka__'
+#define const_str_plain___nuitka__ global_constants[29]
+// 'inspect'
+#define const_str_plain_inspect global_constants[30]
+// 'compile'
+#define const_str_plain_compile global_constants[31]
+// 'range'
+#define const_str_plain_range global_constants[32]
+// 'open'
+#define const_str_plain_open global_constants[33]
+// 'super'
+#define const_str_plain_super global_constants[34]
+// 'sum'
+#define const_str_plain_sum global_constants[35]
+// 'format'
+#define const_str_plain_format global_constants[36]
+// '__import__'
+#define const_str_plain___import__ global_constants[37]
+// 'bytearray'
+#define const_str_plain_bytearray global_constants[38]
+// 'staticmethod'
+#define const_str_plain_staticmethod global_constants[39]
+// 'classmethod'
+#define const_str_plain_classmethod global_constants[40]
+// 'keys'
+#define const_str_plain_keys global_constants[41]
+// 'name'
+#define const_str_plain_name global_constants[42]
+// 'globals'
+#define const_str_plain_globals global_constants[43]
+// 'locals'
+#define const_str_plain_locals global_constants[44]
+// 'fromlist'
+#define const_str_plain_fromlist global_constants[45]
+// 'level'
+#define const_str_plain_level global_constants[46]
+// 'read'
+#define const_str_plain_read global_constants[47]
+// 'rb'
+#define const_str_plain_rb global_constants[48]
+// '/'
+#define const_str_slash global_constants[49]
+// '\\'
+#define const_str_backslash global_constants[50]
+// 'getattr'
+#define const_str_plain_getattr global_constants[51]
+// '__cached__'
+#define const_str_plain___cached__ global_constants[52]
+// '__loader__'
+#define const_str_plain___loader__ global_constants[53]
+// 'print'
+#define const_str_plain_print global_constants[54]
+// 'end'
+#define const_str_plain_end global_constants[55]
+// 'file'
+#define const_str_plain_file global_constants[56]
+// 'bytes'
+#define const_str_plain_bytes global_constants[57]
+// '.'
+#define const_str_dot global_constants[58]
+// '__loader__'
+#define const_str_plain___loader__ global_constants[53]
+// 'send'
+#define const_str_plain_send global_constants[59]
+// 'throw'
+#define const_str_plain_throw global_constants[60]
+// 'close'
+#define const_str_plain_close global_constants[61]
+// 'site'
+#define const_str_plain_site global_constants[62]
+// 'type'
+#define const_str_plain_type global_constants[63]
+// 'len'
+#define const_str_plain_len global_constants[64]
+// 'range'
+#define const_str_plain_range global_constants[32]
+// 'repr'
+#define const_str_plain_repr global_constants[65]
+// 'int'
+#define const_str_plain_int global_constants[66]
+// 'iter'
+#define const_str_plain_iter global_constants[67]
+// '__spec__'
+#define const_str_plain___spec__ global_constants[68]
+// '_initializing'
+#define const_str_plain__initializing global_constants[69]
+// 'parent'
+#define const_str_plain_parent global_constants[70]
+// 'types'
+#define const_str_plain_types global_constants[71]
+// '__main__'
+#define const_str_plain___main__ global_constants[72]
+// 'as_file'
+#define const_str_plain_as_file global_constants[73]
+// 'register'
+#define const_str_plain_register global_constants[74]
+// '__class_getitem__'
+#define const_str_plain___class_getitem__ global_constants[75]
+// '__match_args__'
+#define const_str_plain___match_args__ global_constants[76]
+#endif
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.10\" project-jdk-type=\"Python SDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision e27f9a8ada45ec7716a25a75c769483354ada97c)
+++ b/.idea/misc.xml	(date 1673618913032)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10 (Python)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: lab15/Lab_15/task_1.build/__constants_data.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/__constants_data.c b/lab15/Lab_15/task_1.build/__constants_data.c
new file mode 100644
--- /dev/null	(date 1673971998613)
+++ b/lab15/Lab_15/task_1.build/__constants_data.c	(date 1673971998613)
@@ -0,0 +1,15 @@
+
+#define INCBIN_PREFIX
+#define INCBIN_STYLE INCBIN_STYLE_SNAKE
+#define INCBIN_LOCAL
+#ifdef _NUITKA_EXPERIMENTAL_WRITEABLE_CONSTANTS
+#define INCBIN_OUTPUT_SECTION ".data"
+#endif
+
+#include "nuitka/incbin.h"
+
+INCBIN(constant_bin, "./__constants.bin");
+
+unsigned char const *getConstantsBlobData(void) {
+    return constant_bin_data;
+}
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"e1ad7646-ce85-4948-9dcd-d0dc45b067ab\" name=\"Changes\" comment=\"gigi\">\n      <change afterPath=\"$PROJECT_DIR$/lab15/Lab_15/Python. Лабораторная работа №15.pdf\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/lab15/Lab_15/c_shared_lib.so\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/lab15/Lab_15/steps.sh\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/lab15/Lab_15/task.exe\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/lab15/Lab_15/task_1.py\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/lab15/Lab_15/task_2.c\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/lab15/Lab_15/task_4.py\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/lab15/Lab_15/task_4_lib_c.c\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/lab15/lab15.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/lab15/lab15.py\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Python Script\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"PUSH_TAGS\">\n      <GitPushTagMode>\n        <option name=\"argument\" value=\"--tags\" />\n        <option name=\"title\" value=\"All\" />\n      </GitPushTagMode>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2G6bIVioirXKpXs4As9BuBsb9Vm\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\n    &quot;last_opened_file_path&quot;: &quot;B:/Задания/Python/lab14&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"CopyFile.RECENT_KEYS\">\n      <recent name=\"B:\\Задания\\Python\\lab14\" />\n      <recent name=\"B:\\Задания\\Python\\lab11\" />\n      <recent name=\"B:\\Задания\\Python\\lab10\\package\\laminat\" />\n      <recent name=\"B:\\Задания\\Python\\lab10\\package\\tile\" />\n      <recent name=\"B:\\Задания\\Python\\lab10\\package\\wallpaper\" />\n    </key>\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"B:\\Задания\\Python\\lab13\\Python-Lab\" />\n      <recent name=\"B:\\Задания\\Python\\lab13\" />\n      <recent name=\"B:\\Задания\\Python\\lab14\\3\" />\n      <recent name=\"B:\\Задания\\Python\\lab14\\models\" />\n      <recent name=\"B:\\Задания\\Python\\lab10\\package\" />\n    </key>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"e1ad7646-ce85-4948-9dcd-d0dc45b067ab\" name=\"Changes\" comment=\"\" />\n      <created>1665711901807</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1665711901807</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"хз\">\n      <created>1671349578997</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671349578997</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"хз\">\n      <created>1671349589335</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671349589335</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"\\\">\n      <created>1671501907718</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671501907718</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"/\">\n      <created>1671588950667</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671588950667</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"gigi\">\n      <created>1673251734667</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1673251734667</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"6\" />\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\n    <MESSAGE value=\"хз\" />\n    <MESSAGE value=\"\\\" />\n    <MESSAGE value=\"/\" />\n    <MESSAGE value=\"gigi\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"gigi\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision e27f9a8ada45ec7716a25a75c769483354ada97c)
+++ b/.idea/workspace.xml	(date 1674138324676)
@@ -5,16 +5,44 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="e1ad7646-ce85-4948-9dcd-d0dc45b067ab" name="Changes" comment="gigi">
-      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/Python. Лабораторная работа №15.pdf" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/c_shared_lib.so" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/steps.sh" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task.exe" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_2.c" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_4.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_4_lib_c.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.bin" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/.sconsign-310.dblite" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/@link_input.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__bytecode.const" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__constants.bin" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__constants.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__constants.const" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__constants.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__constants.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__constants_data.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__constants_data.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__helpers.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__helpers.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__helpers.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__loader.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/__loader.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/build_definitions.h" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/module.__main__.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/module.__main__.const" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/module.__main__.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/scons-report.txt" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/CompiledCellType.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/CompiledCellType.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/CompiledFunctionType.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/CompiledFunctionType.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/CompiledGeneratorType.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/CompiledGeneratorType.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/InspectPatcher.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/InspectPatcher.o" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/MainProgram.c" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/lab15/Lab_15/task_1.build/static_src/MainProgram.o" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/Python.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/Python.iml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/vcs.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/lab15/lab15.py" beforeDir="false" afterPath="$PROJECT_DIR$/lab15/lab15.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/lab15/1" beforeDir="false" afterPath="$PROJECT_DIR$/lab15/1" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/lab15/Lab_15/c_shared_lib.so" beforeDir="false" afterPath="$PROJECT_DIR$/lab15/Lab_15/c_shared_lib.so" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -54,7 +82,7 @@
     &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
     &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
     &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
-    &quot;last_opened_file_path&quot;: &quot;B:/Задания/Python/lab14&quot;,
+    &quot;last_opened_file_path&quot;: &quot;/home/hetsu/Рабочий стол/Python&quot;,
     &quot;settings.editor.selected.configurable&quot;: &quot;com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable&quot;
   }
 }</component>
@@ -73,6 +101,29 @@
       <recent name="B:\Задания\Python\lab14\models" />
       <recent name="B:\Задания\Python\lab10\package" />
     </key>
+  </component>
+  <component name="RunManager">
+    <configuration name="lab15" type="PythonConfigurationType" factoryName="Python" nameIsGenerated="true">
+      <module name="Python" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/lab15" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/lab15/lab15.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
   </component>
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="TaskManager">
Index: lab15/Lab_15/task_1.build/module.__main__.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/module.__main__.c b/lab15/Lab_15/task_1.build/module.__main__.c
new file mode 100644
--- /dev/null	(date 1673971998333)
+++ b/lab15/Lab_15/task_1.build/module.__main__.c	(date 1673971998333)
@@ -0,0 +1,2077 @@
+/* Generated code for Python module '__main__'
+ * created by Nuitka version 1.3.8
+ *
+ * This code is in part copyright 2022 Kay Hayen.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "nuitka/prelude.h"
+
+#include "nuitka/unfreezing.h"
+
+#include "__helpers.h"
+
+/* The "module___main__" is a Python object pointer of module type.
+ *
+ * Note: For full compatibility with CPython, every module variable access
+ * needs to go through it except for cases where the module cannot possibly
+ * have changed in the mean time.
+ */
+
+PyObject *module___main__;
+PyDictObject *moduledict___main__;
+
+/* The declarations of module constants used, if any. */
+static PyObject *mod_consts[30];
+#ifndef __NUITKA_NO_ASSERT__
+static Py_hash_t mod_consts_hash[30];
+#endif
+
+static PyObject *module_filename_obj = NULL;
+
+/* Indicator if this modules private constants were created yet. */
+static bool constants_created = false;
+
+/* Function to create module private constants. */
+static void createModuleConstants(void) {
+    if (constants_created == false) {
+        loadConstantsBlob(&mod_consts[0], UNTRANSLATE("__main__"));
+        constants_created = true;
+
+#ifndef __NUITKA_NO_ASSERT__
+        for (int i = 0; i < 30; i++) {
+            mod_consts_hash[i] = DEEP_HASH(mod_consts[i]);
+        }
+#endif
+    }
+}
+
+// We want to be able to initialize the "__main__" constants in any case.
+#if 1
+void createMainModuleConstants(void) {
+    createModuleConstants();
+}
+#endif
+
+/* Function to verify module private constants for non-corruption. */
+#ifndef __NUITKA_NO_ASSERT__
+void checkModuleConstants___main__(void) {
+    // The module may not have been used at all, then ignore this.
+    if (constants_created == false) return;
+
+    for (int i = 0; i < 30; i++) {
+        assert(mod_consts_hash[i] == DEEP_HASH(mod_consts[i]));
+        CHECK_OBJECT_DEEP(mod_consts[i]);
+    }
+}
+#endif
+
+// The module code objects.
+static PyCodeObject *codeobj_9f175da657e9e7d0f3ba50c1bfc74357;
+static PyCodeObject *codeobj_10c93265617b8d504866c6f170ccad7b;
+static PyCodeObject *codeobj_dae4f6d4d04d5bba3b643dda2c8cd5c6;
+static PyCodeObject *codeobj_a27b114b6fb72fcd115f6303cc6375fb;
+static PyCodeObject *codeobj_7299982e0887f5ce5de7890518a855ca;
+/* For use in "MainProgram.c". */
+PyCodeObject *codeobj_main = NULL;
+
+static void createModuleCodeObjects(void) {
+    module_filename_obj = mod_consts[18]; CHECK_OBJECT(module_filename_obj);
+    codeobj_9f175da657e9e7d0f3ba50c1bfc74357 = MAKE_CODE_OBJECT(module_filename_obj, 1, CO_NOFREE, mod_consts[26], mod_consts[26], NULL, NULL, 0, 0, 0);
+    codeobj_main = codeobj_9f175da657e9e7d0f3ba50c1bfc74357;
+    codeobj_10c93265617b8d504866c6f170ccad7b = MAKE_CODE_OBJECT(module_filename_obj, 12, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, mod_consts[15], mod_consts[15], mod_consts[27], NULL, 1, 0, 0);
+    codeobj_dae4f6d4d04d5bba3b643dda2c8cd5c6 = MAKE_CODE_OBJECT(module_filename_obj, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, mod_consts[9], mod_consts[9], mod_consts[28], NULL, 1, 0, 0);
+    codeobj_a27b114b6fb72fcd115f6303cc6375fb = MAKE_CODE_OBJECT(module_filename_obj, 8, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, mod_consts[10], mod_consts[10], mod_consts[28], NULL, 1, 0, 0);
+    codeobj_7299982e0887f5ce5de7890518a855ca = MAKE_CODE_OBJECT(module_filename_obj, 16, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, mod_consts[23], mod_consts[23], mod_consts[29], NULL, 2, 0, 0);
+}
+
+// The module function declarations.
+static PyObject *MAKE_FUNCTION___main__$$$function__1_func_f();
+
+
+static PyObject *MAKE_FUNCTION___main__$$$function__2_func_g();
+
+
+static PyObject *MAKE_FUNCTION___main__$$$function__3_func_a_ij();
+
+
+static PyObject *MAKE_FUNCTION___main__$$$function__4_func_n_a();
+
+
+// The module function definitions.
+static PyObject *impl___main__$$$function__1_func_f(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
+    // Preserve error status for checks
+#ifndef __NUITKA_NO_ASSERT__
+    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
+#endif
+
+    // Local variable declarations.
+    PyObject *par_x = python_pars[0];
+    struct Nuitka_FrameObject *frame_dae4f6d4d04d5bba3b643dda2c8cd5c6;
+    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
+    PyObject *tmp_return_value = NULL;
+    PyObject *exception_type = NULL;
+    PyObject *exception_value = NULL;
+    PyTracebackObject *exception_tb = NULL;
+    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
+    static struct Nuitka_FrameObject *cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6 = NULL;
+
+    // Actual function body.
+    if (isFrameUnusable(cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6)) {
+        Py_XDECREF(cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6);
+
+#if _DEBUG_REFCOUNTS
+        if (cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6 == NULL) {
+            count_active_frame_cache_instances += 1;
+        } else {
+            count_released_frame_cache_instances += 1;
+        }
+        count_allocated_frame_cache_instances += 1;
+#endif
+        cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6 = MAKE_FUNCTION_FRAME(codeobj_dae4f6d4d04d5bba3b643dda2c8cd5c6, module___main__, sizeof(void *));
+#if _DEBUG_REFCOUNTS
+    } else {
+        count_hit_frame_cache_instances += 1;
+#endif
+    }
+    assert(cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6->m_type_description == NULL);
+    frame_dae4f6d4d04d5bba3b643dda2c8cd5c6 = cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6;
+
+
+    // Push the new frame as the currently active one.
+    pushFrameStack(frame_dae4f6d4d04d5bba3b643dda2c8cd5c6);
+
+    // Mark the frame object as in use, ref count 1 will be up for reuse.
+    assert(Py_REFCNT(frame_dae4f6d4d04d5bba3b643dda2c8cd5c6) == 2); // Frame stack
+
+    // Framed code:
+    {
+        PyObject *tmp_sub_expr_left_1;
+        PyObject *tmp_sub_expr_right_1;
+        PyObject *tmp_called_value_1;
+        PyObject *tmp_expression_value_1;
+        PyObject *tmp_args_element_value_1;
+        PyObject *tmp_expression_value_2;
+        PyObject *tmp_args_element_value_2;
+        PyObject *tmp_called_instance_1;
+        PyObject *tmp_args_element_value_3;
+        tmp_expression_value_1 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[0]);
+
+        if (unlikely(tmp_expression_value_1 == NULL)) {
+            tmp_expression_value_1 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[0]);
+        }
+
+        if (tmp_expression_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 5;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_called_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_value_1, mod_consts[1]);
+        if (tmp_called_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 5;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_expression_value_2 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[0]);
+
+        if (unlikely(tmp_expression_value_2 == NULL)) {
+            tmp_expression_value_2 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[0]);
+        }
+
+        if (tmp_expression_value_2 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+
+            exception_lineno = 5;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_args_element_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_value_2, mod_consts[2]);
+        if (tmp_args_element_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+
+            exception_lineno = 5;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_called_instance_1 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[0]);
+
+        if (unlikely(tmp_called_instance_1 == NULL)) {
+            tmp_called_instance_1 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[0]);
+        }
+
+        if (tmp_called_instance_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+            Py_DECREF(tmp_args_element_value_1);
+
+            exception_lineno = 5;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        CHECK_OBJECT(par_x);
+        tmp_args_element_value_3 = par_x;
+        frame_dae4f6d4d04d5bba3b643dda2c8cd5c6->m_frame.f_lineno = 5;
+        tmp_args_element_value_2 = CALL_METHOD_WITH_SINGLE_ARG(tmp_called_instance_1, mod_consts[3], tmp_args_element_value_3);
+        if (tmp_args_element_value_2 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+            Py_DECREF(tmp_args_element_value_1);
+
+            exception_lineno = 5;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        frame_dae4f6d4d04d5bba3b643dda2c8cd5c6->m_frame.f_lineno = 5;
+        {
+            PyObject *call_args[] = {tmp_args_element_value_1, tmp_args_element_value_2};
+            tmp_sub_expr_left_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_value_1, call_args);
+        }
+
+        Py_DECREF(tmp_called_value_1);
+        Py_DECREF(tmp_args_element_value_1);
+        Py_DECREF(tmp_args_element_value_2);
+        if (tmp_sub_expr_left_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 5;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        CHECK_OBJECT(par_x);
+        tmp_sub_expr_right_1 = par_x;
+        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_OBJECT_OBJECT(tmp_sub_expr_left_1, tmp_sub_expr_right_1);
+        Py_DECREF(tmp_sub_expr_left_1);
+        if (tmp_return_value == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 5;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        goto frame_return_exit_1;
+    }
+
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_dae4f6d4d04d5bba3b643dda2c8cd5c6);
+#endif
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    goto frame_no_exception_1;
+
+    frame_return_exit_1:;
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_dae4f6d4d04d5bba3b643dda2c8cd5c6);
+#endif
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    goto function_return_exit;
+
+    frame_exception_exit_1:;
+
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_dae4f6d4d04d5bba3b643dda2c8cd5c6);
+#endif
+
+    if (exception_tb == NULL) {
+        exception_tb = MAKE_TRACEBACK(frame_dae4f6d4d04d5bba3b643dda2c8cd5c6, exception_lineno);
+    } else if (exception_tb->tb_frame != &frame_dae4f6d4d04d5bba3b643dda2c8cd5c6->m_frame) {
+        exception_tb = ADD_TRACEBACK(exception_tb, frame_dae4f6d4d04d5bba3b643dda2c8cd5c6, exception_lineno);
+    }
+
+    // Attaches locals to frame if any.
+    Nuitka_Frame_AttachLocals(
+        frame_dae4f6d4d04d5bba3b643dda2c8cd5c6,
+        type_description_1,
+        par_x
+    );
+
+
+    // Release cached frame if used for exception.
+    if (frame_dae4f6d4d04d5bba3b643dda2c8cd5c6 == cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6) {
+#if _DEBUG_REFCOUNTS
+        count_active_frame_cache_instances -= 1;
+        count_released_frame_cache_instances += 1;
+#endif
+
+        Py_DECREF(cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6);
+        cache_frame_dae4f6d4d04d5bba3b643dda2c8cd5c6 = NULL;
+    }
+
+    assertFrameObject(frame_dae4f6d4d04d5bba3b643dda2c8cd5c6);
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    // Return the error.
+    goto function_exception_exit;
+
+    frame_no_exception_1:;
+
+    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
+    return NULL;
+
+function_exception_exit:
+    CHECK_OBJECT(par_x);
+    Py_DECREF(par_x);
+    assert(exception_type);
+    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+    return NULL;
+
+function_return_exit:
+   // Function cleanup code if any.
+    CHECK_OBJECT(par_x);
+    Py_DECREF(par_x);
+
+   // Actual function exit with return value, making sure we did not make
+   // the error status worse despite non-NULL return.
+   CHECK_OBJECT(tmp_return_value);
+   assert(had_error || !ERROR_OCCURRED());
+   return tmp_return_value;
+}
+
+
+static PyObject *impl___main__$$$function__2_func_g(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
+    // Preserve error status for checks
+#ifndef __NUITKA_NO_ASSERT__
+    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
+#endif
+
+    // Local variable declarations.
+    PyObject *par_x = python_pars[0];
+    struct Nuitka_FrameObject *frame_a27b114b6fb72fcd115f6303cc6375fb;
+    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
+    PyObject *tmp_return_value = NULL;
+    PyObject *exception_type = NULL;
+    PyObject *exception_value = NULL;
+    PyTracebackObject *exception_tb = NULL;
+    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
+    static struct Nuitka_FrameObject *cache_frame_a27b114b6fb72fcd115f6303cc6375fb = NULL;
+
+    // Actual function body.
+    if (isFrameUnusable(cache_frame_a27b114b6fb72fcd115f6303cc6375fb)) {
+        Py_XDECREF(cache_frame_a27b114b6fb72fcd115f6303cc6375fb);
+
+#if _DEBUG_REFCOUNTS
+        if (cache_frame_a27b114b6fb72fcd115f6303cc6375fb == NULL) {
+            count_active_frame_cache_instances += 1;
+        } else {
+            count_released_frame_cache_instances += 1;
+        }
+        count_allocated_frame_cache_instances += 1;
+#endif
+        cache_frame_a27b114b6fb72fcd115f6303cc6375fb = MAKE_FUNCTION_FRAME(codeobj_a27b114b6fb72fcd115f6303cc6375fb, module___main__, sizeof(void *));
+#if _DEBUG_REFCOUNTS
+    } else {
+        count_hit_frame_cache_instances += 1;
+#endif
+    }
+    assert(cache_frame_a27b114b6fb72fcd115f6303cc6375fb->m_type_description == NULL);
+    frame_a27b114b6fb72fcd115f6303cc6375fb = cache_frame_a27b114b6fb72fcd115f6303cc6375fb;
+
+
+    // Push the new frame as the currently active one.
+    pushFrameStack(frame_a27b114b6fb72fcd115f6303cc6375fb);
+
+    // Mark the frame object as in use, ref count 1 will be up for reuse.
+    assert(Py_REFCNT(frame_a27b114b6fb72fcd115f6303cc6375fb) == 2); // Frame stack
+
+    // Framed code:
+    {
+        PyObject *tmp_sub_expr_left_1;
+        PyObject *tmp_sub_expr_right_1;
+        PyObject *tmp_called_value_1;
+        PyObject *tmp_expression_value_1;
+        PyObject *tmp_args_element_value_1;
+        PyObject *tmp_add_expr_left_1;
+        PyObject *tmp_add_expr_right_1;
+        PyObject *tmp_called_instance_1;
+        PyObject *tmp_args_element_value_2;
+        PyObject *tmp_called_instance_2;
+        PyObject *tmp_args_element_value_3;
+        tmp_expression_value_1 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[0]);
+
+        if (unlikely(tmp_expression_value_1 == NULL)) {
+            tmp_expression_value_1 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[0]);
+        }
+
+        if (tmp_expression_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_called_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_value_1, mod_consts[4]);
+        if (tmp_called_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_add_expr_left_1 = mod_consts[5];
+        tmp_called_instance_1 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[0]);
+
+        if (unlikely(tmp_called_instance_1 == NULL)) {
+            tmp_called_instance_1 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[0]);
+        }
+
+        if (tmp_called_instance_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        CHECK_OBJECT(par_x);
+        tmp_args_element_value_2 = par_x;
+        frame_a27b114b6fb72fcd115f6303cc6375fb->m_frame.f_lineno = 9;
+        tmp_add_expr_right_1 = CALL_METHOD_WITH_SINGLE_ARG(tmp_called_instance_1, mod_consts[6], tmp_args_element_value_2);
+        if (tmp_add_expr_right_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_args_element_value_1 = BINARY_OPERATION_ADD_OBJECT_LONG_OBJECT(tmp_add_expr_left_1, tmp_add_expr_right_1);
+        Py_DECREF(tmp_add_expr_right_1);
+        if (tmp_args_element_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        frame_a27b114b6fb72fcd115f6303cc6375fb->m_frame.f_lineno = 9;
+        tmp_sub_expr_left_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_value_1, tmp_args_element_value_1);
+        Py_DECREF(tmp_called_value_1);
+        Py_DECREF(tmp_args_element_value_1);
+        if (tmp_sub_expr_left_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_called_instance_2 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[0]);
+
+        if (unlikely(tmp_called_instance_2 == NULL)) {
+            tmp_called_instance_2 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[0]);
+        }
+
+        if (tmp_called_instance_2 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_sub_expr_left_1);
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        CHECK_OBJECT(par_x);
+        tmp_args_element_value_3 = par_x;
+        frame_a27b114b6fb72fcd115f6303cc6375fb->m_frame.f_lineno = 9;
+        tmp_sub_expr_right_1 = CALL_METHOD_WITH_SINGLE_ARG(tmp_called_instance_2, mod_consts[7], tmp_args_element_value_3);
+        if (tmp_sub_expr_right_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_sub_expr_left_1);
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_return_value = BINARY_OPERATION_SUB_OBJECT_OBJECT_OBJECT(tmp_sub_expr_left_1, tmp_sub_expr_right_1);
+        Py_DECREF(tmp_sub_expr_left_1);
+        Py_DECREF(tmp_sub_expr_right_1);
+        if (tmp_return_value == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 9;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        goto frame_return_exit_1;
+    }
+
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_a27b114b6fb72fcd115f6303cc6375fb);
+#endif
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    goto frame_no_exception_1;
+
+    frame_return_exit_1:;
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_a27b114b6fb72fcd115f6303cc6375fb);
+#endif
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    goto function_return_exit;
+
+    frame_exception_exit_1:;
+
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_a27b114b6fb72fcd115f6303cc6375fb);
+#endif
+
+    if (exception_tb == NULL) {
+        exception_tb = MAKE_TRACEBACK(frame_a27b114b6fb72fcd115f6303cc6375fb, exception_lineno);
+    } else if (exception_tb->tb_frame != &frame_a27b114b6fb72fcd115f6303cc6375fb->m_frame) {
+        exception_tb = ADD_TRACEBACK(exception_tb, frame_a27b114b6fb72fcd115f6303cc6375fb, exception_lineno);
+    }
+
+    // Attaches locals to frame if any.
+    Nuitka_Frame_AttachLocals(
+        frame_a27b114b6fb72fcd115f6303cc6375fb,
+        type_description_1,
+        par_x
+    );
+
+
+    // Release cached frame if used for exception.
+    if (frame_a27b114b6fb72fcd115f6303cc6375fb == cache_frame_a27b114b6fb72fcd115f6303cc6375fb) {
+#if _DEBUG_REFCOUNTS
+        count_active_frame_cache_instances -= 1;
+        count_released_frame_cache_instances += 1;
+#endif
+
+        Py_DECREF(cache_frame_a27b114b6fb72fcd115f6303cc6375fb);
+        cache_frame_a27b114b6fb72fcd115f6303cc6375fb = NULL;
+    }
+
+    assertFrameObject(frame_a27b114b6fb72fcd115f6303cc6375fb);
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    // Return the error.
+    goto function_exception_exit;
+
+    frame_no_exception_1:;
+
+    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
+    return NULL;
+
+function_exception_exit:
+    CHECK_OBJECT(par_x);
+    Py_DECREF(par_x);
+    assert(exception_type);
+    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+    return NULL;
+
+function_return_exit:
+   // Function cleanup code if any.
+    CHECK_OBJECT(par_x);
+    Py_DECREF(par_x);
+
+   // Actual function exit with return value, making sure we did not make
+   // the error status worse despite non-NULL return.
+   CHECK_OBJECT(tmp_return_value);
+   assert(had_error || !ERROR_OCCURRED());
+   return tmp_return_value;
+}
+
+
+static PyObject *impl___main__$$$function__3_func_a_ij(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
+    // Preserve error status for checks
+#ifndef __NUITKA_NO_ASSERT__
+    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
+#endif
+
+    // Local variable declarations.
+    PyObject *par_i = python_pars[0];
+    struct Nuitka_FrameObject *frame_10c93265617b8d504866c6f170ccad7b;
+    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
+    PyObject *tmp_return_value = NULL;
+    PyObject *exception_type = NULL;
+    PyObject *exception_value = NULL;
+    PyTracebackObject *exception_tb = NULL;
+    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
+    static struct Nuitka_FrameObject *cache_frame_10c93265617b8d504866c6f170ccad7b = NULL;
+
+    // Actual function body.
+    if (isFrameUnusable(cache_frame_10c93265617b8d504866c6f170ccad7b)) {
+        Py_XDECREF(cache_frame_10c93265617b8d504866c6f170ccad7b);
+
+#if _DEBUG_REFCOUNTS
+        if (cache_frame_10c93265617b8d504866c6f170ccad7b == NULL) {
+            count_active_frame_cache_instances += 1;
+        } else {
+            count_released_frame_cache_instances += 1;
+        }
+        count_allocated_frame_cache_instances += 1;
+#endif
+        cache_frame_10c93265617b8d504866c6f170ccad7b = MAKE_FUNCTION_FRAME(codeobj_10c93265617b8d504866c6f170ccad7b, module___main__, sizeof(void *));
+#if _DEBUG_REFCOUNTS
+    } else {
+        count_hit_frame_cache_instances += 1;
+#endif
+    }
+    assert(cache_frame_10c93265617b8d504866c6f170ccad7b->m_type_description == NULL);
+    frame_10c93265617b8d504866c6f170ccad7b = cache_frame_10c93265617b8d504866c6f170ccad7b;
+
+
+    // Push the new frame as the currently active one.
+    pushFrameStack(frame_10c93265617b8d504866c6f170ccad7b);
+
+    // Mark the frame object as in use, ref count 1 will be up for reuse.
+    assert(Py_REFCNT(frame_10c93265617b8d504866c6f170ccad7b) == 2); // Frame stack
+
+    // Framed code:
+    {
+        PyObject *tmp_called_value_1;
+        PyObject *tmp_expression_value_1;
+        PyObject *tmp_args_element_value_1;
+        PyObject *tmp_add_expr_left_1;
+        PyObject *tmp_add_expr_right_1;
+        PyObject *tmp_called_value_2;
+        PyObject *tmp_args_element_value_2;
+        PyObject *tmp_called_value_3;
+        PyObject *tmp_args_element_value_3;
+        tmp_expression_value_1 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[0]);
+
+        if (unlikely(tmp_expression_value_1 == NULL)) {
+            tmp_expression_value_1 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[0]);
+        }
+
+        if (tmp_expression_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 13;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_called_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_value_1, mod_consts[8]);
+        if (tmp_called_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 13;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_called_value_2 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[9]);
+
+        if (unlikely(tmp_called_value_2 == NULL)) {
+            tmp_called_value_2 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[9]);
+        }
+
+        if (tmp_called_value_2 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+
+            exception_lineno = 13;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        CHECK_OBJECT(par_i);
+        tmp_args_element_value_2 = par_i;
+        frame_10c93265617b8d504866c6f170ccad7b->m_frame.f_lineno = 13;
+        tmp_add_expr_left_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_value_2, tmp_args_element_value_2);
+        if (tmp_add_expr_left_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+
+            exception_lineno = 13;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_called_value_3 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[10]);
+
+        if (unlikely(tmp_called_value_3 == NULL)) {
+            tmp_called_value_3 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[10]);
+        }
+
+        if (tmp_called_value_3 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+            Py_DECREF(tmp_add_expr_left_1);
+
+            exception_lineno = 13;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        CHECK_OBJECT(par_i);
+        tmp_args_element_value_3 = par_i;
+        frame_10c93265617b8d504866c6f170ccad7b->m_frame.f_lineno = 13;
+        tmp_add_expr_right_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_value_3, tmp_args_element_value_3);
+        if (tmp_add_expr_right_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+            Py_DECREF(tmp_add_expr_left_1);
+
+            exception_lineno = 13;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        tmp_args_element_value_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT_OBJECT(tmp_add_expr_left_1, tmp_add_expr_right_1);
+        Py_DECREF(tmp_add_expr_left_1);
+        Py_DECREF(tmp_add_expr_right_1);
+        if (tmp_args_element_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            Py_DECREF(tmp_called_value_1);
+
+            exception_lineno = 13;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        frame_10c93265617b8d504866c6f170ccad7b->m_frame.f_lineno = 13;
+        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_value_1, tmp_args_element_value_1);
+        Py_DECREF(tmp_called_value_1);
+        Py_DECREF(tmp_args_element_value_1);
+        if (tmp_return_value == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 13;
+            type_description_1 = "o";
+            goto frame_exception_exit_1;
+        }
+        goto frame_return_exit_1;
+    }
+
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_10c93265617b8d504866c6f170ccad7b);
+#endif
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    goto frame_no_exception_1;
+
+    frame_return_exit_1:;
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_10c93265617b8d504866c6f170ccad7b);
+#endif
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    goto function_return_exit;
+
+    frame_exception_exit_1:;
+
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_10c93265617b8d504866c6f170ccad7b);
+#endif
+
+    if (exception_tb == NULL) {
+        exception_tb = MAKE_TRACEBACK(frame_10c93265617b8d504866c6f170ccad7b, exception_lineno);
+    } else if (exception_tb->tb_frame != &frame_10c93265617b8d504866c6f170ccad7b->m_frame) {
+        exception_tb = ADD_TRACEBACK(exception_tb, frame_10c93265617b8d504866c6f170ccad7b, exception_lineno);
+    }
+
+    // Attaches locals to frame if any.
+    Nuitka_Frame_AttachLocals(
+        frame_10c93265617b8d504866c6f170ccad7b,
+        type_description_1,
+        par_i
+    );
+
+
+    // Release cached frame if used for exception.
+    if (frame_10c93265617b8d504866c6f170ccad7b == cache_frame_10c93265617b8d504866c6f170ccad7b) {
+#if _DEBUG_REFCOUNTS
+        count_active_frame_cache_instances -= 1;
+        count_released_frame_cache_instances += 1;
+#endif
+
+        Py_DECREF(cache_frame_10c93265617b8d504866c6f170ccad7b);
+        cache_frame_10c93265617b8d504866c6f170ccad7b = NULL;
+    }
+
+    assertFrameObject(frame_10c93265617b8d504866c6f170ccad7b);
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    // Return the error.
+    goto function_exception_exit;
+
+    frame_no_exception_1:;
+
+    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
+    return NULL;
+
+function_exception_exit:
+    CHECK_OBJECT(par_i);
+    Py_DECREF(par_i);
+    assert(exception_type);
+    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+    return NULL;
+
+function_return_exit:
+   // Function cleanup code if any.
+    CHECK_OBJECT(par_i);
+    Py_DECREF(par_i);
+
+   // Actual function exit with return value, making sure we did not make
+   // the error status worse despite non-NULL return.
+   CHECK_OBJECT(tmp_return_value);
+   assert(had_error || !ERROR_OCCURRED());
+   return tmp_return_value;
+}
+
+
+static PyObject *impl___main__$$$function__4_func_n_a(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
+    // Preserve error status for checks
+#ifndef __NUITKA_NO_ASSERT__
+    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
+#endif
+
+    // Local variable declarations.
+    PyObject *par_m = python_pars[0];
+    PyObject *par_n = python_pars[1];
+    PyObject *var_max_value = NULL;
+    PyObject *var_i = NULL;
+    PyObject *tmp_for_loop_1__for_iterator = NULL;
+    PyObject *tmp_for_loop_1__iter_value = NULL;
+    struct Nuitka_FrameObject *frame_7299982e0887f5ce5de7890518a855ca;
+    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
+    PyObject *exception_type = NULL;
+    PyObject *exception_value = NULL;
+    PyTracebackObject *exception_tb = NULL;
+    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
+    PyObject *exception_keeper_type_1;
+    PyObject *exception_keeper_value_1;
+    PyTracebackObject *exception_keeper_tb_1;
+    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
+    PyObject *tmp_return_value = NULL;
+    static struct Nuitka_FrameObject *cache_frame_7299982e0887f5ce5de7890518a855ca = NULL;
+    PyObject *exception_keeper_type_2;
+    PyObject *exception_keeper_value_2;
+    PyTracebackObject *exception_keeper_tb_2;
+    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
+
+    // Actual function body.
+    // Tried code:
+    if (isFrameUnusable(cache_frame_7299982e0887f5ce5de7890518a855ca)) {
+        Py_XDECREF(cache_frame_7299982e0887f5ce5de7890518a855ca);
+
+#if _DEBUG_REFCOUNTS
+        if (cache_frame_7299982e0887f5ce5de7890518a855ca == NULL) {
+            count_active_frame_cache_instances += 1;
+        } else {
+            count_released_frame_cache_instances += 1;
+        }
+        count_allocated_frame_cache_instances += 1;
+#endif
+        cache_frame_7299982e0887f5ce5de7890518a855ca = MAKE_FUNCTION_FRAME(codeobj_7299982e0887f5ce5de7890518a855ca, module___main__, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
+#if _DEBUG_REFCOUNTS
+    } else {
+        count_hit_frame_cache_instances += 1;
+#endif
+    }
+    assert(cache_frame_7299982e0887f5ce5de7890518a855ca->m_type_description == NULL);
+    frame_7299982e0887f5ce5de7890518a855ca = cache_frame_7299982e0887f5ce5de7890518a855ca;
+
+
+    // Push the new frame as the currently active one.
+    pushFrameStack(frame_7299982e0887f5ce5de7890518a855ca);
+
+    // Mark the frame object as in use, ref count 1 will be up for reuse.
+    assert(Py_REFCNT(frame_7299982e0887f5ce5de7890518a855ca) == 2); // Frame stack
+
+    // Framed code:
+    {
+        PyObject *tmp_assign_source_1;
+        PyObject *tmp_called_value_1;
+        PyObject *tmp_args_element_value_1;
+        PyObject *tmp_args_element_value_2;
+        tmp_called_value_1 = LOOKUP_BUILTIN(mod_consts[11]);
+        assert(tmp_called_value_1 != NULL);
+        CHECK_OBJECT(par_m);
+        tmp_args_element_value_1 = par_m;
+        CHECK_OBJECT(par_n);
+        tmp_args_element_value_2 = par_n;
+        frame_7299982e0887f5ce5de7890518a855ca->m_frame.f_lineno = 17;
+        {
+            PyObject *call_args[] = {tmp_args_element_value_1, tmp_args_element_value_2};
+            tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_value_1, call_args);
+        }
+
+        if (tmp_assign_source_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 17;
+            type_description_1 = "oooo";
+            goto frame_exception_exit_1;
+        }
+        {
+            PyObject *old = par_m;
+            assert(old != NULL);
+            par_m = tmp_assign_source_1;
+            Py_DECREF(old);
+        }
+
+    }
+    {
+        PyObject *tmp_assign_source_2;
+        tmp_assign_source_2 = mod_consts[12];
+        assert(var_max_value == NULL);
+        Py_INCREF(tmp_assign_source_2);
+        var_max_value = tmp_assign_source_2;
+    }
+    {
+        PyObject *tmp_assign_source_3;
+        PyObject *tmp_iter_arg_1;
+        PyObject *tmp_xrange_low_1;
+        PyObject *tmp_xrange_high_1;
+        PyObject *tmp_add_expr_left_1;
+        PyObject *tmp_add_expr_right_1;
+        tmp_xrange_low_1 = mod_consts[5];
+        CHECK_OBJECT(par_m);
+        tmp_add_expr_left_1 = par_m;
+        tmp_add_expr_right_1 = mod_consts[5];
+        tmp_xrange_high_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT_LONG(tmp_add_expr_left_1, tmp_add_expr_right_1);
+        if (tmp_xrange_high_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 20;
+            type_description_1 = "oooo";
+            goto frame_exception_exit_1;
+        }
+        tmp_iter_arg_1 = BUILTIN_XRANGE2(tmp_xrange_low_1, tmp_xrange_high_1);
+        Py_DECREF(tmp_xrange_high_1);
+        if (tmp_iter_arg_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 20;
+            type_description_1 = "oooo";
+            goto frame_exception_exit_1;
+        }
+        tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
+        Py_DECREF(tmp_iter_arg_1);
+        if (tmp_assign_source_3 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 20;
+            type_description_1 = "oooo";
+            goto frame_exception_exit_1;
+        }
+        assert(tmp_for_loop_1__for_iterator == NULL);
+        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
+    }
+    // Tried code:
+    loop_start_1:;
+    {
+        PyObject *tmp_next_source_1;
+        PyObject *tmp_assign_source_4;
+        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
+        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
+        tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
+        if (tmp_assign_source_4 == NULL) {
+            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {
+
+                goto loop_end_1;
+            } else {
+
+                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+                type_description_1 = "oooo";
+                exception_lineno = 20;
+                goto try_except_handler_2;
+            }
+        }
+
+        {
+            PyObject *old = tmp_for_loop_1__iter_value;
+            tmp_for_loop_1__iter_value = tmp_assign_source_4;
+            Py_XDECREF(old);
+        }
+
+    }
+    {
+        PyObject *tmp_assign_source_5;
+        CHECK_OBJECT(tmp_for_loop_1__iter_value);
+        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
+        {
+            PyObject *old = var_i;
+            var_i = tmp_assign_source_5;
+            Py_INCREF(var_i);
+            Py_XDECREF(old);
+        }
+
+    }
+    {
+        PyObject *tmp_assign_source_6;
+        PyObject *tmp_called_value_2;
+        PyObject *tmp_args_element_value_3;
+        PyObject *tmp_args_element_value_4;
+        PyObject *tmp_called_value_3;
+        PyObject *tmp_args_element_value_5;
+        tmp_called_value_2 = LOOKUP_BUILTIN(mod_consts[13]);
+        assert(tmp_called_value_2 != NULL);
+        if (var_max_value == NULL) {
+
+            FORMAT_UNBOUND_LOCAL_ERROR(&exception_type, &exception_value, mod_consts[14]);
+            exception_tb = NULL;
+            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
+            CHAIN_EXCEPTION(exception_value);
+
+            exception_lineno = 21;
+            type_description_1 = "oooo";
+            goto try_except_handler_2;
+        }
+
+        tmp_args_element_value_3 = var_max_value;
+        tmp_called_value_3 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[15]);
+
+        if (unlikely(tmp_called_value_3 == NULL)) {
+            tmp_called_value_3 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[15]);
+        }
+
+        if (tmp_called_value_3 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 21;
+            type_description_1 = "oooo";
+            goto try_except_handler_2;
+        }
+        CHECK_OBJECT(var_i);
+        tmp_args_element_value_5 = var_i;
+        frame_7299982e0887f5ce5de7890518a855ca->m_frame.f_lineno = 21;
+        tmp_args_element_value_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_value_3, tmp_args_element_value_5);
+        if (tmp_args_element_value_4 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 21;
+            type_description_1 = "oooo";
+            goto try_except_handler_2;
+        }
+        frame_7299982e0887f5ce5de7890518a855ca->m_frame.f_lineno = 21;
+        {
+            PyObject *call_args[] = {tmp_args_element_value_3, tmp_args_element_value_4};
+            tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2(tmp_called_value_2, call_args);
+        }
+
+        Py_DECREF(tmp_args_element_value_4);
+        if (tmp_assign_source_6 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 21;
+            type_description_1 = "oooo";
+            goto try_except_handler_2;
+        }
+        {
+            PyObject *old = var_max_value;
+            var_max_value = tmp_assign_source_6;
+            Py_XDECREF(old);
+        }
+
+    }
+    if (CONSIDER_THREADING() == false) {
+        assert(ERROR_OCCURRED());
+
+        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+        exception_lineno = 20;
+        type_description_1 = "oooo";
+        goto try_except_handler_2;
+    }
+    goto loop_start_1;
+    loop_end_1:;
+    goto try_end_1;
+    // Exception handler code:
+    try_except_handler_2:;
+    exception_keeper_type_1 = exception_type;
+    exception_keeper_value_1 = exception_value;
+    exception_keeper_tb_1 = exception_tb;
+    exception_keeper_lineno_1 = exception_lineno;
+    exception_type = NULL;
+    exception_value = NULL;
+    exception_tb = NULL;
+    exception_lineno = 0;
+
+    Py_XDECREF(tmp_for_loop_1__iter_value);
+    tmp_for_loop_1__iter_value = NULL;
+    CHECK_OBJECT(tmp_for_loop_1__for_iterator);
+    Py_DECREF(tmp_for_loop_1__for_iterator);
+    tmp_for_loop_1__for_iterator = NULL;
+    // Re-raise.
+    exception_type = exception_keeper_type_1;
+    exception_value = exception_keeper_value_1;
+    exception_tb = exception_keeper_tb_1;
+    exception_lineno = exception_keeper_lineno_1;
+
+    goto frame_exception_exit_1;
+    // End of try:
+    try_end_1:;
+    Py_XDECREF(tmp_for_loop_1__iter_value);
+    tmp_for_loop_1__iter_value = NULL;
+    CHECK_OBJECT(tmp_for_loop_1__for_iterator);
+    Py_DECREF(tmp_for_loop_1__for_iterator);
+    tmp_for_loop_1__for_iterator = NULL;
+    {
+        PyObject *tmp_called_value_4;
+        PyObject *tmp_expression_value_1;
+        PyObject *tmp_args_element_value_6;
+        tmp_expression_value_1 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[0]);
+
+        if (unlikely(tmp_expression_value_1 == NULL)) {
+            tmp_expression_value_1 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[0]);
+        }
+
+        if (tmp_expression_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 23;
+            type_description_1 = "oooo";
+            goto frame_exception_exit_1;
+        }
+        tmp_called_value_4 = LOOKUP_ATTRIBUTE(tmp_expression_value_1, mod_consts[6]);
+        if (tmp_called_value_4 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 23;
+            type_description_1 = "oooo";
+            goto frame_exception_exit_1;
+        }
+        if (var_max_value == NULL) {
+            Py_DECREF(tmp_called_value_4);
+            FORMAT_UNBOUND_LOCAL_ERROR(&exception_type, &exception_value, mod_consts[14]);
+            exception_tb = NULL;
+            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
+            CHAIN_EXCEPTION(exception_value);
+
+            exception_lineno = 23;
+            type_description_1 = "oooo";
+            goto frame_exception_exit_1;
+        }
+
+        tmp_args_element_value_6 = var_max_value;
+        frame_7299982e0887f5ce5de7890518a855ca->m_frame.f_lineno = 23;
+        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_value_4, tmp_args_element_value_6);
+        Py_DECREF(tmp_called_value_4);
+        if (tmp_return_value == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 23;
+            type_description_1 = "oooo";
+            goto frame_exception_exit_1;
+        }
+        goto frame_return_exit_1;
+    }
+
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_7299982e0887f5ce5de7890518a855ca);
+#endif
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    goto frame_no_exception_1;
+
+    frame_return_exit_1:;
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_7299982e0887f5ce5de7890518a855ca);
+#endif
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    goto try_return_handler_1;
+
+    frame_exception_exit_1:;
+
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_7299982e0887f5ce5de7890518a855ca);
+#endif
+
+    if (exception_tb == NULL) {
+        exception_tb = MAKE_TRACEBACK(frame_7299982e0887f5ce5de7890518a855ca, exception_lineno);
+    } else if (exception_tb->tb_frame != &frame_7299982e0887f5ce5de7890518a855ca->m_frame) {
+        exception_tb = ADD_TRACEBACK(exception_tb, frame_7299982e0887f5ce5de7890518a855ca, exception_lineno);
+    }
+
+    // Attaches locals to frame if any.
+    Nuitka_Frame_AttachLocals(
+        frame_7299982e0887f5ce5de7890518a855ca,
+        type_description_1,
+        par_m,
+        par_n,
+        var_max_value,
+        var_i
+    );
+
+
+    // Release cached frame if used for exception.
+    if (frame_7299982e0887f5ce5de7890518a855ca == cache_frame_7299982e0887f5ce5de7890518a855ca) {
+#if _DEBUG_REFCOUNTS
+        count_active_frame_cache_instances -= 1;
+        count_released_frame_cache_instances += 1;
+#endif
+
+        Py_DECREF(cache_frame_7299982e0887f5ce5de7890518a855ca);
+        cache_frame_7299982e0887f5ce5de7890518a855ca = NULL;
+    }
+
+    assertFrameObject(frame_7299982e0887f5ce5de7890518a855ca);
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+
+    // Return the error.
+    goto try_except_handler_1;
+
+    frame_no_exception_1:;
+    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
+    return NULL;
+    // Return handler code:
+    try_return_handler_1:;
+    CHECK_OBJECT(par_m);
+    Py_DECREF(par_m);
+    par_m = NULL;
+    Py_XDECREF(var_max_value);
+    var_max_value = NULL;
+    Py_XDECREF(var_i);
+    var_i = NULL;
+    goto function_return_exit;
+    // Exception handler code:
+    try_except_handler_1:;
+    exception_keeper_type_2 = exception_type;
+    exception_keeper_value_2 = exception_value;
+    exception_keeper_tb_2 = exception_tb;
+    exception_keeper_lineno_2 = exception_lineno;
+    exception_type = NULL;
+    exception_value = NULL;
+    exception_tb = NULL;
+    exception_lineno = 0;
+
+    Py_XDECREF(par_m);
+    par_m = NULL;
+    Py_XDECREF(var_max_value);
+    var_max_value = NULL;
+    Py_XDECREF(var_i);
+    var_i = NULL;
+    // Re-raise.
+    exception_type = exception_keeper_type_2;
+    exception_value = exception_keeper_value_2;
+    exception_tb = exception_keeper_tb_2;
+    exception_lineno = exception_keeper_lineno_2;
+
+    goto function_exception_exit;
+    // End of try:
+
+    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
+    return NULL;
+
+function_exception_exit:
+    CHECK_OBJECT(par_n);
+    Py_DECREF(par_n);
+    assert(exception_type);
+    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+    return NULL;
+
+function_return_exit:
+   // Function cleanup code if any.
+    CHECK_OBJECT(par_n);
+    Py_DECREF(par_n);
+
+   // Actual function exit with return value, making sure we did not make
+   // the error status worse despite non-NULL return.
+   CHECK_OBJECT(tmp_return_value);
+   assert(had_error || !ERROR_OCCURRED());
+   return tmp_return_value;
+}
+
+
+
+static PyObject *MAKE_FUNCTION___main__$$$function__1_func_f() {
+    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
+        impl___main__$$$function__1_func_f,
+        mod_consts[9],
+#if PYTHON_VERSION >= 0x300
+        NULL,
+#endif
+        codeobj_dae4f6d4d04d5bba3b643dda2c8cd5c6,
+        NULL,
+#if PYTHON_VERSION >= 0x300
+        NULL,
+        NULL,
+#endif
+        module___main__,
+        NULL,
+        NULL,
+        0
+    );
+
+
+    return (PyObject *)result;
+}
+
+
+
+static PyObject *MAKE_FUNCTION___main__$$$function__2_func_g() {
+    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
+        impl___main__$$$function__2_func_g,
+        mod_consts[10],
+#if PYTHON_VERSION >= 0x300
+        NULL,
+#endif
+        codeobj_a27b114b6fb72fcd115f6303cc6375fb,
+        NULL,
+#if PYTHON_VERSION >= 0x300
+        NULL,
+        NULL,
+#endif
+        module___main__,
+        NULL,
+        NULL,
+        0
+    );
+
+
+    return (PyObject *)result;
+}
+
+
+
+static PyObject *MAKE_FUNCTION___main__$$$function__3_func_a_ij() {
+    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
+        impl___main__$$$function__3_func_a_ij,
+        mod_consts[15],
+#if PYTHON_VERSION >= 0x300
+        NULL,
+#endif
+        codeobj_10c93265617b8d504866c6f170ccad7b,
+        NULL,
+#if PYTHON_VERSION >= 0x300
+        NULL,
+        NULL,
+#endif
+        module___main__,
+        NULL,
+        NULL,
+        0
+    );
+
+
+    return (PyObject *)result;
+}
+
+
+
+static PyObject *MAKE_FUNCTION___main__$$$function__4_func_n_a() {
+    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
+        impl___main__$$$function__4_func_n_a,
+        mod_consts[23],
+#if PYTHON_VERSION >= 0x300
+        NULL,
+#endif
+        codeobj_7299982e0887f5ce5de7890518a855ca,
+        NULL,
+#if PYTHON_VERSION >= 0x300
+        NULL,
+        NULL,
+#endif
+        module___main__,
+        NULL,
+        NULL,
+        0
+    );
+
+
+    return (PyObject *)result;
+}
+
+
+extern void _initCompiledCellType();
+extern void _initCompiledGeneratorType();
+extern void _initCompiledFunctionType();
+extern void _initCompiledMethodType();
+extern void _initCompiledFrameType();
+
+extern PyTypeObject Nuitka_Loader_Type;
+
+#ifdef _NUITKA_PLUGIN_DILL_ENABLED
+// Provide a way to create find a function via its C code and create it back
+// in another process, useful for multiprocessing extensions like dill
+extern void registerDillPluginTables(char const *module_name, PyMethodDef *reduce_compiled_function, PyMethodDef *create_compiled_function);
+
+function_impl_code functable___main__[] = {
+    impl___main__$$$function__1_func_f,
+    impl___main__$$$function__2_func_g,
+    impl___main__$$$function__3_func_a_ij,
+    impl___main__$$$function__4_func_n_a,
+    NULL
+};
+
+static char const *_reduce_compiled_function_argnames[] = {
+    "func",
+    NULL
+};
+
+static PyObject *_reduce_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
+    PyObject *func;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:reduce_compiled_function", (char **)_reduce_compiled_function_argnames, &func, NULL)) {
+        return NULL;
+    }
+
+    if (Nuitka_Function_Check(func) == false) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "not a compiled function");
+        return NULL;
+    }
+
+    struct Nuitka_FunctionObject *function = (struct Nuitka_FunctionObject *)func;
+
+    function_impl_code *current = functable___main__;
+    int offset = 0;
+
+    while (*current != NULL) {
+        if (*current == function->m_c_code) {
+            break;
+        }
+
+        current += 1;
+        offset += 1;
+    }
+
+    if (*current == NULL) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "Cannot find compiled function in module.");
+        return NULL;
+    }
+
+    PyObject *code_object_desc = MAKE_TUPLE_EMPTY(6);
+    PyTuple_SET_ITEM0(code_object_desc, 0, function->m_code_object->co_filename);
+    PyTuple_SET_ITEM0(code_object_desc, 1, function->m_code_object->co_name);
+    PyTuple_SET_ITEM(code_object_desc, 2, PyLong_FromLong(function->m_code_object->co_firstlineno));
+    PyTuple_SET_ITEM0(code_object_desc, 3, function->m_code_object->co_varnames);
+    PyTuple_SET_ITEM(code_object_desc, 4, PyLong_FromLong(function->m_code_object->co_argcount));
+    PyTuple_SET_ITEM(code_object_desc, 5, PyLong_FromLong(function->m_code_object->co_flags));
+
+    CHECK_OBJECT_DEEP(code_object_desc);
+
+    PyObject *result = MAKE_TUPLE_EMPTY(4);
+    PyTuple_SET_ITEM(result, 0, PyLong_FromLong(offset));
+    PyTuple_SET_ITEM(result, 1, code_object_desc);
+    PyTuple_SET_ITEM0(result, 2, function->m_defaults);
+    PyTuple_SET_ITEM0(result, 3, function->m_doc != NULL ? function->m_doc : Py_None);
+
+    CHECK_OBJECT_DEEP(result);
+
+    return result;
+}
+
+static PyMethodDef _method_def_reduce_compiled_function = {"reduce_compiled_function", (PyCFunction)_reduce_compiled_function,
+                                                           METH_VARARGS | METH_KEYWORDS, NULL};
+
+static char const *_create_compiled_function_argnames[] = {
+    "func",
+    "code_object_desc",
+    "defaults",
+    "doc",
+    NULL
+};
+
+
+static PyObject *_create_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
+    CHECK_OBJECT_DEEP(args);
+
+    PyObject *func;
+    PyObject *code_object_desc;
+    PyObject *defaults;
+    PyObject *doc;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:create_compiled_function", (char **)_create_compiled_function_argnames, &func, &code_object_desc, &defaults, &doc, NULL)) {
+        return NULL;
+    }
+
+    int offset = PyLong_AsLong(func);
+
+    if (offset == -1 && ERROR_OCCURRED()) {
+        return NULL;
+    }
+
+    if (offset > sizeof(functable___main__) || offset < 0) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "Wrong offset for compiled function.");
+        return NULL;
+    }
+
+    PyObject *filename = PyTuple_GET_ITEM(code_object_desc, 0);
+    PyObject *function_name = PyTuple_GET_ITEM(code_object_desc, 1);
+    PyObject *line = PyTuple_GET_ITEM(code_object_desc, 2);
+    int line_int = PyLong_AsLong(line);
+    assert(!ERROR_OCCURRED());
+
+    PyObject *argnames = PyTuple_GET_ITEM(code_object_desc, 3);
+    PyObject *arg_count = PyTuple_GET_ITEM(code_object_desc, 4);
+    int arg_count_int = PyLong_AsLong(arg_count);
+    assert(!ERROR_OCCURRED());
+    PyObject *flags = PyTuple_GET_ITEM(code_object_desc, 5);
+    int flags_int = PyLong_AsLong(flags);
+    assert(!ERROR_OCCURRED());
+
+    PyCodeObject *code_object = MAKE_CODE_OBJECT(
+        filename,
+        line_int,
+        flags_int,
+        function_name,
+        argnames,
+        NULL, // freevars
+        arg_count_int,
+        0, // TODO: Missing kw_only_count
+        0 // TODO: Missing pos_only_count
+    );
+
+    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
+        functable___main__[offset],
+        code_object->co_name,
+#if PYTHON_VERSION >= 0x300
+        NULL, // TODO: Not transferring qualname yet
+#endif
+        code_object,
+        defaults,
+#if PYTHON_VERSION >= 0x300
+        NULL, // kwdefaults are done on the outside currently
+        NULL, // TODO: Not transferring annotations
+#endif
+        module___main__,
+        doc,
+        NULL,
+        0
+    );
+
+    return (PyObject *)result;
+}
+
+static PyMethodDef _method_def_create_compiled_function = {
+    "create_compiled_function",
+    (PyCFunction)_create_compiled_function,
+    METH_VARARGS | METH_KEYWORDS, NULL
+};
+
+
+#endif
+
+// Internal entry point for module code.
+PyObject *modulecode___main__(PyObject *module, struct Nuitka_MetaPathBasedLoaderEntry const *loader_entry) {
+    // Report entry to PGO.
+    PGO_onModuleEntered("__main__");
+
+    // Store the module for future use.
+    module___main__ = module;
+
+    // Modules can be loaded again in case of errors, avoid the init being done again.
+    static bool init_done = false;
+
+    if (init_done == false) {
+#if defined(_NUITKA_MODULE) && 1
+        // In case of an extension module loaded into a process, we need to call
+        // initialization here because that's the first and potentially only time
+        // we are going called.
+
+        // Initialize the constant values used.
+        _initBuiltinModule();
+        createGlobalConstants();
+
+        /* Initialize the compiled types of Nuitka. */
+        _initCompiledCellType();
+        _initCompiledGeneratorType();
+        _initCompiledFunctionType();
+        _initCompiledMethodType();
+        _initCompiledFrameType();
+
+        _initSlotCompare();
+#if PYTHON_VERSION >= 0x270
+        _initSlotIterNext();
+#endif
+
+        patchTypeComparison();
+
+        // Enable meta path based loader if not already done.
+#ifdef _NUITKA_TRACE
+        PRINT_STRING("__main__: Calling setupMetaPathBasedLoader().\n");
+#endif
+        setupMetaPathBasedLoader();
+
+#if PYTHON_VERSION >= 0x300
+        patchInspectModule();
+#endif
+
+#endif
+
+        /* The constants only used by this module are created now. */
+#ifdef _NUITKA_TRACE
+        PRINT_STRING("__main__: Calling createModuleConstants().\n");
+#endif
+        createModuleConstants();
+
+        /* The code objects used by this module are created now. */
+#ifdef _NUITKA_TRACE
+        PRINT_STRING("__main__: Calling createModuleCodeObjects().\n");
+#endif
+        createModuleCodeObjects();
+
+        init_done = true;
+    }
+
+    // PRINT_STRING("in init__main__\n");
+
+    moduledict___main__ = MODULE_DICT(module___main__);
+
+#ifdef _NUITKA_PLUGIN_DILL_ENABLED
+    registerDillPluginTables(loader_entry->name, &_method_def_reduce_compiled_function, &_method_def_create_compiled_function);
+#endif
+
+    // Set "__compiled__" to what version information we have.
+    UPDATE_STRING_DICT0(
+        moduledict___main__,
+        (Nuitka_StringObject *)const_str_plain___compiled__,
+        Nuitka_dunder_compiled_value
+    );
+
+    // Update "__package__" value to what it ought to be.
+    {
+#if 1
+        UPDATE_STRING_DICT0(
+            moduledict___main__,
+            (Nuitka_StringObject *)const_str_plain___package__,
+            Py_None
+        );
+#elif 0
+        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)const_str_plain___name__);
+
+        UPDATE_STRING_DICT0(
+            moduledict___main__,
+            (Nuitka_StringObject *)const_str_plain___package__,
+            module_name
+        );
+#else
+
+#if PYTHON_VERSION < 0x300
+        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)const_str_plain___name__);
+        char const *module_name_cstr = PyString_AS_STRING(module_name);
+
+        char const *last_dot = strrchr(module_name_cstr, '.');
+
+        if (last_dot != NULL) {
+            UPDATE_STRING_DICT1(
+                moduledict___main__,
+                (Nuitka_StringObject *)const_str_plain___package__,
+                PyString_FromStringAndSize(module_name_cstr, last_dot - module_name_cstr)
+            );
+        }
+#else
+        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)const_str_plain___name__);
+        Py_ssize_t dot_index = PyUnicode_Find(module_name, const_str_dot, 0, PyUnicode_GetLength(module_name), -1);
+
+        if (dot_index != -1) {
+            UPDATE_STRING_DICT1(
+                moduledict___main__,
+                (Nuitka_StringObject *)const_str_plain___package__,
+                PyUnicode_Substring(module_name, 0, dot_index)
+            );
+        }
+#endif
+#endif
+    }
+
+    CHECK_OBJECT(module___main__);
+
+    // For deep importing of a module we need to have "__builtins__", so we set
+    // it ourselves in the same way than CPython does. Note: This must be done
+    // before the frame object is allocated, or else it may fail.
+
+    if (GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)const_str_plain___builtins__) == NULL) {
+        PyObject *value = (PyObject *)builtin_module;
+
+        // Check if main module, not a dict then but the module itself.
+#if defined(_NUITKA_MODULE) || !1
+        value = PyModule_GetDict(value);
+#endif
+
+        UPDATE_STRING_DICT0(moduledict___main__, (Nuitka_StringObject *)const_str_plain___builtins__, value);
+    }
+
+#if PYTHON_VERSION >= 0x300
+    UPDATE_STRING_DICT0(moduledict___main__, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type);
+#endif
+
+#if PYTHON_VERSION >= 0x340
+// Set the "__spec__" value
+
+#if 1
+    // Main modules just get "None" as spec.
+    UPDATE_STRING_DICT0(moduledict___main__, (Nuitka_StringObject *)const_str_plain___spec__, Py_None);
+#else
+    // Other modules get a "ModuleSpec" from the standard mechanism.
+    {
+        PyObject *bootstrap_module = getImportLibBootstrapModule();
+        CHECK_OBJECT(bootstrap_module);
+
+        PyObject *_spec_from_module = PyObject_GetAttrString(bootstrap_module, "_spec_from_module");
+        CHECK_OBJECT(_spec_from_module);
+
+        PyObject *spec_value = CALL_FUNCTION_WITH_SINGLE_ARG(_spec_from_module, module___main__);
+        Py_DECREF(_spec_from_module);
+
+        // We can assume this to never fail, or else we are in trouble anyway.
+        // CHECK_OBJECT(spec_value);
+
+        if (spec_value == NULL) {
+            PyErr_PrintEx(0);
+            abort();
+        }
+
+// Mark the execution in the "__spec__" value.
+        SET_ATTRIBUTE(spec_value, const_str_plain__initializing, Py_True);
+
+        UPDATE_STRING_DICT1(moduledict___main__, (Nuitka_StringObject *)const_str_plain___spec__, spec_value);
+    }
+#endif
+#endif
+
+    // Temp variables if any
+    struct Nuitka_FrameObject *frame_9f175da657e9e7d0f3ba50c1bfc74357;
+    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
+    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
+    PyObject *exception_type = NULL;
+    PyObject *exception_value = NULL;
+    PyTracebackObject *exception_tb = NULL;
+    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
+
+    // Module code.
+    // Frame without reuse.
+    frame_9f175da657e9e7d0f3ba50c1bfc74357 = MAKE_MODULE_FRAME(codeobj_9f175da657e9e7d0f3ba50c1bfc74357, module___main__);
+
+    // Push the new frame as the currently active one, and we should be exclusively
+    // owning it.
+    pushFrameStack(frame_9f175da657e9e7d0f3ba50c1bfc74357);
+    assert(Py_REFCNT(frame_9f175da657e9e7d0f3ba50c1bfc74357) == 2);
+
+    // Framed code:
+    {
+        PyObject *tmp_imported_value_1;
+        frame_9f175da657e9e7d0f3ba50c1bfc74357->m_frame.f_lineno = 1;
+        tmp_imported_value_1 = IMPORT_HARD_SITE();
+        if (tmp_imported_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 1;
+
+            goto frame_exception_exit_1;
+        }
+    }
+    {
+        PyObject *tmp_imported_value_2;
+        frame_9f175da657e9e7d0f3ba50c1bfc74357->m_frame.f_lineno = 1;
+        tmp_imported_value_2 = IMPORT_MODULE1(mod_consts[16]);
+        if (tmp_imported_value_2 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 1;
+
+            goto frame_exception_exit_1;
+        }
+        Py_DECREF(tmp_imported_value_2);
+    }
+    {
+        PyObject *tmp_assign_source_1;
+        tmp_assign_source_1 = Py_None;
+        UPDATE_STRING_DICT0(moduledict___main__, (Nuitka_StringObject *)mod_consts[17], tmp_assign_source_1);
+    }
+    {
+        PyObject *tmp_assign_source_2;
+        tmp_assign_source_2 = mod_consts[18];
+        UPDATE_STRING_DICT0(moduledict___main__, (Nuitka_StringObject *)mod_consts[19], tmp_assign_source_2);
+    }
+    {
+        PyObject *tmp_assign_source_3;
+        tmp_assign_source_3 = Py_None;
+        UPDATE_STRING_DICT0(moduledict___main__, (Nuitka_StringObject *)mod_consts[20], tmp_assign_source_3);
+    }
+    {
+        PyObject *tmp_assign_source_4;
+        tmp_assign_source_4 = MAKE_DICT_EMPTY();
+        UPDATE_STRING_DICT1(moduledict___main__, (Nuitka_StringObject *)mod_consts[21], tmp_assign_source_4);
+    }
+    {
+        PyObject *tmp_assign_source_5;
+        PyObject *tmp_name_value_1;
+        PyObject *tmp_globals_arg_value_1;
+        PyObject *tmp_locals_arg_value_1;
+        PyObject *tmp_fromlist_value_1;
+        PyObject *tmp_level_value_1;
+        tmp_name_value_1 = mod_consts[0];
+        tmp_globals_arg_value_1 = (PyObject *)moduledict___main__;
+        tmp_locals_arg_value_1 = Py_None;
+        tmp_fromlist_value_1 = Py_None;
+        tmp_level_value_1 = mod_consts[22];
+        frame_9f175da657e9e7d0f3ba50c1bfc74357->m_frame.f_lineno = 1;
+        tmp_assign_source_5 = IMPORT_MODULE5(tmp_name_value_1, tmp_globals_arg_value_1, tmp_locals_arg_value_1, tmp_fromlist_value_1, tmp_level_value_1);
+        if (tmp_assign_source_5 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 1;
+
+            goto frame_exception_exit_1;
+        }
+        UPDATE_STRING_DICT1(moduledict___main__, (Nuitka_StringObject *)mod_consts[0], tmp_assign_source_5);
+    }
+    {
+        PyObject *tmp_assign_source_6;
+
+
+        tmp_assign_source_6 = MAKE_FUNCTION___main__$$$function__1_func_f();
+
+        UPDATE_STRING_DICT1(moduledict___main__, (Nuitka_StringObject *)mod_consts[9], tmp_assign_source_6);
+    }
+    {
+        PyObject *tmp_assign_source_7;
+
+
+        tmp_assign_source_7 = MAKE_FUNCTION___main__$$$function__2_func_g();
+
+        UPDATE_STRING_DICT1(moduledict___main__, (Nuitka_StringObject *)mod_consts[10], tmp_assign_source_7);
+    }
+    {
+        PyObject *tmp_assign_source_8;
+
+
+        tmp_assign_source_8 = MAKE_FUNCTION___main__$$$function__3_func_a_ij();
+
+        UPDATE_STRING_DICT1(moduledict___main__, (Nuitka_StringObject *)mod_consts[15], tmp_assign_source_8);
+    }
+    {
+        PyObject *tmp_assign_source_9;
+
+
+        tmp_assign_source_9 = MAKE_FUNCTION___main__$$$function__4_func_n_a();
+
+        UPDATE_STRING_DICT1(moduledict___main__, (Nuitka_StringObject *)mod_consts[23], tmp_assign_source_9);
+    }
+    {
+        PyObject *tmp_called_value_1;
+        PyObject *tmp_call_result_1;
+        PyObject *tmp_args_element_value_1;
+        PyObject *tmp_called_value_2;
+        tmp_called_value_1 = LOOKUP_BUILTIN(mod_consts[24]);
+        assert(tmp_called_value_1 != NULL);
+        tmp_called_value_2 = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)mod_consts[23]);
+
+        if (unlikely(tmp_called_value_2 == NULL)) {
+            tmp_called_value_2 = GET_MODULE_VARIABLE_VALUE_FALLBACK(mod_consts[23]);
+        }
+
+        assert(!(tmp_called_value_2 == NULL));
+        frame_9f175da657e9e7d0f3ba50c1bfc74357->m_frame.f_lineno = 27;
+        tmp_args_element_value_1 = CALL_FUNCTION_WITH_POSARGS2(tmp_called_value_2, mod_consts[25]);
+
+        if (tmp_args_element_value_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 27;
+
+            goto frame_exception_exit_1;
+        }
+        frame_9f175da657e9e7d0f3ba50c1bfc74357->m_frame.f_lineno = 27;
+        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_value_1, tmp_args_element_value_1);
+        Py_DECREF(tmp_args_element_value_1);
+        if (tmp_call_result_1 == NULL) {
+            assert(ERROR_OCCURRED());
+
+            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+
+            exception_lineno = 27;
+
+            goto frame_exception_exit_1;
+        }
+        Py_DECREF(tmp_call_result_1);
+    }
+
+    // Restore frame exception if necessary.
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_9f175da657e9e7d0f3ba50c1bfc74357);
+#endif
+    popFrameStack();
+
+    goto frame_no_exception_1;
+
+    frame_exception_exit_1:;
+#if 0
+    RESTORE_FRAME_EXCEPTION(frame_9f175da657e9e7d0f3ba50c1bfc74357);
+#endif
+
+    if (exception_tb == NULL) {
+        exception_tb = MAKE_TRACEBACK(frame_9f175da657e9e7d0f3ba50c1bfc74357, exception_lineno);
+    } else if (exception_tb->tb_frame != &frame_9f175da657e9e7d0f3ba50c1bfc74357->m_frame) {
+        exception_tb = ADD_TRACEBACK(exception_tb, frame_9f175da657e9e7d0f3ba50c1bfc74357, exception_lineno);
+    }
+
+    // Put the previous frame back on top.
+    popFrameStack();
+
+    // Return the error.
+    goto module_exception_exit;
+
+    frame_no_exception_1:;
+
+    // Report to PGO about leaving the module without error.
+    PGO_onModuleExit("__main__", false);
+
+    Py_INCREF(module___main__);
+    return module___main__;
+    module_exception_exit:
+
+#if defined(_NUITKA_MODULE) && 1
+    {
+        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict___main__, (Nuitka_StringObject *)const_str_plain___name__);
+
+        if (module_name != NULL) {
+            Nuitka_DelModule(module_name);
+        }
+    }
+#endif
+    PGO_onModuleExit("__main__", false);
+
+    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+    return NULL;
+}
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"VcsDirectoryMappings\">\n    <mapping directory=\"$PROJECT_DIR$\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/Python-Lab\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/a/pythonbase\" vcs=\"Git\" />\n    <mapping directory=\"$PROJECT_DIR$/lab13/Python-Lab\" vcs=\"Git\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
--- a/.idea/vcs.xml	(revision e27f9a8ada45ec7716a25a75c769483354ada97c)
+++ b/.idea/vcs.xml	(date 1673618722409)
@@ -2,8 +2,5 @@
 <project version="4">
   <component name="VcsDirectoryMappings">
     <mapping directory="$PROJECT_DIR$" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/Python-Lab" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/a/pythonbase" vcs="Git" />
-    <mapping directory="$PROJECT_DIR$/lab13/Python-Lab" vcs="Git" />
   </component>
 </project>
\ No newline at end of file
Index: lab15/Lab_15/task_1.build/__helpers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/__helpers.h b/lab15/Lab_15/task_1.build/__helpers.h
new file mode 100644
--- /dev/null	(date 1673971998336)
+++ b/lab15/Lab_15/task_1.build/__helpers.h	(date 1673971998336)
@@ -0,0 +1,5 @@
+#ifndef __NUITKA_CALLS_H__
+#define __NUITKA_CALLS_H__
+
+
+#endif
Index: lab15/Lab_15/task_1.build/scons-report.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/scons-report.txt b/lab15/Lab_15/task_1.build/scons-report.txt
new file mode 100644
--- /dev/null	(date 1673971998619)
+++ b/lab15/Lab_15/task_1.build/scons-report.txt	(date 1673971998619)
@@ -0,0 +1,63 @@
+CC=gcc
+CCACHE_DIR=/home/hetsu/.cache/Nuitka/ccache
+CCACHE_LOGFILE=/home/hetsu/Рабочий стол/Python/lab15/Lab_15/task_1.build/ccache-2356.txt
+CCCOM=$CC -o $TARGET -c $CFLAGS $CCFLAGS $_CCCOMCOM $SOURCES
+CFILESUFFIX=.c
+CPPDEFINES=['__NUITKA_NO_ASSERT__', '_NUITKA_CONSTANTS_FROM_INCBIN', '_NUITKA_FROZEN=0', '_NUITKA_EXE']
+CPPDEFPREFIX=-D
+CPPDEFSUFFIX=
+CPPPATH=['/usr/include/python3.10', '.', '/home/hetsu/Рабочий стол/Python/venv/lib/python3.10/site-packages/nuitka/build/include', '/home/hetsu/Рабочий стол/Python/venv/lib/python3.10/site-packages/nuitka/build/static_src']
+CPPSUFFIXES=['.c', '.C', '.cxx', '.cpp', '.c++', '.cc', '.h', '.H', '.hxx', '.hpp', '.hh', '.F', '.fpp', '.FPP', '.m', '.mm', '.S', '.spp', '.SPP', '.sx']
+CXX=g++
+CXXCOM=$CXX -o $TARGET -c $CXXFLAGS $CCFLAGS $_CCCOMCOM $SOURCES
+CXXFILESUFFIX=.cc
+INCPREFIX=-I
+INCSUFFIX=
+LDMODULE=$SHLINK
+LDMODULECOM=$LDMODULE -o $TARGET $LDMODULEFLAGS $__LDMODULEVERSIONFLAGS $__RPATH $SOURCES $_LIBDIRFLAGS $_LIBFLAGS
+LDMODULEFLAGS=$SHLINKFLAGS
+LDMODULENOVERSIONSYMLINKS=$SHLIBNOVERSIONSYMLINKS
+LDMODULEPREFIX=$SHLIBPREFIX
+LDMODULESUFFIX=$SHLIBSUFFIX
+LDMODULEVERSION=$SHLIBVERSION
+LDMODULEVERSIONFLAGS=$SHLIBVERSIONFLAGS
+LIBDIRPREFIX=-L
+LIBDIRSUFFIX=
+LIBLINKPREFIX=-l
+LIBLINKSUFFIX=
+LIBPATH=['/usr/lib']
+LIBPREFIX=lib
+LIBPREFIXES=['$LIBPREFIX']
+LIBS=['dl', 'm', 'python3.10']
+LIBSUFFIX=.a
+LIBSUFFIXES=['$LIBSUFFIX', '$SHLIBSUFFIX']
+LINK=$SMARTLINK
+LINKCOM=$LINK -o $TARGET $LINKFLAGS $__RPATH @"./@link_input.txt" $_LIBDIRFLAGS $_LIBFLAGS
+OBJPREFIX=
+OBJSUFFIX=.o
+PLATFORM=posix
+PROGPREFIX=
+PROGSUFFIX=
+RPATHPREFIX=-Wl,-rpath=
+RPATHSUFFIX=
+SHCC=$CC
+SHCCCOM=$SHCC -o $TARGET -c $SHCFLAGS $SHCCFLAGS $_CCCOMCOM $SOURCES
+SHCXX=$CXX
+SHCXXCOM=$SHCXX -o $TARGET -c $SHCXXFLAGS $SHCCFLAGS $_CCCOMCOM $SOURCES
+SHELL=sh
+SHLIBPREFIX=
+SHLIBSUFFIX=.so
+SHLINK=$LINK
+SHLINKCOM=$SHLINK -o $TARGET $SHLINKFLAGS $__SHLIBVERSIONFLAGS $__RPATH @"./@link_input.txt" $_LIBDIRFLAGS $_LIBFLAGS
+SHOBJPREFIX=$OBJPREFIX
+SHOBJSUFFIX=.os
+TARGET_ARCH=x86_64
+TEMPFILEARGJOIN= 
+TEMPFILEPREFIX=@
+TOOLS=['default', 'gnulink', 'gcc', 'g++']
+gcc_mode=True
+clang_mode=False
+msvc_mode=False
+mingw_mode=False
+clangcl_mode=False
+PATH=/home/hetsu/Рабочий стол/Python/venv/bin:/home/hetsu/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/var/lib/flatpak/exports/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/var/lib/snapd/snap/bin
Index: lab15/Lab_15/task_1.build/__helpers.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/__helpers.c b/lab15/Lab_15/task_1.build/__helpers.c
new file mode 100644
--- /dev/null	(date 1673971998336)
+++ b/lab15/Lab_15/task_1.build/__helpers.c	(date 1673971998336)
@@ -0,0 +1,7 @@
+// This file contains helper functions that are automatically created from
+// templates.
+
+#include "nuitka/prelude.h"
+
+extern PyObject *callPythonFunction(PyObject *func, PyObject *const *args, int count);
+
Index: .idea/Python.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"PYTHON_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\">\n    <content url=\"file://$MODULE_DIR$\" />\n    <orderEntry type=\"inheritedJdk\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n  <component name=\"PyDocumentationSettings\">\n    <option name=\"format\" value=\"PLAIN\" />\n    <option name=\"myDocStringFormat\" value=\"Plain\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/Python.iml b/.idea/Python.iml
--- a/.idea/Python.iml	(revision e27f9a8ada45ec7716a25a75c769483354ada97c)
+++ b/.idea/Python.iml	(date 1673618912992)
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="inheritedJdk" />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/venv" />
+    </content>
+    <orderEntry type="jdk" jdkName="Python 3.10 (Python)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
   <component name="PyDocumentationSettings">
Index: lab15/Lab_15/task_1.build/build_definitions.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/build_definitions.h b/lab15/Lab_15/task_1.build/build_definitions.h
new file mode 100644
--- /dev/null	(date 1673971998616)
+++ b/lab15/Lab_15/task_1.build/build_definitions.h	(date 1673971998616)
@@ -0,0 +1,10 @@
+#define NO_PYTHON_WARNINGS 0
+#define NUITKA_MAIN_MODULE_NAME "__main__"
+#define SYSFLAG_BYTES_WARNING 0
+#define SYSFLAG_NO_RANDOMIZATION 0
+#define SYSFLAG_NO_SITE 0
+#define SYSFLAG_OPTIMIZE 0
+#define SYSFLAG_UNBUFFERED 0
+#define SYSFLAG_UTF8 0
+#define SYSFLAG_VERBOSE 0
+#define _NUITKA_BUILD_DEFINITIONS_CATALOG "_NUITKA_BUILD_DEFINITIONS_CATALOG"
Index: lab15/Lab_15/task_1.build/static_src/CompiledCellType.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/static_src/CompiledCellType.c b/lab15/Lab_15/task_1.build/static_src/CompiledCellType.c
new file mode 100644
--- /dev/null	(date 1673971982059)
+++ b/lab15/Lab_15/task_1.build/static_src/CompiledCellType.c	(date 1673971982059)
@@ -0,0 +1,241 @@
+//     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com
+//
+//     Part of "Nuitka", an optimizing Python compiler that is compatible and
+//     integrates with CPython, but also works on its own.
+//
+//     Licensed under the Apache License, Version 2.0 (the "License");
+//     you may not use this file except in compliance with the License.
+//     You may obtain a copy of the License at
+//
+//        http://www.apache.org/licenses/LICENSE-2.0
+//
+//     Unless required by applicable law or agreed to in writing, software
+//     distributed under the License is distributed on an "AS IS" BASIS,
+//     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//     See the License for the specific language governing permissions and
+//     limitations under the License.
+//
+
+#include "nuitka/prelude.h"
+
+#include "nuitka/freelists.h"
+
+#define MAX_CELL_FREE_LIST_COUNT 1000
+static struct Nuitka_CellObject *free_list_cells = NULL;
+static int free_list_cells_count = 0;
+
+static void Nuitka_Cell_tp_dealloc(struct Nuitka_CellObject *cell) {
+    Nuitka_GC_UnTrack(cell);
+    Py_XDECREF(cell->ob_ref);
+
+    releaseToFreeList(free_list_cells, cell, MAX_CELL_FREE_LIST_COUNT);
+}
+
+#if PYTHON_VERSION < 0x300
+static int Nuitka_Cell_tp_compare(struct Nuitka_CellObject *cell_a, struct Nuitka_CellObject *cell_b) {
+    /* Empty cells compare specifically different. */
+    if (cell_a->ob_ref == NULL) {
+        if (cell_b->ob_ref == NULL) {
+            return 0;
+        }
+
+        return -1;
+    }
+
+    if (cell_b->ob_ref == NULL) {
+        return 1;
+    }
+
+    return PyObject_Compare(cell_a->ob_ref, cell_b->ob_ref);
+}
+#else
+static PyObject *Nuitka_Cell_tp_richcompare(PyObject *a, PyObject *b, int op) {
+    PyObject *result;
+
+    CHECK_OBJECT(a);
+    CHECK_OBJECT(b);
+
+    if (unlikely(!Nuitka_Cell_Check(a) || !Nuitka_Cell_Check(b))) {
+        result = Py_NotImplemented;
+        Py_INCREF(result);
+
+        return result;
+    }
+
+    /* Now just dereference, and compare from there by contents. */
+    a = ((struct Nuitka_CellObject *)a)->ob_ref;
+    b = ((struct Nuitka_CellObject *)b)->ob_ref;
+
+    if (a != NULL && b != NULL) {
+        return PyObject_RichCompare(a, b, op);
+    }
+
+    int res = (b == NULL) - (a == NULL);
+    switch (op) {
+    case Py_EQ:
+        result = BOOL_FROM(res == 0);
+        break;
+    case Py_NE:
+        result = BOOL_FROM(res != 0);
+        break;
+    case Py_LE:
+        result = BOOL_FROM(res <= 0);
+        break;
+    case Py_GE:
+        result = BOOL_FROM(res >= 0);
+        break;
+    case Py_LT:
+        result = BOOL_FROM(res < 0);
+        break;
+    case Py_GT:
+        result = BOOL_FROM(res > 0);
+        break;
+    default:
+        PyErr_BadArgument();
+        return NULL;
+    }
+
+    Py_INCREF(result);
+    return result;
+}
+
+#endif
+
+static PyObject *Nuitka_Cell_tp_repr(struct Nuitka_CellObject *cell) {
+    if (cell->ob_ref == NULL) {
+        return Nuitka_String_FromFormat("<compiled_cell at %p: empty>", cell);
+    } else {
+        return Nuitka_String_FromFormat("<compiled_cell at %p: %s object at %p>", cell, cell->ob_ref->ob_type->tp_name,
+                                        cell->ob_ref);
+    }
+}
+
+static int Nuitka_Cell_tp_traverse(struct Nuitka_CellObject *cell, visitproc visit, void *arg) {
+    Py_VISIT(cell->ob_ref);
+
+    return 0;
+}
+
+static int Nuitka_Cell_tp_clear(struct Nuitka_CellObject *cell) {
+    Py_CLEAR(cell->ob_ref);
+
+    return 0;
+}
+
+static PyObject *Nuitka_Cell_get_contents(struct Nuitka_CellObject *cell, void *closure) {
+    if (cell->ob_ref == NULL) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_ValueError, "Cell is empty");
+        return NULL;
+    }
+
+    Py_INCREF(cell->ob_ref);
+    return cell->ob_ref;
+}
+
+#if PYTHON_VERSION >= 0x370
+static int Nuitka_Cell_set_contents(struct Nuitka_CellObject *cell, PyObject *value) {
+    PyObject *old = cell->ob_ref;
+
+    if (old != NULL && value == NULL) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_RuntimeError, "cell_contents cannot be used to delete values Nuitka");
+        return -1;
+    }
+
+    cell->ob_ref = value;
+    Py_XINCREF(value);
+    Py_XDECREF(old);
+
+    return 0;
+}
+#endif
+
+static PyGetSetDef Nuitka_Cell_getsetlist[] = {
+#if PYTHON_VERSION < 0x370
+    {(char *)"cell_contents", (getter)Nuitka_Cell_get_contents, NULL, NULL},
+#else
+    {(char *)"cell_contents", (getter)Nuitka_Cell_get_contents, (setter)Nuitka_Cell_set_contents, NULL},
+#endif
+    {NULL}};
+
+PyTypeObject Nuitka_Cell_Type = {
+    PyVarObject_HEAD_INIT(NULL, 0) "compiled_cell",
+    sizeof(struct Nuitka_CellObject),   /* tp_basicsize */
+    0,                                  /* tp_itemsize */
+    (destructor)Nuitka_Cell_tp_dealloc, /* tp_dealloc */
+    0,                                  /* tp_print */
+    0,                                  /* tp_getattr */
+    0,                                  /* tp_setattr */
+#if PYTHON_VERSION < 0x300
+    (cmpfunc)Nuitka_Cell_tp_compare, /* tp_compare */
+#else
+    0,                          /* tp_reserved */
+#endif
+    (reprfunc)Nuitka_Cell_tp_repr,           /* tp_repr */
+    0,                                       /* tp_as_number */
+    0,                                       /* tp_as_sequence */
+    0,                                       /* tp_as_mapping */
+    0,                                       /* tp_hash */
+    0,                                       /* tp_call */
+    0,                                       /* tp_str */
+    PyObject_GenericGetAttr,                 /* tp_getattro */
+    0,                                       /* tp_setattro */
+    0,                                       /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+    0,                                       /* tp_doc */
+    (traverseproc)Nuitka_Cell_tp_traverse,   /* tp_traverse */
+    (inquiry)Nuitka_Cell_tp_clear,           /* tp_clear */
+#if PYTHON_VERSION < 0x300
+    0, /* tp_richcompare */
+#else
+    Nuitka_Cell_tp_richcompare, /* tp_richcompare */
+#endif
+    0,                      /* tp_weaklistoffset */
+    0,                      /* tp_iter */
+    0,                      /* tp_iternext */
+    0,                      /* tp_methods */
+    0,                      /* tp_members */
+    Nuitka_Cell_getsetlist, /* tp_getset */
+};
+
+void _initCompiledCellType(void) { PyType_Ready(&Nuitka_Cell_Type); }
+
+struct Nuitka_CellObject *Nuitka_Cell_Empty(void) {
+    struct Nuitka_CellObject *result;
+
+    allocateFromFreeListFixed(free_list_cells, struct Nuitka_CellObject, Nuitka_Cell_Type);
+
+    result->ob_ref = NULL;
+
+    Nuitka_GC_Track(result);
+
+    return result;
+}
+
+struct Nuitka_CellObject *Nuitka_Cell_New0(PyObject *value) {
+    CHECK_OBJECT(value);
+
+    struct Nuitka_CellObject *result;
+
+    allocateFromFreeListFixed(free_list_cells, struct Nuitka_CellObject, Nuitka_Cell_Type);
+
+    result->ob_ref = value;
+    Py_INCREF(value);
+
+    Nuitka_GC_Track(result);
+
+    return result;
+}
+
+struct Nuitka_CellObject *Nuitka_Cell_New1(PyObject *value) {
+    CHECK_OBJECT(value);
+
+    struct Nuitka_CellObject *result;
+
+    allocateFromFreeListFixed(free_list_cells, struct Nuitka_CellObject, Nuitka_Cell_Type);
+
+    result->ob_ref = value;
+
+    Nuitka_GC_Track(result);
+
+    return result;
+}
\ No newline at end of file
Index: lab15/Lab_15/task_1.build/static_src/InspectPatcher.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/static_src/InspectPatcher.c b/lab15/Lab_15/task_1.build/static_src/InspectPatcher.c
new file mode 100644
--- /dev/null	(date 1673971982086)
+++ b/lab15/Lab_15/task_1.build/static_src/InspectPatcher.c	(date 1673971982086)
@@ -0,0 +1,349 @@
+//     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com
+//
+//     Part of "Nuitka", an optimizing Python compiler that is compatible and
+//     integrates with CPython, but also works on its own.
+//
+//     Licensed under the Apache License, Version 2.0 (the "License");
+//     you may not use this file except in compliance with the License.
+//     You may obtain a copy of the License at
+//
+//        http://www.apache.org/licenses/LICENSE-2.0
+//
+//     Unless required by applicable law or agreed to in writing, software
+//     distributed under the License is distributed on an "AS IS" BASIS,
+//     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//     See the License for the specific language governing permissions and
+//     limitations under the License.
+//
+/**
+ * This is responsible for updating parts of CPython to better work with Nuitka
+ * by replacing CPython implementations with enhanced versions.
+ */
+
+#include "nuitka/prelude.h"
+
+#if PYTHON_VERSION >= 0x300
+static PyObject *module_inspect;
+#if PYTHON_VERSION >= 0x350
+static PyObject *module_types;
+#endif
+
+static char *kw_list_object[] = {(char *)"object", NULL};
+
+// spell-checker: ignore getgeneratorstate, getcoroutinestate
+
+static PyObject *old_getgeneratorstate = NULL;
+
+static PyObject *_inspect_getgeneratorstate_replacement(PyObject *self, PyObject *args, PyObject *kwds) {
+    PyObject *object;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:getgeneratorstate", kw_list_object, &object, NULL)) {
+        return NULL;
+    }
+
+    if (Nuitka_Generator_Check(object)) {
+        struct Nuitka_GeneratorObject *generator = (struct Nuitka_GeneratorObject *)object;
+
+        if (generator->m_running) {
+            return PyObject_GetAttrString(module_inspect, "GEN_RUNNING");
+        } else if (generator->m_status == status_Finished) {
+            return PyObject_GetAttrString(module_inspect, "GEN_CLOSED");
+        } else if (generator->m_status == status_Unused) {
+            return PyObject_GetAttrString(module_inspect, "GEN_CREATED");
+        } else {
+            return PyObject_GetAttrString(module_inspect, "GEN_SUSPENDED");
+        }
+    } else {
+        return old_getgeneratorstate->ob_type->tp_call(old_getgeneratorstate, args, kwds);
+    }
+}
+
+#if PYTHON_VERSION >= 0x350
+static PyObject *old_getcoroutinestate = NULL;
+
+static PyObject *_inspect_getcoroutinestate_replacement(PyObject *self, PyObject *args, PyObject *kwds) {
+    PyObject *object;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:getcoroutinestate", kw_list_object, &object, NULL)) {
+        return NULL;
+    }
+
+    if (Nuitka_Coroutine_Check(object)) {
+        struct Nuitka_CoroutineObject *coroutine = (struct Nuitka_CoroutineObject *)object;
+
+        if (coroutine->m_running) {
+            return PyObject_GetAttrString(module_inspect, "CORO_RUNNING");
+        } else if (coroutine->m_status == status_Finished) {
+            return PyObject_GetAttrString(module_inspect, "CORO_CLOSED");
+        } else if (coroutine->m_status == status_Unused) {
+            return PyObject_GetAttrString(module_inspect, "CORO_CREATED");
+        } else {
+            return PyObject_GetAttrString(module_inspect, "CORO_SUSPENDED");
+        }
+    } else {
+        return old_getcoroutinestate->ob_type->tp_call(old_getcoroutinestate, args, kwds);
+    }
+}
+
+static PyObject *old_types_coroutine = NULL;
+
+static char *kw_list_coroutine[] = {(char *)"func", NULL};
+
+static PyObject *_types_coroutine_replacement(PyObject *self, PyObject *args, PyObject *kwds) {
+    PyObject *func;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:coroutine", kw_list_coroutine, &func, NULL)) {
+        return NULL;
+    }
+
+    if (Nuitka_Function_Check(func)) {
+        struct Nuitka_FunctionObject *function = (struct Nuitka_FunctionObject *)func;
+
+        if (function->m_code_object->co_flags & CO_GENERATOR) {
+            function->m_code_object->co_flags |= 0x100;
+        }
+    }
+
+    return old_types_coroutine->ob_type->tp_call(old_types_coroutine, args, kwds);
+}
+
+#endif
+
+#endif
+
+#if PYTHON_VERSION >= 0x300
+static PyMethodDef _method_def_inspect_getgeneratorstate_replacement = {
+    "getgeneratorstate", (PyCFunction)_inspect_getgeneratorstate_replacement, METH_VARARGS | METH_KEYWORDS, NULL};
+
+#if PYTHON_VERSION >= 0x350
+static PyMethodDef _method_def_inspect_getcoroutinestate_replacement = {
+    "getcoroutinestate", (PyCFunction)_inspect_getcoroutinestate_replacement, METH_VARARGS | METH_KEYWORDS, NULL};
+
+static PyMethodDef _method_def_types_coroutine_replacement = {"coroutine", (PyCFunction)_types_coroutine_replacement,
+                                                              METH_VARARGS | METH_KEYWORDS, NULL};
+
+#endif
+
+/* Replace inspect functions with ones that handle compiles types too. */
+void patchInspectModule(void) {
+    static bool is_done = false;
+    if (is_done)
+        return;
+
+#if PYTHON_VERSION >= 0x300
+#if defined(_NUITKA_EXE) && !defined(_NUITKA_STANDALONE)
+    // May need to import the "site" module, because otherwise the patching can
+    // fail with it being unable to load it (yet)
+    if (Py_NoSiteFlag == 0) {
+        PyObject *site_module = IMPORT_MODULE5(const_str_plain_site, Py_None, Py_None, const_tuple_empty, const_int_0);
+
+        if (site_module == NULL) {
+            // Ignore "ImportError", having a "site" module is not a must.
+            CLEAR_ERROR_OCCURRED();
+        }
+    }
+#endif
+
+    // TODO: Change this into an import hook that is executed after it is imported.
+    module_inspect = IMPORT_MODULE5(const_str_plain_inspect, Py_None, Py_None, const_tuple_empty, const_int_0);
+
+    if (module_inspect == NULL) {
+        PyErr_PrintEx(0);
+        Py_Exit(1);
+    }
+    CHECK_OBJECT(module_inspect);
+
+    // Patch "inspect.getgeneratorstate" unless it is already patched.
+    old_getgeneratorstate = PyObject_GetAttrString(module_inspect, "getgeneratorstate");
+    CHECK_OBJECT(old_getgeneratorstate);
+
+    if (PyFunction_Check(old_getgeneratorstate)) {
+        PyObject *inspect_getgeneratorstate_replacement =
+            PyCFunction_New(&_method_def_inspect_getgeneratorstate_replacement, NULL);
+        CHECK_OBJECT(inspect_getgeneratorstate_replacement);
+
+        PyObject_SetAttrString(module_inspect, "getgeneratorstate", inspect_getgeneratorstate_replacement);
+    }
+
+#if PYTHON_VERSION >= 0x350
+    // Patch "inspect.getcoroutinestate" unless it is already patched.
+    old_getcoroutinestate = PyObject_GetAttrString(module_inspect, "getcoroutinestate");
+    CHECK_OBJECT(old_getcoroutinestate);
+
+    if (PyFunction_Check(old_getcoroutinestate)) {
+        PyObject *inspect_getcoroutinestate_replacement =
+            PyCFunction_New(&_method_def_inspect_getcoroutinestate_replacement, NULL);
+        CHECK_OBJECT(inspect_getcoroutinestate_replacement);
+
+        PyObject_SetAttrString(module_inspect, "getcoroutinestate", inspect_getcoroutinestate_replacement);
+    }
+
+    module_types = IMPORT_MODULE5(const_str_plain_types, Py_None, Py_None, const_tuple_empty, const_int_0);
+
+    if (module_types == NULL) {
+        PyErr_PrintEx(0);
+        Py_Exit(1);
+    }
+    CHECK_OBJECT(module_types);
+
+    // Patch "types.coroutine" unless it is already patched.
+    old_types_coroutine = PyObject_GetAttrString(module_types, "coroutine");
+    CHECK_OBJECT(old_types_coroutine);
+
+    if (PyFunction_Check(old_types_coroutine)) {
+        PyObject *types_coroutine_replacement = PyCFunction_New(&_method_def_types_coroutine_replacement, NULL);
+        CHECK_OBJECT(types_coroutine_replacement);
+
+        PyObject_SetAttrString(module_types, "coroutine", types_coroutine_replacement);
+    }
+
+    static char const *wrapper_enhancement_code = "\n\
+import types\n\
+_old_GeneratorWrapper = types._GeneratorWrapper\n\
+class GeneratorWrapperEnhanced(_old_GeneratorWrapper):\n\
+    def __init__(self, gen):\n\
+        _old_GeneratorWrapper.__init__(self, gen)\n\
+\n\
+        if hasattr(gen, 'gi_code'):\n\
+            if gen.gi_code.co_flags & 0x0020:\n\
+                self._GeneratorWrapper__isgen = True\n\
+\n\
+types._GeneratorWrapper = GeneratorWrapperEnhanced\
+";
+
+    PyObject *wrapper_enhancement_code_object = Py_CompileString(wrapper_enhancement_code, "<exec>", Py_file_input);
+    CHECK_OBJECT(wrapper_enhancement_code_object);
+
+    {
+        PyObject *module = PyImport_ExecCodeModule("nuitka_types_patch", wrapper_enhancement_code_object);
+        CHECK_OBJECT(module);
+
+        bool bool_res = Nuitka_DelModuleString("nuitka_types_patch");
+        assert(bool_res != false);
+
+        Py_DECREF(module);
+    }
+
+#endif
+
+#endif
+
+    is_done = true;
+}
+#endif
+
+static richcmpfunc original_PyType_tp_richcompare = NULL;
+
+static PyObject *Nuitka_type_tp_richcompare(PyObject *a, PyObject *b, int op) {
+    if (likely(op == Py_EQ || op == Py_NE)) {
+        if (a == (PyObject *)&Nuitka_Function_Type) {
+            a = (PyObject *)&PyFunction_Type;
+        } else if (a == (PyObject *)&Nuitka_Method_Type) {
+            a = (PyObject *)&PyMethod_Type;
+        } else if (a == (PyObject *)&Nuitka_Generator_Type) {
+            a = (PyObject *)&PyGen_Type;
+#if PYTHON_VERSION >= 0x350
+        } else if (a == (PyObject *)&Nuitka_Coroutine_Type) {
+            a = (PyObject *)&PyCoro_Type;
+#endif
+#if PYTHON_VERSION >= 0x360
+        } else if (a == (PyObject *)&Nuitka_Asyncgen_Type) {
+            a = (PyObject *)&PyAsyncGen_Type;
+#endif
+        }
+
+        if (b == (PyObject *)&Nuitka_Function_Type) {
+            b = (PyObject *)&PyFunction_Type;
+        } else if (b == (PyObject *)&Nuitka_Method_Type) {
+            b = (PyObject *)&PyMethod_Type;
+        } else if (b == (PyObject *)&Nuitka_Generator_Type) {
+            b = (PyObject *)&PyGen_Type;
+#if PYTHON_VERSION >= 0x350
+        } else if (b == (PyObject *)&Nuitka_Coroutine_Type) {
+            b = (PyObject *)&PyCoro_Type;
+#endif
+#if PYTHON_VERSION >= 0x360
+        } else if (b == (PyObject *)&Nuitka_Asyncgen_Type) {
+            b = (PyObject *)&PyAsyncGen_Type;
+#endif
+        }
+    }
+
+    CHECK_OBJECT(a);
+    CHECK_OBJECT(b);
+
+    assert(original_PyType_tp_richcompare);
+
+    return original_PyType_tp_richcompare(a, b, op);
+}
+
+void patchTypeComparison(void) {
+    if (original_PyType_tp_richcompare == NULL) {
+        original_PyType_tp_richcompare = PyType_Type.tp_richcompare;
+        PyType_Type.tp_richcompare = Nuitka_type_tp_richcompare;
+    }
+}
+
+#include "nuitka/freelists.h"
+
+#define MAX_TRACEBACK_FREE_LIST_COUNT 1000
+static PyTracebackObject *free_list_tracebacks = NULL;
+static int free_list_tracebacks_count = 0;
+
+// Create a traceback for a given frame, using a free list hacked into the
+// existing type.
+PyTracebackObject *MAKE_TRACEBACK(struct Nuitka_FrameObject *frame, int lineno) {
+#if 0
+    PRINT_STRING("MAKE_TRACEBACK: Enter");
+    PRINT_ITEM((PyObject *)frame);
+    PRINT_NEW_LINE();
+
+    dumpFrameStack();
+#endif
+
+    CHECK_OBJECT(frame);
+    assert(lineno != 0);
+
+    PyTracebackObject *result;
+
+    allocateFromFreeListFixed(free_list_tracebacks, PyTracebackObject, PyTraceBack_Type);
+
+    result->tb_next = NULL;
+    result->tb_frame = (PyFrameObject *)frame;
+    Py_INCREF(frame);
+
+    result->tb_lasti = 0;
+    result->tb_lineno = lineno;
+
+    Nuitka_GC_Track(result);
+
+    return result;
+}
+
+static void Nuitka_tb_dealloc(PyTracebackObject *tb) {
+    // Need to use official method as it checks for recursion.
+    PyObject_GC_UnTrack(tb);
+
+#if 0
+#if PYTHON_VERSION >= 0x380
+    Py_TRASHCAN_BEGIN(tb, Nuitka_tb_dealloc);
+#else
+    Py_TRASHCAN_SAFE_BEGIN(tb);
+#endif
+#endif
+
+    Py_XDECREF(tb->tb_next);
+    Py_XDECREF(tb->tb_frame);
+
+    releaseToFreeList(free_list_tracebacks, tb, MAX_TRACEBACK_FREE_LIST_COUNT);
+
+#if 0
+#if PYTHON_VERSION >= 0x380
+    Py_TRASHCAN_END;
+#else
+    Py_TRASHCAN_SAFE_END(tb);
+#endif
+#endif
+}
+
+void patchTracebackDealloc(void) { PyTraceBack_Type.tp_dealloc = (destructor)Nuitka_tb_dealloc; }
Index: lab15/Lab_15/task_1.build/static_src/MainProgram.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/static_src/MainProgram.c b/lab15/Lab_15/task_1.build/static_src/MainProgram.c
new file mode 100644
--- /dev/null	(date 1673971982086)
+++ b/lab15/Lab_15/task_1.build/static_src/MainProgram.c	(date 1673971982086)
@@ -0,0 +1,1201 @@
+//     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com
+//
+//     Part of "Nuitka", an optimizing Python compiler that is compatible and
+//     integrates with CPython, but also works on its own.
+//
+//     Licensed under the Apache License, Version 2.0 (the "License");
+//     you may not use this file except in compliance with the License.
+//     You may obtain a copy of the License at
+//
+//        http://www.apache.org/licenses/LICENSE-2.0
+//
+//     Unless required by applicable law or agreed to in writing, software
+//     distributed under the License is distributed on an "AS IS" BASIS,
+//     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//     See the License for the specific language governing permissions and
+//     limitations under the License.
+//
+/* The main program for a compiled program.
+ *
+ * It needs to prepare the interpreter and then loads and executes
+ * the "__main__" module.
+ *
+ */
+
+#if defined(_WIN32)
+#include <windows.h>
+#endif
+
+#include "nuitka/prelude.h"
+
+#ifndef __IDE_ONLY__
+// Generated during build with optional defines.
+#include "build_definitions.h"
+#else
+// For the IDE to know these exist.
+#define SYSFLAG_PY3K_WARNING 0
+#define SYSFLAG_DIVISION_WARNING 0
+#define SYSFLAG_UNICODE 0
+#define SYSFLAG_OPTIMIZE 0
+#define SYSFLAG_NO_SITE 0
+#define SYSFLAG_VERBOSE 0
+#define SYSFLAG_BYTES_WARNING 0
+#define SYSFLAG_UTF8 0
+#define SYSFLAG_UNBUFFERED 0
+#endif
+
+#ifndef NUITKA_MAIN_MODULE_NAME
+#define NUITKA_MAIN_MODULE_NAME "__main__"
+#endif
+
+extern PyCodeObject *codeobj_main;
+
+/* For later use in "Py_GetArgcArgv" we expose the needed value  */
+#if PYTHON_VERSION >= 0x300
+static wchar_t **orig_argv;
+#else
+static char **orig_argv;
+#endif
+static int orig_argc;
+
+#if _NUITKA_FROZEN > 0
+extern void copyFrozenModulesTo(struct _frozen *destination);
+
+// The original frozen modules list.
+#if PYTHON_VERSION < 0x340
+static struct _frozen *old_frozen = NULL;
+#else
+static struct _frozen const *old_frozen = NULL;
+#endif
+
+static void prepareFrozenModules(void) {
+    // Tell the CPython library to use our pre-compiled modules as frozen
+    // modules. This for those modules/packages like "encoding" that will be
+    // loaded during "Py_Initialize" already, for the others they may be
+    // compiled.
+
+    // The CPython library before 3.11 has some pre-existing frozen modules, we
+    // only append to those to keep compatible.
+    struct _frozen const *search = PyImport_FrozenModules;
+    int pre_existing_count;
+
+    if (search) {
+        while (search->name) {
+            search++;
+        }
+        pre_existing_count = (int)(search - PyImport_FrozenModules);
+    } else {
+        pre_existing_count = 0;
+    }
+
+    // Allocate new memory and merge the tables. Keeping the old ones has the
+    // advantage that e.g. "import this" is going to be compatible, and there
+    // might be Python flavors that add more.
+    struct _frozen *merged =
+        (struct _frozen *)malloc(sizeof(struct _frozen) * (_NUITKA_FROZEN + pre_existing_count + 1));
+
+    memcpy(merged, PyImport_FrozenModules, pre_existing_count * sizeof(struct _frozen));
+    copyFrozenModulesTo(merged + pre_existing_count);
+    old_frozen = PyImport_FrozenModules;
+    PyImport_FrozenModules = merged;
+}
+#endif
+
+#ifdef _NUITKA_STANDALONE
+
+static void prepareStandaloneEnvironment(void) {
+
+    /* Setup environment variables to tell CPython that we would like it to use
+     * the provided binary directory as the place to look for DLLs and for
+     * extension modules.
+     */
+#if defined(_WIN32)
+    SetDllDirectoryW(getBinaryDirectoryWideChars());
+#endif
+
+#if PYTHON_VERSION < 0x300
+    char *binary_directory = (char *)getBinaryDirectoryHostEncoded();
+    NUITKA_PRINTF_TRACE("main(): Binary dir is %s\n", binary_directory);
+
+    Py_SetPythonHome(binary_directory);
+#else
+    wchar_t *binary_directory = (wchar_t *)getBinaryDirectoryWideChars();
+    NUITKA_PRINTF_TRACE("main(): Binary dir is %S\n", binary_directory);
+
+    Py_SetPythonHome(binary_directory);
+#endif
+}
+
+static void restoreStandaloneEnvironment(void) {
+    /* Make sure to use the optimal value for standalone mode only. */
+#if PYTHON_VERSION < 0x300
+    PySys_SetPath((char *)getBinaryDirectoryHostEncoded());
+    // NUITKA_PRINTF_TRACE("Final PySys_GetPath is 's'.\n", PySys_GetPath());
+#else
+    PySys_SetPath(getBinaryDirectoryWideChars());
+    Py_SetPath(getBinaryDirectoryWideChars());
+    NUITKA_PRINTF_TRACE("Final Py_GetPath is '%ls'.\n", Py_GetPath());
+#endif
+}
+
+#endif
+
+extern void _initCompiledCellType();
+extern void _initCompiledGeneratorType();
+extern void _initCompiledFunctionType();
+extern void _initCompiledMethodType();
+extern void _initCompiledFrameType();
+
+#include <locale.h>
+
+#ifdef _WIN32
+#define _NUITKA_NATIVE_WCHAR_ARGV 1
+#else
+#define _NUITKA_NATIVE_WCHAR_ARGV 0
+#endif
+
+// Types of command line arguments are different between Python2/3.
+#if PYTHON_VERSION >= 0x300 && _NUITKA_NATIVE_WCHAR_ARGV == 0
+static wchar_t **convertCommandLineParameters(int argc, char **argv) {
+    // Originally taken from CPython3: There seems to be no sane way to use
+    static wchar_t **argv_copy;
+    argv_copy = (wchar_t **)PyMem_MALLOC(sizeof(wchar_t *) * argc);
+
+    // Temporarily disable locale for conversions to not use it.
+    char *old_locale = strdup(setlocale(LC_ALL, NULL));
+    setlocale(LC_ALL, "");
+
+    for (int i = 0; i < argc; i++) {
+#if PYTHON_VERSION >= 0x350
+        argv_copy[i] = Py_DecodeLocale(argv[i], NULL);
+#elif defined(__APPLE__) && PYTHON_VERSION >= 0x320
+        argv_copy[i] = _Py_DecodeUTF8_surrogateescape(argv[i], strlen(argv[i]));
+#else
+        argv_copy[i] = _Py_char2wchar(argv[i], NULL);
+#endif
+
+        assert(argv_copy[i]);
+    }
+
+    setlocale(LC_ALL, old_locale);
+    free(old_locale);
+
+    return argv_copy;
+}
+#endif
+
+static int HANDLE_PROGRAM_EXIT(void) {
+    int exit_code;
+
+    if (ERROR_OCCURRED()) {
+#if PYTHON_VERSION >= 0x300
+        /* Remove the frozen importlib traceback part, which would not be compatible. */
+        PyThreadState *thread_state = PyThreadState_GET();
+
+        while (thread_state->curexc_traceback) {
+            PyTracebackObject *tb = (PyTracebackObject *)thread_state->curexc_traceback;
+            PyFrameObject *frame = tb->tb_frame;
+
+            if (0 == strcmp(PyUnicode_AsUTF8(Nuitka_Frame_GetCodeObject(frame)->co_filename),
+                            "<frozen importlib._bootstrap>")) {
+                thread_state->curexc_traceback = (PyObject *)tb->tb_next;
+                Py_INCREF(tb->tb_next);
+
+                continue;
+            }
+
+            break;
+        }
+#endif
+
+        PyErr_PrintEx(0);
+
+        exit_code = 1;
+    } else {
+        exit_code = 0;
+    }
+
+    return exit_code;
+}
+
+static PyObject *EXECUTE_MAIN_MODULE(char const *module_name) {
+    NUITKA_INIT_PROGRAM_LATE(module_name);
+
+#if NUITKA_MAIN_PACKAGE_MODE
+    {
+        char const *w = module_name;
+
+        for (;;) {
+            char const *s = strchr(w, '.');
+
+            if (s == NULL) {
+                break;
+            }
+
+            w = s + 1;
+
+            char buffer[1024];
+            memset(buffer, 0, sizeof(buffer));
+            memcpy(buffer, module_name, s - module_name);
+
+            PyObject *result = IMPORT_EMBEDDED_MODULE(buffer);
+
+            if (ERROR_OCCURRED()) {
+                return result;
+            }
+        }
+    }
+#endif
+
+    return IMPORT_EMBEDDED_MODULE(module_name);
+}
+
+#ifdef _NUITKA_PLUGIN_WINDOWS_SERVICE_ENABLED
+extern void SvcInstall();
+extern void SvcLaunchService();
+
+// Callback from Windows Service logic.
+DWORD WINAPI SvcStartPython(LPVOID lpParam) {
+    if (lpParam == NULL) {
+        EXECUTE_MAIN_MODULE(NUITKA_MAIN_MODULE_NAME);
+
+        // TODO: Log exception and call ReportSvcStatus
+        if (ERROR_OCCURRED()) {
+            return 1;
+        } else {
+            return 0;
+        }
+    } else {
+        PyErr_SetInterrupt();
+        return 0;
+    }
+}
+#endif
+
+// This is a multiprocessing fork
+static bool is_multiprocessing_fork = false;
+// This is a multiprocessing resource tracker.
+static PyObject *multiprocessing_resource_tracker_arg = NULL;
+
+// Parse the command line parameters and provide it to "sys" built-in module,
+// as well as decide if it's a multiprocessing usage.
+#if _NUITKA_NATIVE_WCHAR_ARGV == 0
+static void setCommandLineParameters(int argc, char **argv, bool initial) {
+#else
+static void setCommandLineParameters(int argc, wchar_t **argv, bool initial) {
+#endif
+    if (initial) {
+        /* We might need to handle special parameters from plugins that are
+           very deeply woven into command line handling. These are right now
+           multiprocessing, which indicates that it's forking via extra
+           command line argument. And Windows Service indicates need to
+           install and exit here too.
+         */
+        for (int i = 1; i < argc; i++) {
+#if _NUITKA_NATIVE_WCHAR_ARGV == 0
+            if ((strcmp(argv[i], "--multiprocessing-fork")) == 0 && (i + 1 < argc))
+#else
+            if ((wcscmp(argv[i], L"--multiprocessing-fork")) == 0 && (i + 1 < argc))
+#endif
+            {
+                is_multiprocessing_fork = true;
+                break;
+            }
+
+#if _NUITKA_NATIVE_WCHAR_ARGV == 0
+            if ((strcmp(argv[i], "--multiprocessing-resource-tracker")) == 0 && (i + 1 < argc))
+#else
+            if ((wcscmp(argv[i], L"--multiprocessing-resource-tracker")) == 0 && (i + 1 < argc))
+#endif
+            {
+#if _NUITKA_NATIVE_WCHAR_ARGV == 0
+                multiprocessing_resource_tracker_arg = PyInt_FromLong(atoi(argv[i + 1]));
+#else
+                multiprocessing_resource_tracker_arg = PyLong_FromLong(_wtoi(argv[i + 1]));
+#endif
+                break;
+            }
+
+#ifdef _NUITKA_PLUGIN_WINDOWS_SERVICE_ENABLED
+            if (i == 1) {
+#if PYTHON_VERSION < 0x300
+                if (strcmp(argv[i], "install") == 0)
+#else
+                if (wcscmp(argv[i], L"install") == 0)
+#endif
+                {
+                    NUITKA_PRINT_TRACE("main(): Calling plugin SvcInstall().");
+
+                    SvcInstall();
+                    NUITKA_CANNOT_GET_HERE("SvcInstall must not return");
+                }
+            }
+#endif
+        }
+    }
+}
+
+#if defined(_WIN32) && PYTHON_VERSION >= 0x300 && (SYSFLAG_NO_RANDOMIZATION == 1 || SYSFLAG_UNBUFFERED == 1)
+static void setenv(char const *name, char const *value, int overwrite) {
+    assert(overwrite);
+
+    SetEnvironmentVariableA(name, value);
+}
+
+static void unsetenv(char const *name) { SetEnvironmentVariableA(name, NULL); }
+#endif
+
+#if _DEBUG_REFCOUNTS
+static void PRINT_REFCOUNTS(void) {
+    PRINT_STRING("REFERENCE counts at program end:\n");
+    PRINT_STRING("active | allocated | released\n");
+    PRINT_FORMAT("Compiled Coroutines: %d | %d | %d\n", count_active_Nuitka_Coroutine_Type,
+                 count_allocated_Nuitka_Coroutine_Type, count_released_Nuitka_Coroutine_Type);
+    PRINT_FORMAT("Compiled Coroutines Wrappers: %d | %d | %d\n", count_active_Nuitka_CoroutineWrapper_Type,
+                 count_allocated_Nuitka_CoroutineWrapper_Type, count_released_Nuitka_CoroutineWrapper_Type);
+
+    PRINT_FORMAT("Compiled Coroutines AIter Wrappers: %d | %d | %d\n", count_active_Nuitka_AIterWrapper_Type,
+                 count_allocated_Nuitka_AIterWrapper_Type, count_released_Nuitka_AIterWrapper_Type);
+#if PYTHON_VERSION >= 0x360
+    PRINT_FORMAT("Compiled Asyncgen: %d | %d | %d\n", count_active_Nuitka_Asyncgen_Type,
+                 count_allocated_Nuitka_Asyncgen_Type, count_released_Nuitka_Asyncgen_Type);
+    PRINT_FORMAT("Compiled Asyncgen Wrappers: %d | %d | %d\n", count_active_Nuitka_AsyncgenValueWrapper_Type,
+                 count_allocated_Nuitka_AsyncgenValueWrapper_Type, count_released_Nuitka_AsyncgenValueWrapper_Type);
+    PRINT_FORMAT("Compiled Asyncgen Asend: %d | %d | %d\n", count_active_Nuitka_AsyncgenAsend_Type,
+                 count_allocated_Nuitka_AsyncgenAsend_Type, count_released_Nuitka_AsyncgenAsend_Type);
+    PRINT_FORMAT("Compiled Asyncgen Athrow: %d | %d | %d\n", count_active_Nuitka_AsyncgenAthrow_Type,
+                 count_allocated_Nuitka_AsyncgenAthrow_Type, count_released_Nuitka_AsyncgenAthrow_Type);
+#endif
+
+    PRINT_FORMAT("Compiled Frames: %d | %d | %d (cache usage may occur)\n", count_active_Nuitka_Frame_Type,
+                 count_allocated_Nuitka_Frame_Type, count_released_Nuitka_Frame_Type);
+    PRINT_STRING("CACHED counts at program end:\n");
+    PRINT_STRING("active | allocated | released | hits\n");
+    PRINT_FORMAT("Cached Frames: %d | %d | %d | %d\n", count_active_frame_cache_instances,
+                 count_allocated_frame_cache_instances, count_released_frame_cache_instances,
+                 count_hit_frame_cache_instances);
+}
+#endif
+
+#if defined(_NUITKA_ONEFILE_MODE) && defined(_WIN32)
+
+static long onefile_ppid;
+
+DWORD WINAPI doOnefileParentMonitoring(LPVOID lpParam) {
+    NUITKA_PRINT_TRACE("Onefile parent monitoring starts.");
+
+    for (;;) {
+        Sleep(1000);
+
+        HANDLE handle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, onefile_ppid);
+
+        if (handle == NULL) {
+            if (GetLastError() == ERROR_INVALID_PARAMETER) {
+                break;
+            } else {
+                continue;
+            }
+        } else {
+            DWORD ret = WaitForSingleObject(handle, 0);
+
+            CloseHandle(handle);
+
+            if (ret == WAIT_OBJECT_0) {
+                break;
+            }
+        }
+    }
+
+    NUITKA_PRINT_TRACE("Onefile parent monitoring causes KeyboardInterrupt.");
+
+    PyErr_SetInterrupt();
+
+    return 0;
+}
+#endif
+
+#if defined(_WIN32) && PYTHON_VERSION < 0x300
+static char **getCommandLineToArgvA(char *lpCmdline) {
+    char *s = lpCmdline;
+
+    int argc = 1;
+
+    if (*s == '"') {
+        s++;
+
+        while (*s != 0) {
+            if (*s++ == '"') {
+                break;
+            }
+        }
+    } else {
+        while (*s != 0 && *s != ' ' && *s != '\t') {
+            s++;
+        }
+    }
+
+    while (*s == ' ' || *s == '\t') {
+        s++;
+    }
+
+    if (*s != 0) {
+        argc++;
+    }
+
+    int quote_count = 0;
+    int slash_count = 0;
+
+    while (*s != 0) {
+        if ((*s == ' ' || *s == '\t') && quote_count == 0) {
+            while (*s == ' ' || *s == '\t') {
+                s++;
+            }
+
+            if (*s != 0) {
+                argc++;
+            }
+            slash_count = 0;
+        } else if (*s == '\\') {
+            slash_count++;
+            s++;
+        } else if (*s == '"') {
+            if ((slash_count & 1) == 0) {
+                quote_count++;
+            }
+
+            slash_count = 0;
+            s++;
+
+            while (*s == '"') {
+                quote_count++;
+                s++;
+            }
+
+            quote_count = quote_count % 3;
+
+            if (quote_count == 2) {
+                quote_count = 0;
+            }
+        } else {
+            slash_count = 0;
+            s++;
+        }
+    }
+
+    char **argv = (char **)malloc((argc + 1) * sizeof(char *) + (strlen(lpCmdline) + 1));
+    assert(argv);
+
+    char *cmdline = (char *)(argv + argc + 1);
+    strcpy(cmdline, lpCmdline);
+
+    argv[0] = cmdline;
+    argc = 1;
+
+    char *d = cmdline;
+
+    if (*d == '"') {
+        s = d + 1;
+
+        while (*s != 0) {
+            if (*s == '"') {
+                s++;
+                break;
+            }
+
+            *d++ = *s++;
+        }
+    } else {
+        while (*d && *d != ' ' && *d != '\t') {
+            d++;
+        }
+
+        s = d;
+
+        if (*s) {
+            s++;
+        }
+    }
+
+    *d++ = 0;
+
+    while (*s == ' ' || *s == '\t') {
+        s++;
+    }
+
+    if (*s == 0) {
+        argv[argc] = NULL;
+        return argv;
+    }
+
+    argv[argc++] = d;
+    quote_count = 0;
+    slash_count = 0;
+
+    while (*s != 0) {
+        if ((*s == ' ' || *s == '\t') && quote_count == 0) {
+            *d++ = 0;
+            slash_count = 0;
+
+            do {
+                s++;
+            } while (*s == ' ' || *s == '\t');
+
+            if (*s) {
+                argv[argc++] = d;
+            }
+
+        } else if (*s == '\\') {
+            *d++ = *s++;
+            slash_count++;
+        } else if (*s == '"') {
+            if ((slash_count & 1) == 0) {
+                d -= slash_count / 2;
+                quote_count++;
+            } else {
+                d = d - slash_count / 2 - 1;
+                *d++ = '"';
+            }
+            s++;
+            slash_count = 0;
+
+            while (*s == '"') {
+                if (++quote_count == 3) {
+                    *d++ = '"';
+                    quote_count = 0;
+                }
+                s++;
+            }
+            if (quote_count == 2)
+                quote_count = 0;
+        } else {
+            *d++ = *s++;
+            slash_count = 0;
+        }
+    }
+
+    *d = '\0';
+    argv[argc] = NULL;
+
+    return argv;
+}
+#endif
+
+// Disable wild card expansion for MinGW64, spell-checker: ignore _dowildcard
+#if defined(__MINGW64__) || defined(__MINGW32__)
+int _dowildcard = 0;
+#endif
+
+#if PYTHON_VERSION >= 0x300 && (SYSFLAG_NO_RANDOMIZATION == 1 || SYSFLAG_UNBUFFERED == 1)
+static void undoEnvironmentVariable(char const *variable_name, char const *old_value) {
+    if (old_value) {
+        setenv(variable_name, old_value, 1);
+
+        PyObject *env_value = PyUnicode_FromString(old_value);
+        PyObject *variable_name_str = PyUnicode_FromString(variable_name);
+
+        int res = PyDict_SetItem(PyObject_GetAttrString(PyImport_ImportModule("os"), "environ"), variable_name_str,
+                                 env_value);
+        assert(res == 0);
+
+        Py_DECREF(env_value);
+        Py_DECREF(variable_name_str);
+    } else {
+        unsetenv(variable_name);
+
+        int res =
+            PyDict_DelItemString(PyObject_GetAttrString(PyImport_ImportModule("os"), "environ"), (char *)variable_name);
+        assert(res == 0);
+    }
+}
+#endif
+
+#if defined(NUITKA_FORCED_STDOUT_PATH) || defined(NUITKA_FORCED_STDERR_PATH)
+#ifdef _WIN32
+static PyObject *getExpandedTemplatePath(wchar_t const *template_path) {
+    wchar_t filename_buffer[1024];
+    bool res = expandTemplatePathW(filename_buffer, template_path, sizeof(filename_buffer) / sizeof(wchar_t));
+
+    if (res == false) {
+        puts("Error, couldn't expand pattern:");
+        abort();
+    }
+
+    return NuitkaUnicode_FromWideChar(filename_buffer, -1);
+}
+#else
+static PyObject *getExpandedTemplatePath(char const *template) {
+    char filename_buffer[1024];
+    bool res = expandTemplatePath(filename_buffer, template, sizeof(filename_buffer));
+
+    if (res == false) {
+        printf("Error, couldn't expand pattern: %s\n", template);
+        abort();
+    }
+
+    return Nuitka_String_FromString(filename_buffer);
+}
+#endif
+#endif
+
+#ifdef _WIN32
+static void setStdFileHandleNumber(DWORD std_handle_id, PyObject *file_handle) {
+    PyObject *file_no_value = CALL_METHOD_NO_ARGS(file_handle, const_str_plain_fileno);
+
+    if (unlikely(file_no_value == NULL)) {
+        DROP_ERROR_OCCURRED();
+        return;
+    }
+
+    long file_number = PyLong_AsLong(file_no_value);
+
+    Py_DECREF(file_no_value);
+
+    if (unlikely(file_number == -1 && ERROR_OCCURRED())) {
+        DROP_ERROR_OCCURRED();
+        return;
+    }
+
+    // Casting from long to handle gives warnings if not using a suitable
+    // sized integer type in between.
+    if (std_handle_id != STD_INPUT_HANDLE) {
+        SetStdHandle(std_handle_id, (HANDLE)(intptr_t)file_number);
+    }
+}
+#endif
+
+static void setInputOutputHandles(void) {
+    /* At least on Windows, we support disabling the console via linker flag, but now
+       need to provide the NUL standard file handles manually in this case. */
+#if defined(_WIN32) && PYTHON_VERSION >= 0x300
+    PyObject *encoding = Nuitka_String_FromString("utf-8");
+#else
+    PyObject *encoding = NULL;
+#endif
+
+    {
+        PyObject *nul_filename = Nuitka_String_FromString("NUL:");
+
+        PyObject *sys_stdin = Nuitka_SysGetObject("stdin");
+        if (sys_stdin == NULL || sys_stdin == Py_None) {
+            // CPython core requires stdin to be buffered due to methods usage, and it won't matter
+            // here much.
+            PyObject *stdin_file = BUILTIN_OPEN_SIMPLE(nul_filename, "r", true, encoding);
+
+            CHECK_OBJECT(stdin_file);
+            Nuitka_SysSetObject("stdin", stdin_file);
+
+#ifdef _WIN32
+            setStdFileHandleNumber(STD_INPUT_HANDLE, stdin_file);
+#endif
+        }
+
+        PyObject *sys_stdout = Nuitka_SysGetObject("stdout");
+        if (sys_stdout == NULL || sys_stdout == Py_None) {
+            PyObject *stdout_file = BUILTIN_OPEN_SIMPLE(nul_filename, "w", false, encoding);
+
+            CHECK_OBJECT(stdout_file);
+            Nuitka_SysSetObject("stdout", stdout_file);
+
+#ifdef _WIN32
+            setStdFileHandleNumber(STD_OUTPUT_HANDLE, stdout_file);
+#endif
+        }
+
+        PyObject *sys_stderr = Nuitka_SysGetObject("stderr");
+        if (sys_stderr == NULL || sys_stderr == Py_None) {
+            PyObject *stderr_file = BUILTIN_OPEN_SIMPLE(nul_filename, "w", false, encoding);
+
+            CHECK_OBJECT(stderr_file);
+
+            Nuitka_SysSetObject("stderr", stderr_file);
+
+#ifdef _WIN32
+            setStdFileHandleNumber(STD_ERROR_HANDLE, stderr_file);
+#endif
+        }
+
+        Py_DECREF(nul_filename);
+    }
+
+#if defined(NUITKA_FORCED_STDOUT_PATH)
+    {
+#ifdef _WIN32
+        PyObject *filename = getExpandedTemplatePath(L"" NUITKA_FORCED_STDOUT_PATH);
+#else
+        PyObject *filename = getExpandedTemplatePath(NUITKA_FORCED_STDOUT_PATH);
+#endif
+        PyObject *stdout_file = BUILTIN_OPEN_SIMPLE(filename, "w", SYSFLAG_UNBUFFERED != 1, encoding);
+        if (unlikely(stdout_file == NULL)) {
+            PyErr_PrintEx(1);
+            Py_Exit(1);
+        }
+
+        Nuitka_SysSetObject("stdout", stdout_file);
+
+#ifdef _WIN32
+        setStdFileHandleNumber(STD_OUTPUT_HANDLE, stdout_file);
+#endif
+    }
+#endif
+
+#if defined(NUITKA_FORCED_STDERR_PATH)
+    {
+#ifdef _WIN32
+        PyObject *filename = getExpandedTemplatePath(L"" NUITKA_FORCED_STDERR_PATH);
+#else
+        PyObject *filename = getExpandedTemplatePath(NUITKA_FORCED_STDERR_PATH);
+#endif
+        PyObject *stderr_file = BUILTIN_OPEN_SIMPLE(filename, "w", false, encoding);
+        if (unlikely(stderr_file == NULL)) {
+            PyErr_PrintEx(1);
+            Py_Exit(1);
+        }
+
+        Nuitka_SysSetObject("stderr", stderr_file);
+
+#ifdef _WIN32
+        setStdFileHandleNumber(STD_ERROR_HANDLE, stderr_file);
+#endif
+    }
+#endif
+
+    Py_XDECREF(encoding);
+}
+
+#ifdef _NUITKA_WINMAIN_ENTRY_POINT
+int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, wchar_t *lpCmdLine, int nCmdShow) {
+    /* MSVC, MINGW64 */
+    int argc = __argc;
+    wchar_t **argv = __wargv;
+#else
+#if defined(_WIN32)
+int wmain(int argc, wchar_t **argv) {
+#else
+int main(int argc, char **argv) {
+#endif
+#endif
+    NUITKA_PRINT_TIMING("main(): Entered.");
+    NUITKA_INIT_PROGRAM_EARLY(argc, argv);
+
+#if SYSFLAG_UNBUFFERED == 1
+    setbuf(stdin, (char *)NULL);
+    setbuf(stdout, (char *)NULL);
+    setbuf(stderr, (char *)NULL);
+
+#if PYTHON_VERSION >= 0x300
+    char const *old_env_unbuffered = getenv("PYTHONUNBUFFERED");
+    setenv("PYTHONUNBUFFERED", "1", 1);
+#endif
+#endif
+
+#ifdef __FreeBSD__
+    /* FP exceptions run in "no stop" mode by default */
+
+    fp_except_t m;
+
+    m = fpgetmask();
+    fpsetmask(m & ~FP_X_OFL);
+#endif
+
+#ifdef _NUITKA_STANDALONE
+    NUITKA_PRINT_TIMING("main(): Prepare standalone environment.");
+    prepareStandaloneEnvironment();
+#else
+
+#endif
+
+#if _NUITKA_FROZEN > 0
+    prepareFrozenModules();
+#endif
+
+    /* Initialize CPython library environment. */
+    Py_DebugFlag = 0;
+#if PYTHON_VERSION < 0x300
+    Py_Py3kWarningFlag = SYSFLAG_PY3K_WARNING;
+    Py_DivisionWarningFlag = SYSFLAG_DIVISION_WARNING;
+    Py_UnicodeFlag = SYSFLAG_UNICODE;
+    Py_TabcheckFlag = 0;
+#endif
+    Py_InspectFlag = 0;
+    Py_InteractiveFlag = 0;
+    Py_OptimizeFlag = SYSFLAG_OPTIMIZE;
+    Py_DontWriteBytecodeFlag = 0;
+    Py_NoUserSiteDirectory = SYSFLAG_NO_SITE;
+    Py_IgnoreEnvironmentFlag = 0;
+    Py_VerboseFlag = SYSFLAG_VERBOSE;
+    Py_BytesWarningFlag = SYSFLAG_BYTES_WARNING;
+#if PYTHON_VERSION >= 0x300 && SYSFLAG_UNBUFFERED == 1
+    Py_UnbufferedStdioFlag = SYSFLAG_UNBUFFERED;
+#endif
+#if SYSFLAG_NO_RANDOMIZATION == 1
+    Py_HashRandomizationFlag = 0;
+#if PYTHON_VERSION < 0x300
+    // For Python2 this is all it takes to have static hashes.
+    _PyRandom_Init();
+#endif
+#endif
+#if PYTHON_VERSION >= 0x370
+    Py_UTF8Mode = SYSFLAG_UTF8;
+
+    if (Py_UTF8Mode) {
+        if (Py_FileSystemDefaultEncoding == NULL) {
+            Py_FileSystemDefaultEncoding = "utf-8";
+            Py_HasFileSystemDefaultEncoding = 1;
+        }
+    }
+#endif
+
+#ifdef NUITKA_PYTHON_STATIC
+    Py_InitStaticModules();
+#endif
+
+    /* This suppresses warnings from getpath.c */
+    Py_FrozenFlag = 1;
+
+    /* We want to import the site module, but only after we finished our own
+     * setup. The site module import will be the first thing, the main module
+     * does.
+     */
+    Py_NoSiteFlag = 1;
+
+    /* Initial command line handling only. */
+
+#if PYTHON_VERSION >= 0x300 && _NUITKA_NATIVE_WCHAR_ARGV == 0
+    NUITKA_PRINT_TRACE("main(): Calling convertCommandLineParameters.");
+    orig_argv = convertCommandLineParameters(argc, argv);
+#elif PYTHON_VERSION < 0x300 && _NUITKA_NATIVE_WCHAR_ARGV == 1
+    orig_argv = getCommandLineToArgvA(GetCommandLineA());
+#else
+orig_argv = argv;
+#endif
+    orig_argc = argc;
+
+    NUITKA_PRINT_TRACE("main(): Calling initial setCommandLineParameters.");
+
+    setCommandLineParameters(argc, argv, true);
+
+    /* For Python installations that need the home set, we inject it back here. */
+#if defined(PYTHON_HOME_PATH)
+#if PYTHON_VERSION < 0x300
+    NUITKA_PRINT_TRACE("main(): Prepare run environment '" PYTHON_HOME_PATH "'.");
+    Py_SetPythonHome(PYTHON_HOME_PATH);
+#else
+    NUITKA_PRINTF_TRACE("main(): Prepare run environment '%S'.\n", L"" PYTHON_HOME_PATH);
+    Py_SetPythonHome(L"" PYTHON_HOME_PATH);
+    // Make sure the above Py_SetPythonHome call has effect already.
+    Py_GetPath();
+#endif
+#endif
+
+#if PYTHON_VERSION >= 0x300 && SYSFLAG_NO_RANDOMIZATION == 1
+    char const *old_env_hash_seed = getenv("PYTHONHASHSEED");
+    setenv("PYTHONHASHSEED", "0", 1);
+#endif
+
+    /* Disable CPython warnings if requested to. */
+#if NO_PYTHON_WARNINGS
+    {
+#if PYTHON_VERSION >= 0x300
+        wchar_t ignore[] = L"ignore";
+#else
+        char ignore[] = "ignore";
+#endif
+
+        PySys_ResetWarnOptions();
+        PySys_AddWarnOption(ignore);
+    }
+#endif
+
+// Workaround older Python not handling stream setup on redirected files properly.
+#if PYTHON_VERSION >= 0x340 && PYTHON_VERSION < 0x380
+    {
+        char const *encoding = NULL;
+
+        if (SYSFLAG_UTF8) {
+            encoding = "utf-8";
+        } else {
+            encoding = getenv("PYTHONIOENCODING");
+            if (encoding == NULL) {
+                encoding = "utf-8";
+            }
+        }
+
+        Py_SetStandardStreamEncoding(encoding, NULL);
+    }
+#endif
+
+    /* Initialize the embedded CPython interpreter. */
+    NUITKA_PRINT_TIMING("main(): Calling Py_Initialize to initialize interpreter.");
+    Py_Initialize();
+
+#if PYTHON_VERSION >= 0x300 && SYSFLAG_NO_RANDOMIZATION == 1
+    if (old_env_hash_seed) {
+        undoEnvironmentVariable("PYTHONHASHSEED", old_env_hash_seed);
+    }
+#endif
+
+#if PYTHON_VERSION >= 0x300 && SYSFLAG_UNBUFFERED == 1
+    if (old_env_unbuffered) {
+        undoEnvironmentVariable("PYTHONUNBUFFERED", old_env_unbuffered);
+    }
+#endif
+
+#ifdef _NUITKA_STANDALONE
+    NUITKA_PRINT_TRACE("main(): Restore standalone environment.");
+    restoreStandaloneEnvironment();
+#endif
+
+    /* Lie about it, believe it or not, there are "site" files, that check
+     * against later imports, see below.
+     */
+    Py_NoSiteFlag = SYSFLAG_NO_SITE;
+
+    /* Set the command line parameters for run time usage. */
+    NUITKA_PRINT_TRACE("main(): Calling setCommandLineParameters.");
+
+    setCommandLineParameters(argc, argv, false);
+
+    PySys_SetArgv(argc, orig_argv);
+
+    /* Initialize the built-in module tricks used and builtin-type methods */
+    NUITKA_PRINT_TRACE("main(): Calling _initBuiltinModule().");
+    _initBuiltinModule();
+
+    /* Initialize the Python constant values used. This also sets
+     * "sys.executable" while at it.
+     */
+    NUITKA_PRINT_TIMING("main(): Calling createGlobalConstants().");
+    createGlobalConstants();
+    NUITKA_PRINT_TIMING("main(): Returned createGlobalConstants().");
+
+    /* Complex call helpers need "__main__" constants, even if we only
+     * go into "__parents__main__" module as a start point.
+     */
+    NUITKA_PRINT_TIMING("main(): Calling createMainModuleConstants().");
+    createMainModuleConstants();
+    NUITKA_PRINT_TIMING("main(): Returned createMainModuleConstants().");
+
+    NUITKA_PRINT_TRACE("main(): Calling _initBuiltinOriginalValues().");
+    _initBuiltinOriginalValues();
+
+    /* Revert the wrong "sys.flags" value, it's used by "site" on at least
+     * Debian for Python 3.3, more uses may exist.
+     */
+#if SYSFLAG_NO_SITE == 0
+#if PYTHON_VERSION < 0x300
+    PyStructSequence_SET_ITEM(Nuitka_SysGetObject("flags"), 9, const_int_0);
+#else
+    PyStructSequence_SetItem(Nuitka_SysGetObject("flags"), 6, const_int_0);
+#endif
+#endif
+
+    /* Initialize the compiled types of Nuitka. */
+    _initCompiledCellType();
+    _initCompiledGeneratorType();
+    _initCompiledFunctionType();
+    _initCompiledMethodType();
+    _initCompiledFrameType();
+
+    _initSlotCompare();
+#if PYTHON_VERSION >= 0x270
+    _initSlotIterNext();
+#endif
+
+    NUITKA_PRINT_TRACE("main(): Calling enhancePythonTypes().");
+    enhancePythonTypes();
+
+    NUITKA_PRINT_TRACE("main(): Calling patchTypeComparison().");
+    patchTypeComparison();
+
+    NUITKA_PRINT_TRACE("main(): Calling patchTracebackDealloc().");
+    patchTracebackDealloc();
+
+#ifndef NUITKA_USE_PYCORE_THREADSTATE
+    /* Allow to override the ticker value, to remove checks for threads in
+     * CPython core from impact on benchmarks. */
+    char const *ticker_value = getenv("NUITKA_TICKER");
+    if (ticker_value != NULL) {
+        _Py_Ticker = atoi(ticker_value);
+        assert(_Py_Ticker >= 20);
+    }
+#endif
+
+    setInputOutputHandles();
+
+#ifdef _NUITKA_STANDALONE
+
+#if PYTHON_VERSION >= 0x300
+    // Make sure the importlib fully bootstraps as we couldn't load it with the
+    // standard loader.
+    PyObject *importlib_module = getImportLibBootstrapModule();
+    CHECK_OBJECT(importlib_module);
+#endif
+
+    NUITKA_PRINT_TRACE("main(): Calling setEarlyFrozenModulesFileAttribute().");
+
+    setEarlyFrozenModulesFileAttribute();
+#endif
+
+#if _NUITKA_FROZEN > 0
+    NUITKA_PRINT_TRACE("main(): Removing early frozen module table again.");
+    PyImport_FrozenModules = old_frozen;
+#endif
+
+    NUITKA_PRINT_TRACE("main(): Calling setupMetaPathBasedLoader().");
+    /* Enable meta path based loader. */
+    setupMetaPathBasedLoader();
+
+    /* Initialize warnings module. */
+    _PyWarnings_Init();
+
+#if NO_PYTHON_WARNINGS && PYTHON_VERSION >= 0x342 && PYTHON_VERSION < 0x3a0 && defined(_NUITKA_FULL_COMPAT)
+    // For full compatibility bump the warnings registry version,
+    // otherwise modules "__warningsregistry__" will mismatch.
+    PyObject *warnings_module = PyImport_ImportModule("warnings");
+    PyObject *meth = PyObject_GetAttrString(warnings_module, "_filters_mutated");
+
+    CALL_FUNCTION_NO_ARGS(meth);
+#if PYTHON_VERSION < 0x380
+    // Two times, so "__warningregistry__" version matches.
+    CALL_FUNCTION_NO_ARGS(meth);
+#endif
+#endif
+
+#if PYTHON_VERSION >= 0x300
+    NUITKA_PRINT_TRACE("main(): Calling patchInspectModule().");
+    patchInspectModule();
+#endif
+
+#if _NUITKA_PROFILE
+    // Profiling with "vmprof" if enabled.
+    startProfiling();
+#endif
+
+#if _NUITKA_PGO_PYTHON
+    // Profiling with our own Python PGO if enabled.
+    PGO_Initialize();
+#endif
+
+    /* Execute the main module unless plugins want to do something else. In case of
+       multiprocessing making a fork on Windows, we should execute "__parents_main__"
+       instead. And for Windows Service we call the plugin C code to call us back
+       to launch main code in a callback. */
+#ifdef _NUITKA_PLUGIN_MULTIPROCESSING_ENABLED
+    if (unlikely(is_multiprocessing_fork)) {
+        NUITKA_PRINT_TRACE("main(): Calling __parents_main__.");
+        EXECUTE_MAIN_MODULE("__parents_main__");
+
+        int exit_code = HANDLE_PROGRAM_EXIT();
+
+        NUITKA_PRINT_TRACE("main(): Calling __parents_main__ Py_Exit.");
+
+        // TODO: Should maybe call Py_Exit here, but there were issues with that.
+        exit(exit_code);
+    } else if (unlikely(multiprocessing_resource_tracker_arg != NULL)) {
+        NUITKA_PRINT_TRACE("main(): Calling resource_tracker.");
+        PyObject *resource_tracker_module = EXECUTE_MAIN_MODULE("multiprocessing.resource_tracker");
+
+        PyObject *main_function = PyObject_GetAttrString(resource_tracker_module, "main");
+
+        CALL_FUNCTION_WITH_SINGLE_ARG(main_function, multiprocessing_resource_tracker_arg);
+
+        int exit_code = HANDLE_PROGRAM_EXIT();
+
+        NUITKA_PRINT_TRACE("main(): Calling resource_tracker Py_Exit.");
+        // TODO: Should maybe call Py_Exit here, but there were issues with that.
+        exit(exit_code);
+    } else {
+#endif
+#if defined(_NUITKA_ONEFILE_MODE) && defined(_WIN32)
+        {
+            char buffer[128] = {0};
+            DWORD size = GetEnvironmentVariableA("NUITKA_ONEFILE_PARENT", buffer, sizeof(buffer));
+
+            if (size > 0 && size < 127) {
+                onefile_ppid = atol(buffer);
+
+                CreateThread(NULL, 0, doOnefileParentMonitoring, NULL, 0, NULL);
+            }
+        }
+#endif
+        PyDict_DelItemString(PyImport_GetModuleDict(), NUITKA_MAIN_MODULE_NAME);
+
+#if _NUITKA_PLUGIN_WINDOWS_SERVICE_ENABLED
+        NUITKA_PRINT_TRACE("main(): Calling plugin SvcLaunchService() entry point.");
+        SvcLaunchService();
+#else
+    /* Execute the "__main__" module. */
+    NUITKA_PRINT_TIMING("main(): Calling " NUITKA_MAIN_MODULE_NAME ".");
+    EXECUTE_MAIN_MODULE(NUITKA_MAIN_MODULE_NAME);
+    NUITKA_PRINT_TIMING("main(): Exited from " NUITKA_MAIN_MODULE_NAME ".");
+
+#endif
+#ifdef _NUITKA_PLUGIN_MULTIPROCESSING_ENABLED
+    }
+#endif
+
+#if _NUITKA_PROFILE
+    stopProfiling();
+#endif
+
+#if _NUITKA_PGO_PYTHON
+    // Write out profiling with our own Python PGO if enabled.
+    PGO_Finalize();
+#endif
+
+#ifndef __NUITKA_NO_ASSERT__
+    checkGlobalConstants();
+
+    /* TODO: Walk over all loaded compiled modules, and make this kind of checks. */
+#if !NUITKA_MAIN_PACKAGE_MODE
+    checkModuleConstants___main__();
+#endif
+
+#endif
+
+    int exit_code = HANDLE_PROGRAM_EXIT();
+
+#if _DEBUG_REFCOUNTS
+    PRINT_REFCOUNTS();
+#endif
+
+    NUITKA_PRINT_TIMING("main(): Calling Py_Exit.");
+    Py_Exit(exit_code);
+
+    // The "Py_Exit()" calls is not supposed to return.
+    NUITKA_CANNOT_GET_HERE("Py_Exit does not return");
+}
+
+/* This is an unofficial API, not available on Windows, but on Linux and others
+ * it is exported, and has been used by some code.
+ */
+#if !defined(_WIN32) && !defined(__MSYS__)
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if PYTHON_VERSION >= 0x300
+#if defined(__GNUC__)
+__attribute__((weak))
+__attribute__((visibility("default")))
+#endif
+void Py_GetArgcArgv(int *argc, wchar_t ***argv) {
+    *argc = orig_argc;
+
+    *argv = orig_argv;
+}
+#else
+#if defined(__GNUC__)
+__attribute__((weak))
+__attribute__((visibility("default")))
+#endif
+void Py_GetArgcArgv(int *argc, char ***argv) {
+    *argc = orig_argc;
+    *argv = orig_argv;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
Index: lab15/Lab_15/task_1.build/static_src/CompiledFunctionType.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/static_src/CompiledFunctionType.c b/lab15/Lab_15/task_1.build/static_src/CompiledFunctionType.c
new file mode 100644
--- /dev/null	(date 1673971982063)
+++ b/lab15/Lab_15/task_1.build/static_src/CompiledFunctionType.c	(date 1673971982063)
@@ -0,0 +1,2672 @@
+//     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com
+//
+//     Part of "Nuitka", an optimizing Python compiler that is compatible and
+//     integrates with CPython, but also works on its own.
+//
+//     Licensed under the Apache License, Version 2.0 (the "License");
+//     you may not use this file except in compliance with the License.
+//     You may obtain a copy of the License at
+//
+//        http://www.apache.org/licenses/LICENSE-2.0
+//
+//     Unless required by applicable law or agreed to in writing, software
+//     distributed under the License is distributed on an "AS IS" BASIS,
+//     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//     See the License for the specific language governing permissions and
+//     limitations under the License.
+//
+// Compiled function type.
+
+// The backbone of the integration into CPython. Try to behave as well as normal
+// functions and built-in functions, or even better.
+
+#include "nuitka/prelude.h"
+
+#include "nuitka/compiled_method.h"
+
+#include "nuitka/freelists.h"
+
+// Needed for offsetof
+#include "structmember.h"
+#include <stddef.h>
+
+// spell-checker: ignore qualname,klass,kwdefaults,getset,weakrefs,vectorcall,nargsf,m_varnames
+
+// tp_descr_get slot, bind a function to an object.
+static PyObject *Nuitka_Function_descr_get(PyObject *function, PyObject *object, PyObject *klass) {
+    assert(Nuitka_Function_Check(function));
+
+#if PYTHON_VERSION >= 0x300
+    if (object == NULL || object == Py_None) {
+        Py_INCREF(function);
+        return function;
+    }
+#endif
+
+    return Nuitka_Method_New((struct Nuitka_FunctionObject *)function, object == Py_None ? NULL : object, klass);
+}
+
+// tp_repr slot, decide how compiled function shall be output to "repr" built-in
+static PyObject *Nuitka_Function_tp_repr(struct Nuitka_FunctionObject *function) {
+    return Nuitka_String_FromFormat("<compiled_function %s at %p>",
+#if PYTHON_VERSION < 0x300
+                                    Nuitka_String_AsString(function->m_name),
+#else
+                                    Nuitka_String_AsString(function->m_qualname),
+#endif
+                                    function);
+}
+
+static long Nuitka_Function_tp_traverse(struct Nuitka_FunctionObject *function, visitproc visit, void *arg) {
+    // TODO: Identify the impact of not visiting other owned objects. It appears
+    // to be mostly harmless, as these are strings.
+    Py_VISIT(function->m_dict);
+
+    for (Py_ssize_t i = 0; i < function->m_closure_given; i++) {
+        Py_VISIT(function->m_closure[i]);
+    }
+
+    return 0;
+}
+
+static long Nuitka_Function_tp_hash(struct Nuitka_FunctionObject *function) { return function->m_counter; }
+
+static PyObject *Nuitka_Function_get_name(struct Nuitka_FunctionObject *object) {
+    PyObject *result = object->m_name;
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Function_set_name(struct Nuitka_FunctionObject *object, PyObject *value) {
+#if PYTHON_VERSION < 0x300
+    if (unlikely(value == NULL || PyString_Check(value) == 0))
+#else
+    if (unlikely(value == NULL || PyUnicode_Check(value) == 0))
+#endif
+    {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "__name__ must be set to a string object");
+        return -1;
+    }
+
+    PyObject *old = object->m_name;
+    Py_INCREF(value);
+    object->m_name = value;
+    Py_DECREF(old);
+
+    return 0;
+}
+
+#if PYTHON_VERSION >= 0x300
+static PyObject *Nuitka_Function_get_qualname(struct Nuitka_FunctionObject *object) {
+    PyObject *result = object->m_qualname;
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Function_set_qualname(struct Nuitka_FunctionObject *object, PyObject *value) {
+    if (unlikely(value == NULL || PyUnicode_Check(value) == 0)) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "__qualname__ must be set to a string object");
+        return -1;
+    }
+
+    PyObject *old = object->m_qualname;
+    Py_INCREF(value);
+    object->m_qualname = value;
+    Py_DECREF(old);
+
+    return 0;
+}
+#endif
+
+static PyObject *Nuitka_Function_get_doc(struct Nuitka_FunctionObject *object) {
+    PyObject *result = object->m_doc;
+
+    if (result == NULL) {
+        result = Py_None;
+    }
+
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Function_set_doc(struct Nuitka_FunctionObject *object, PyObject *value) {
+    PyObject *old = object->m_doc;
+
+    object->m_doc = value;
+    Py_XINCREF(value);
+
+    Py_XDECREF(old);
+
+    return 0;
+}
+
+static PyObject *Nuitka_Function_get_dict(struct Nuitka_FunctionObject *object) {
+    if (object->m_dict == NULL) {
+        object->m_dict = MAKE_DICT_EMPTY();
+    }
+
+    Py_INCREF(object->m_dict);
+    return object->m_dict;
+}
+
+static int Nuitka_Function_set_dict(struct Nuitka_FunctionObject *object, PyObject *value) {
+    if (unlikely(value == NULL)) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "function's dictionary may not be deleted");
+        return -1;
+    }
+
+    if (likely(PyDict_Check(value))) {
+        PyObject *old = object->m_dict;
+        Py_INCREF(value);
+        object->m_dict = value;
+        Py_XDECREF(old);
+
+        return 0;
+    } else {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "setting function's dictionary to a non-dict");
+        return -1;
+    }
+}
+
+static PyObject *Nuitka_Function_get_code(struct Nuitka_FunctionObject *object) {
+    PyObject *result = (PyObject *)object->m_code_object;
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Function_set_code(struct Nuitka_FunctionObject *object, PyObject *value) {
+    SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_RuntimeError, "__code__ is not writable in Nuitka");
+    return -1;
+}
+
+static PyObject *Nuitka_Function_get_compiled(struct Nuitka_FunctionObject *object) {
+    PyObject *result = Nuitka_dunder_compiled_value;
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Function_set_compiled(struct Nuitka_FunctionObject *object, PyObject *value) {
+    SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_RuntimeError, "__compiled__ is not writable");
+    return -1;
+}
+
+static PyObject *Nuitka_Function_get_compiled_constant(struct Nuitka_FunctionObject *object) {
+    PyObject *result = object->m_constant_return_value;
+
+    if (result == NULL) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_AttributeError, "non-constant return value");
+
+        return NULL;
+    }
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Function_set_compiled_constant(struct Nuitka_FunctionObject *object, PyObject *value) {
+    SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_RuntimeError, "__compiled_constant__ is not writable");
+    return -1;
+}
+
+static PyObject *Nuitka_Function_get_closure(struct Nuitka_FunctionObject *object) {
+    if (object->m_closure_given > 0) {
+        return MAKE_TUPLE((PyObject *const *)object->m_closure, object->m_closure_given);
+    } else {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+}
+
+static int Nuitka_Function_set_closure(struct Nuitka_FunctionObject *object, PyObject *value) {
+    SET_CURRENT_EXCEPTION_TYPE0_STR(
+#if PYTHON_VERSION < 0x300
+        PyExc_TypeError,
+#else
+        PyExc_AttributeError,
+#endif
+        "readonly attribute");
+
+    return -1;
+}
+
+static PyObject *Nuitka_Function_get_defaults(struct Nuitka_FunctionObject *object) {
+    PyObject *result = (PyObject *)object->m_defaults;
+    Py_INCREF(result);
+    return result;
+}
+
+static void _onUpdatedCompiledFunctionDefaultsValue(struct Nuitka_FunctionObject *function) {
+    if (function->m_defaults == Py_None) {
+        function->m_defaults_given = 0;
+    } else {
+        function->m_defaults_given = PyTuple_GET_SIZE(function->m_defaults);
+    }
+}
+
+static int Nuitka_Function_set_defaults(struct Nuitka_FunctionObject *object, PyObject *value) {
+    if (value == NULL) {
+        value = Py_None;
+    }
+
+    if (unlikely(value != Py_None && PyTuple_Check(value) == false)) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "__defaults__ must be set to a tuple object");
+        return -1;
+    }
+
+    PyObject *old = object->m_defaults;
+    Py_INCREF(value);
+    object->m_defaults = value;
+    Py_DECREF(old);
+
+    _onUpdatedCompiledFunctionDefaultsValue(object);
+
+    return 0;
+}
+
+#if PYTHON_VERSION >= 0x300
+static PyObject *Nuitka_Function_get_kwdefaults(struct Nuitka_FunctionObject *object) {
+    PyObject *result = object->m_kwdefaults;
+
+    if (result == NULL) {
+        result = Py_None;
+    }
+
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Function_set_kwdefaults(struct Nuitka_FunctionObject *object, PyObject *value) {
+    if (value == NULL) {
+        value = Py_None;
+    }
+
+    if (unlikely(value != Py_None && PyDict_Check(value) == false)) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "__kwdefaults__ must be set to a dict object");
+        return -1;
+    }
+
+    if (value == Py_None) {
+        value = NULL;
+    }
+
+    PyObject *old = object->m_kwdefaults;
+    Py_XINCREF(value);
+    object->m_kwdefaults = value;
+    Py_XDECREF(old);
+
+    return 0;
+}
+
+static PyObject *Nuitka_Function_get_annotations(struct Nuitka_FunctionObject *object) {
+    if (object->m_annotations == NULL) {
+        object->m_annotations = MAKE_DICT_EMPTY();
+    }
+
+    Py_INCREF(object->m_annotations);
+    return object->m_annotations;
+}
+
+static int Nuitka_Function_set_annotations(struct Nuitka_FunctionObject *object, PyObject *value) {
+    if (unlikely(value != NULL && PyDict_Check(value) == false)) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "__annotations__ must be set to a dict object");
+        return -1;
+    }
+
+    PyObject *old = object->m_annotations;
+    Py_XINCREF(value);
+    object->m_annotations = value;
+    Py_XDECREF(old);
+
+    return 0;
+}
+
+#endif
+
+static int Nuitka_Function_set_globals(struct Nuitka_FunctionObject *function, PyObject *value) {
+    SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "readonly attribute");
+    return -1;
+}
+
+static PyObject *Nuitka_Function_get_globals(struct Nuitka_FunctionObject *function) {
+    PyObject *result = PyModule_GetDict(function->m_module);
+    Py_INCREF(result);
+    return result;
+}
+
+#if PYTHON_VERSION >= 0x3a0
+static int Nuitka_Function_set_builtins(struct Nuitka_FunctionObject *function, PyObject *value) {
+    SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "readonly attribute");
+    return -1;
+}
+
+static PyObject *Nuitka_Function_get_builtins(struct Nuitka_FunctionObject *function) {
+    return LOOKUP_SUBSCRIPT(PyModule_GetDict(function->m_module), const_str_plain___builtins__);
+}
+#endif
+
+static int Nuitka_Function_set_module(struct Nuitka_FunctionObject *object, PyObject *value) {
+    if (object->m_dict == NULL) {
+        object->m_dict = MAKE_DICT_EMPTY();
+    }
+
+    if (value == NULL) {
+        value = Py_None;
+    }
+
+    return PyDict_SetItem(object->m_dict, const_str_plain___module__, value);
+}
+
+static PyObject *Nuitka_Function_get_module(struct Nuitka_FunctionObject *object) {
+    PyObject *result;
+
+    // The __dict__ might overrule this.
+    if (object->m_dict) {
+        result = DICT_GET_ITEM1(object->m_dict, const_str_plain___module__);
+
+        if (result != NULL) {
+            return result;
+        }
+    }
+
+    result = MODULE_NAME1(object->m_module);
+    return result;
+}
+
+static PyGetSetDef Nuitka_Function_getset[] = {
+#if PYTHON_VERSION >= 0x300
+    {(char *)"__qualname__", (getter)Nuitka_Function_get_qualname, (setter)Nuitka_Function_set_qualname, NULL},
+#endif
+#if PYTHON_VERSION < 0x300
+    {(char *)"func_name", (getter)Nuitka_Function_get_name, (setter)Nuitka_Function_set_name, NULL},
+#endif
+    {(char *)"__name__", (getter)Nuitka_Function_get_name, (setter)Nuitka_Function_set_name, NULL},
+#if PYTHON_VERSION < 0x300
+    {(char *)"func_doc", (getter)Nuitka_Function_get_doc, (setter)Nuitka_Function_set_doc, NULL},
+#endif
+    {(char *)"__doc__", (getter)Nuitka_Function_get_doc, (setter)Nuitka_Function_set_doc, NULL},
+#if PYTHON_VERSION < 0x300
+    {(char *)"func_dict", (getter)Nuitka_Function_get_dict, (setter)Nuitka_Function_set_dict, NULL},
+#endif
+    {(char *)"__dict__", (getter)Nuitka_Function_get_dict, (setter)Nuitka_Function_set_dict, NULL},
+#if PYTHON_VERSION < 0x300
+    {(char *)"func_code", (getter)Nuitka_Function_get_code, (setter)Nuitka_Function_set_code, NULL},
+#endif
+    {(char *)"__code__", (getter)Nuitka_Function_get_code, (setter)Nuitka_Function_set_code, NULL},
+#if PYTHON_VERSION < 0x300
+    {(char *)"func_defaults", (getter)Nuitka_Function_get_defaults, (setter)Nuitka_Function_set_defaults, NULL},
+#endif
+    {(char *)"__defaults__", (getter)Nuitka_Function_get_defaults, (setter)Nuitka_Function_set_defaults, NULL},
+#if PYTHON_VERSION < 0x300
+    {(char *)"func_globals", (getter)Nuitka_Function_get_globals, (setter)Nuitka_Function_set_globals, NULL},
+#endif
+    {(char *)"__closure__", (getter)Nuitka_Function_get_closure, (setter)Nuitka_Function_set_closure, NULL},
+#if PYTHON_VERSION < 0x300
+    {(char *)"func_closure", (getter)Nuitka_Function_get_closure, (setter)Nuitka_Function_set_closure, NULL},
+#endif
+    {(char *)"__globals__", (getter)Nuitka_Function_get_globals, (setter)Nuitka_Function_set_globals, NULL},
+    {(char *)"__module__", (getter)Nuitka_Function_get_module, (setter)Nuitka_Function_set_module, NULL},
+#if PYTHON_VERSION >= 0x300
+    {(char *)"__kwdefaults__", (getter)Nuitka_Function_get_kwdefaults, (setter)Nuitka_Function_set_kwdefaults, NULL},
+    {(char *)"__annotations__", (getter)Nuitka_Function_get_annotations, (setter)Nuitka_Function_set_annotations, NULL},
+#endif
+#if PYTHON_VERSION >= 0x3a0
+    {(char *)"__builtins__", (getter)Nuitka_Function_get_builtins, (setter)Nuitka_Function_set_builtins, NULL},
+#endif
+    {(char *)"__compiled__", (getter)Nuitka_Function_get_compiled, (setter)Nuitka_Function_set_compiled, NULL},
+    {(char *)"__compiled_constant__", (getter)Nuitka_Function_get_compiled_constant,
+     (setter)Nuitka_Function_set_compiled_constant, NULL},
+    {NULL}};
+
+static PyObject *Nuitka_Function_reduce(struct Nuitka_FunctionObject *function) {
+    PyObject *result;
+
+#if PYTHON_VERSION < 0x300
+    result = function->m_name;
+#else
+    result = function->m_qualname;
+#endif
+
+    Py_INCREF(result);
+    return result;
+}
+
+static PyObject *Nuitka_Function_clone(struct Nuitka_FunctionObject *function) {
+    struct Nuitka_FunctionObject *result =
+        Nuitka_Function_New(function->m_c_code, function->m_name,
+#if PYTHON_VERSION >= 0x300
+                            function->m_qualname,
+#endif
+                            function->m_code_object, function->m_defaults,
+#if PYTHON_VERSION >= 0x300
+                            function->m_kwdefaults, function->m_annotations,
+#endif
+                            function->m_module, function->m_doc, function->m_closure, function->m_closure_given);
+
+    return (PyObject *)result;
+}
+
+#define MAX_FUNCTION_FREE_LIST_COUNT 100
+static struct Nuitka_FunctionObject *free_list_functions = NULL;
+static int free_list_functions_count = 0;
+
+static void Nuitka_Function_tp_dealloc(struct Nuitka_FunctionObject *function) {
+#ifndef __NUITKA_NO_ASSERT__
+    // Save the current exception, if any, we must to not corrupt it.
+    PyObject *save_exception_type, *save_exception_value;
+    PyTracebackObject *save_exception_tb;
+    FETCH_ERROR_OCCURRED(&save_exception_type, &save_exception_value, &save_exception_tb);
+    RESTORE_ERROR_OCCURRED(save_exception_type, save_exception_value, save_exception_tb);
+#endif
+
+    Nuitka_GC_UnTrack(function);
+
+    if (function->m_weakrefs != NULL) {
+        PyObject_ClearWeakRefs((PyObject *)function);
+    }
+
+    Py_DECREF(function->m_name);
+#if PYTHON_VERSION >= 0x300
+    Py_DECREF(function->m_qualname);
+#endif
+
+    // These may actually resurrect the object, not?
+    Py_XDECREF(function->m_dict);
+    Py_DECREF(function->m_defaults);
+
+    Py_XDECREF(function->m_doc);
+
+#if PYTHON_VERSION >= 0x300
+    Py_XDECREF(function->m_kwdefaults);
+    Py_XDECREF(function->m_annotations);
+#endif
+
+    for (Py_ssize_t i = 0; i < function->m_closure_given; i++) {
+        assert(function->m_closure[i]);
+        Py_DECREF(function->m_closure[i]);
+
+        // Note: No need to set to NULL, each function creation makes
+        // a full copy, doing the init.
+    }
+
+    /* Put the object into free list or release to GC */
+    releaseToFreeList(free_list_functions, function, MAX_FUNCTION_FREE_LIST_COUNT);
+
+#ifndef __NUITKA_NO_ASSERT__
+    PyThreadState *thread_state = PyThreadState_GET();
+
+    assert(thread_state->curexc_type == save_exception_type);
+    assert(thread_state->curexc_value == save_exception_value);
+    assert((PyTracebackObject *)thread_state->curexc_traceback == save_exception_tb);
+#endif
+}
+
+static PyMethodDef Nuitka_Function_methods[] = {{"__reduce__", (PyCFunction)Nuitka_Function_reduce, METH_NOARGS, NULL},
+                                                {"clone", (PyCFunction)Nuitka_Function_clone, METH_NOARGS, NULL},
+                                                {NULL}};
+
+static PyObject *Nuitka_Function_tp_call(struct Nuitka_FunctionObject *function, PyObject *tuple_args, PyObject *kw);
+
+PyTypeObject Nuitka_Function_Type = {
+    PyVarObject_HEAD_INIT(NULL, 0) "compiled_function", /* tp_name */
+    sizeof(struct Nuitka_FunctionObject),               /* tp_basicsize */
+    sizeof(struct Nuitka_CellObject *),                 /* tp_itemsize */
+    (destructor)Nuitka_Function_tp_dealloc,             /* tp_dealloc */
+#if PYTHON_VERSION < 0x380 || defined(_NUITKA_EXPERIMENTAL_DISABLE_VECTORCALL_SLOT)
+    0, /* tp_print */
+#else
+    offsetof(struct Nuitka_FunctionObject, m_vectorcall), /* tp_vectorcall_offset */
+#endif
+    0,                                    /* tp_getattr */
+    0,                                    /* tp_setattr */
+    0,                                    /* tp_compare */
+    (reprfunc)Nuitka_Function_tp_repr,    /* tp_repr */
+    0,                                    /* tp_as_number */
+    0,                                    /* tp_as_sequence */
+    0,                                    /* tp_as_mapping */
+    (hashfunc)Nuitka_Function_tp_hash,    /* tp_hash */
+    (ternaryfunc)Nuitka_Function_tp_call, /* tp_call */
+    0,                                    /* tp_str */
+    PyObject_GenericGetAttr,              /* tp_getattro */
+    0,                                    /* tp_setattro */
+    0,                                    /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT |
+#if PYTHON_VERSION < 0x300
+        Py_TPFLAGS_HAVE_WEAKREFS |
+#endif
+#if PYTHON_VERSION >= 0x380
+        _Py_TPFLAGS_HAVE_VECTORCALL | Py_TPFLAGS_METHOD_DESCRIPTOR |
+#endif
+        Py_TPFLAGS_HAVE_GC,                             /* tp_flags */
+    0,                                                  /* tp_doc */
+    (traverseproc)Nuitka_Function_tp_traverse,          /* tp_traverse */
+    0,                                                  /* tp_clear */
+    0,                                                  /* tp_richcompare */
+    offsetof(struct Nuitka_FunctionObject, m_weakrefs), /* tp_weaklistoffset */
+    0,                                                  /* tp_iter */
+    0,                                                  /* tp_iternext */
+    Nuitka_Function_methods,                            /* tp_methods */
+    0,                                                  /* tp_members */
+    Nuitka_Function_getset,                             /* tp_getset */
+    0,                                                  /* tp_base */
+    0,                                                  /* tp_dict */
+    Nuitka_Function_descr_get,                          /* tp_descr_get */
+    0,                                                  /* tp_descr_set */
+    offsetof(struct Nuitka_FunctionObject, m_dict),     /* tp_dictoffset */
+    0,                                                  /* tp_init */
+    0,                                                  /* tp_alloc */
+    0,                                                  /* tp_new */
+    0,                                                  /* tp_free */
+    0,                                                  /* tp_is_gc */
+    0,                                                  /* tp_bases */
+    0,                                                  /* tp_mro */
+    0,                                                  /* tp_cache */
+    0,                                                  /* tp_subclasses */
+    0,                                                  /* tp_weaklist */
+    0,                                                  /* tp_del */
+    0                                                   /* tp_version_tag */
+#if PYTHON_VERSION >= 0x340
+    ,
+    0 /* tp_finalizer */
+#endif
+};
+
+void _initCompiledFunctionType(void) {
+    Nuitka_Function_Type.tp_base = &PyFunction_Type;
+
+    PyType_Ready(&Nuitka_Function_Type);
+
+    // Be a paranoid subtype of uncompiled function, we want nothing shared.
+    assert(Nuitka_Function_Type.tp_doc != PyFunction_Type.tp_doc);
+    assert(Nuitka_Function_Type.tp_traverse != PyFunction_Type.tp_traverse);
+    assert(Nuitka_Function_Type.tp_clear != PyFunction_Type.tp_clear || PyFunction_Type.tp_clear == NULL);
+    assert(Nuitka_Function_Type.tp_richcompare != PyFunction_Type.tp_richcompare ||
+           PyFunction_Type.tp_richcompare == NULL);
+    assert(Nuitka_Function_Type.tp_weaklistoffset != PyFunction_Type.tp_weaklistoffset);
+    assert(Nuitka_Function_Type.tp_iter != PyFunction_Type.tp_iter || PyFunction_Type.tp_iter == NULL);
+    assert(Nuitka_Function_Type.tp_iternext != PyFunction_Type.tp_iternext || PyFunction_Type.tp_iternext == NULL);
+    assert(Nuitka_Function_Type.tp_methods != PyFunction_Type.tp_methods);
+    assert(Nuitka_Function_Type.tp_members != PyFunction_Type.tp_members);
+    assert(Nuitka_Function_Type.tp_getset != PyFunction_Type.tp_getset);
+    assert(Nuitka_Function_Type.tp_base != PyFunction_Type.tp_base);
+    assert(Nuitka_Function_Type.tp_dict != PyFunction_Type.tp_dict);
+    assert(Nuitka_Function_Type.tp_descr_get != PyFunction_Type.tp_descr_get);
+
+    assert(Nuitka_Function_Type.tp_descr_set != PyFunction_Type.tp_descr_set || PyFunction_Type.tp_descr_set == NULL);
+    assert(Nuitka_Function_Type.tp_dictoffset != PyFunction_Type.tp_dictoffset);
+    // TODO: These get changed and into the same thing, not sure what to compare against, project something
+    // assert(Nuitka_Function_Type.tp_init != PyFunction_Type.tp_init || PyFunction_Type.tp_init == NULL);
+    // assert(Nuitka_Function_Type.tp_alloc != PyFunction_Type.tp_alloc || PyFunction_Type.tp_alloc == NULL);
+    // assert(Nuitka_Function_Type.tp_new != PyFunction_Type.tp_new || PyFunction_Type.tp_new == NULL);
+    // assert(Nuitka_Function_Type.tp_free != PyFunction_Type.tp_free || PyFunction_Type.tp_free == NULL);
+    assert(Nuitka_Function_Type.tp_bases != PyFunction_Type.tp_bases);
+    assert(Nuitka_Function_Type.tp_mro != PyFunction_Type.tp_mro);
+    assert(Nuitka_Function_Type.tp_cache != PyFunction_Type.tp_cache || PyFunction_Type.tp_cache == NULL);
+    assert(Nuitka_Function_Type.tp_subclasses != PyFunction_Type.tp_subclasses || PyFunction_Type.tp_cache == NULL);
+    assert(Nuitka_Function_Type.tp_weaklist != PyFunction_Type.tp_weaklist);
+    assert(Nuitka_Function_Type.tp_del != PyFunction_Type.tp_del || PyFunction_Type.tp_del == NULL);
+#if PYTHON_VERSION >= 0x340
+    assert(Nuitka_Function_Type.tp_finalize != PyFunction_Type.tp_finalize || PyFunction_Type.tp_finalize == NULL);
+#endif
+
+    // Make sure we don't miss out on attributes we are not having or should not have.
+#ifndef __NUITKA_NO_ASSERT__
+    for (struct PyGetSetDef *own = &Nuitka_Function_getset[0]; own->name != NULL; own++) {
+        bool found = false;
+
+        for (struct PyGetSetDef *related = PyFunction_Type.tp_getset; related->name != NULL; related++) {
+            if (strcmp(related->name, own->name) == 0) {
+                found = true;
+            }
+        }
+
+        if (found == false) {
+            if (strcmp(own->name, "__doc__") == 0) {
+                // We do that one differently right now.
+                continue;
+            }
+#if PYTHON_VERSION < 0x300
+            if (strcmp(own->name, "func_doc") == 0) {
+                // We do that one differently right now.
+                continue;
+            }
+#endif
+
+            if (strcmp(own->name, "__globals__") == 0) {
+                // We do that one differently right now.
+                continue;
+            }
+
+#if PYTHON_VERSION < 0x300
+            if (strcmp(own->name, "func_globals") == 0) {
+                // We do that one differently right now.
+                continue;
+            }
+#endif
+
+#if PYTHON_VERSION >= 0x3a0
+            if (strcmp(own->name, "__builtins__") == 0) {
+                // We do that one differently right now.
+                continue;
+            }
+#endif
+
+            if (strcmp(own->name, "__module__") == 0) {
+                // We do that one differently right now.
+                continue;
+            }
+
+            if (strcmp(own->name, "__closure__") == 0) {
+                // We have to do that differently, because we do not keep this around until
+                // needed, and we make it read-only
+                continue;
+            }
+
+#if PYTHON_VERSION < 0x300
+            if (strcmp(own->name, "func_closure") == 0) {
+                // We have to do that differently, because we do not keep this around until
+                // needed, and we make it read-only
+                continue;
+            }
+#endif
+
+            if (strcmp(own->name, "__compiled__") == 0 || strcmp(own->name, "__compiled_constant__") == 0) {
+                // We have to do that differently, because we do not keep this around until
+                // needed, and we make it read-only
+                continue;
+            }
+
+            PRINT_FORMAT("Not found in uncompiled type: %s\n", own->name);
+            NUITKA_CANNOT_GET_HERE("Type problem");
+        }
+    }
+
+    for (struct PyGetSetDef *related = PyFunction_Type.tp_getset; related->name != NULL; related++) {
+        bool found = false;
+
+        for (struct PyGetSetDef *own = &Nuitka_Function_getset[0]; own->name != NULL; own++) {
+            if (strcmp(related->name, own->name) == 0) {
+                found = true;
+            }
+        }
+
+        if (found == false) {
+            PRINT_FORMAT("Not found in compiled type: %s\n", related->name);
+            NUITKA_CANNOT_GET_HERE("Type problem");
+        }
+    }
+
+    for (struct PyMemberDef *related = PyFunction_Type.tp_members; related->name != NULL; related++) {
+        bool found = false;
+
+        for (struct PyGetSetDef *own = &Nuitka_Function_getset[0]; own->name != NULL; own++) {
+            if (strcmp(related->name, own->name) == 0) {
+                found = true;
+            }
+        }
+
+        if (found == false) {
+            PRINT_FORMAT("Not found in compiled type: %s\n", related->name);
+            NUITKA_CANNOT_GET_HERE("Type problem");
+        }
+    }
+#endif
+
+#ifdef _NUITKA_PLUGIN_DILL_ENABLED
+    // TODO: Move this to a __nuitka__ module maybe
+    PyObject_SetAttrString((PyObject *)builtin_module, "compiled_function", (PyObject *)&Nuitka_Function_Type);
+#endif
+}
+
+// Shared implementations for empty functions. When a function body is empty, but
+// still needs to exist, e.g. overloaded functions, this is saving the effort to
+// produce one.
+static PyObject *_Nuitka_FunctionEmptyCodeNoneImpl(struct Nuitka_FunctionObject const *function,
+                                                   PyObject **python_pars) {
+    Py_ssize_t arg_count = function->m_args_overall_count;
+
+    for (Py_ssize_t i = 0; i < arg_count; i++) {
+        Py_DECREF(python_pars[i]);
+    }
+
+    PyObject *result = Py_None;
+
+    Py_INCREF(result);
+    return result;
+}
+
+static PyObject *_Nuitka_FunctionEmptyCodeTrueImpl(struct Nuitka_FunctionObject const *function,
+                                                   PyObject **python_pars) {
+    Py_ssize_t arg_count = function->m_args_overall_count;
+
+    for (Py_ssize_t i = 0; i < arg_count; i++) {
+        Py_DECREF(python_pars[i]);
+    }
+
+    PyObject *result = Py_True;
+
+    Py_INCREF(result);
+    return result;
+}
+
+static PyObject *_Nuitka_FunctionEmptyCodeFalseImpl(struct Nuitka_FunctionObject const *function,
+                                                    PyObject **python_pars) {
+    Py_ssize_t arg_count = function->m_args_overall_count;
+
+    for (Py_ssize_t i = 0; i < arg_count; i++) {
+        Py_DECREF(python_pars[i]);
+    }
+
+    PyObject *result = Py_False;
+
+    Py_INCREF(result);
+    return result;
+}
+
+static PyObject *_Nuitka_FunctionEmptyCodeGenericImpl(struct Nuitka_FunctionObject const *function,
+                                                      PyObject **python_pars) {
+    Py_ssize_t arg_count = function->m_args_overall_count;
+
+    for (Py_ssize_t i = 0; i < arg_count; i++) {
+        Py_DECREF(python_pars[i]);
+    }
+
+    PyObject *result = function->m_constant_return_value;
+
+    Py_INCREF(result);
+    return result;
+}
+
+void Nuitka_Function_EnableConstReturnTrue(struct Nuitka_FunctionObject *function) {
+    function->m_constant_return_value = Py_True;
+    function->m_c_code = _Nuitka_FunctionEmptyCodeTrueImpl;
+}
+
+void Nuitka_Function_EnableConstReturnFalse(struct Nuitka_FunctionObject *function) {
+    function->m_constant_return_value = Py_False;
+    function->m_c_code = _Nuitka_FunctionEmptyCodeFalseImpl;
+}
+
+void Nuitka_Function_EnableConstReturnGeneric(struct Nuitka_FunctionObject *function, PyObject *value) {
+    function->m_constant_return_value = value;
+    function->m_c_code = _Nuitka_FunctionEmptyCodeGenericImpl;
+}
+
+#if PYTHON_VERSION >= 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_VECTORCALL_SLOT)
+static PyObject *Nuitka_Function_tp_vectorcall(struct Nuitka_FunctionObject *function, PyObject *const *stack,
+                                               size_t nargsf, PyObject *kw_names);
+#endif
+
+// Make a function with closure.
+#if PYTHON_VERSION < 0x300
+struct Nuitka_FunctionObject *Nuitka_Function_New(function_impl_code c_code, PyObject *name, PyCodeObject *code_object,
+                                                  PyObject *defaults, PyObject *module, PyObject *doc,
+                                                  struct Nuitka_CellObject **closure, Py_ssize_t closure_given)
+#else
+struct Nuitka_FunctionObject *Nuitka_Function_New(function_impl_code c_code, PyObject *name, PyObject *qualname,
+                                                  PyCodeObject *code_object, PyObject *defaults, PyObject *kwdefaults,
+                                                  PyObject *annotations, PyObject *module, PyObject *doc,
+                                                  struct Nuitka_CellObject **closure, Py_ssize_t closure_given)
+#endif
+{
+    struct Nuitka_FunctionObject *result;
+
+    // Macro to assign result memory from GC or free list.
+    allocateFromFreeList(free_list_functions, struct Nuitka_FunctionObject, Nuitka_Function_Type, closure_given);
+
+    memcpy(&result->m_closure[0], closure, closure_given * sizeof(struct Nuitka_CellObject *));
+    result->m_closure_given = closure_given;
+
+    if (c_code != NULL) {
+        result->m_c_code = c_code;
+        result->m_constant_return_value = NULL;
+    } else {
+        result->m_c_code = _Nuitka_FunctionEmptyCodeNoneImpl;
+        result->m_constant_return_value = Py_None;
+    }
+
+    Py_INCREF(name);
+    result->m_name = name;
+
+#if PYTHON_VERSION >= 0x300
+    // The "qualname" defaults to NULL for most compact C code.
+    if (qualname == NULL) {
+        qualname = name;
+    }
+    CHECK_OBJECT(qualname);
+
+    Py_INCREF(qualname);
+    result->m_qualname = qualname;
+#endif
+
+    if (defaults == NULL) {
+        Py_INCREF(Py_None);
+        defaults = Py_None;
+    }
+    CHECK_OBJECT(defaults);
+    assert(defaults == Py_None || (PyTuple_Check(defaults) && PyTuple_GET_SIZE(defaults) > 0));
+    result->m_defaults = defaults;
+
+    _onUpdatedCompiledFunctionDefaultsValue(result);
+
+#if PYTHON_VERSION >= 0x300
+    assert(kwdefaults == NULL || (PyDict_Check(kwdefaults) && DICT_SIZE(kwdefaults) > 0));
+    result->m_kwdefaults = kwdefaults;
+
+    assert(annotations == NULL || (PyDict_Check(annotations) && DICT_SIZE(annotations) > 0));
+    result->m_annotations = annotations;
+#endif
+
+    result->m_code_object = code_object;
+    result->m_args_positional_count = code_object->co_argcount;
+    result->m_args_keywords_count = result->m_args_positional_count;
+#if PYTHON_VERSION >= 0x300
+    result->m_args_keywords_count += code_object->co_kwonlyargcount;
+#endif
+#if PYTHON_VERSION >= 0x380
+    result->m_args_pos_only_count = code_object->co_posonlyargcount;
+#endif
+
+    result->m_args_overall_count = result->m_args_keywords_count + ((code_object->co_flags & CO_VARARGS) ? 1 : 0) +
+                                   ((code_object->co_flags & CO_VARKEYWORDS) ? 1 : 0);
+
+    result->m_args_simple = (code_object->co_flags & (CO_VARARGS | CO_VARKEYWORDS)) == 0;
+#if PYTHON_VERSION >= 0x300
+    if (code_object->co_kwonlyargcount > 0) {
+        result->m_args_simple = false;
+    }
+#endif
+
+    if ((code_object->co_flags & CO_VARARGS) != 0) {
+        result->m_args_star_list_index = result->m_args_keywords_count;
+    } else {
+        result->m_args_star_list_index = -1;
+    }
+
+    if ((code_object->co_flags & CO_VARKEYWORDS) != 0) {
+        result->m_args_star_dict_index = result->m_args_keywords_count;
+
+        if (code_object->co_flags & CO_VARARGS) {
+            result->m_args_star_dict_index += 1;
+        }
+    } else {
+        result->m_args_star_dict_index = -1;
+    }
+
+    result->m_varnames = Nuitka_GetCodeVarNames(code_object);
+
+    result->m_module = module;
+
+    Py_XINCREF(doc);
+    result->m_doc = doc;
+
+    result->m_dict = NULL;
+    result->m_weakrefs = NULL;
+
+    static long Nuitka_Function_counter = 0;
+    result->m_counter = Nuitka_Function_counter++;
+
+#if PYTHON_VERSION >= 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_VECTORCALL_SLOT)
+    result->m_vectorcall = (vectorcallfunc)Nuitka_Function_tp_vectorcall;
+#endif
+
+    Nuitka_GC_Track(result);
+
+    assert(Py_REFCNT(result) == 1);
+
+    return result;
+}
+
+#if PYTHON_VERSION >= 0x300
+static void formatErrorNoArgumentAllowedKwSplit(struct Nuitka_FunctionObject const *function, PyObject *kw_name,
+                                                Py_ssize_t given) {
+#if PYTHON_VERSION < 0x3a0
+    char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+    char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+    PyErr_Format(PyExc_TypeError, "%s() got an unexpected keyword argument '%s'", function_name,
+                 Nuitka_String_AsString(kw_name));
+}
+#endif
+
+static void formatErrorNoArgumentAllowed(struct Nuitka_FunctionObject const *function,
+#if PYTHON_VERSION >= 0x300
+                                         PyObject *kw,
+#endif
+                                         Py_ssize_t given) {
+#if PYTHON_VERSION < 0x3a0
+    char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+    char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+#if PYTHON_VERSION < 0x300
+    PyErr_Format(PyExc_TypeError, "%s() takes no arguments (%zd given)", function_name, given);
+#else
+    if (kw == NULL) {
+        PyErr_Format(PyExc_TypeError, "%s() takes 0 positional arguments but %zd was given", function_name, given);
+    } else {
+        PyObject *tmp_iter = PyObject_GetIter(kw);
+        PyObject *tmp_arg_name = PyIter_Next(tmp_iter);
+        Py_DECREF(tmp_iter);
+
+        PyErr_Format(PyExc_TypeError, "%s() got an unexpected keyword argument '%s'", function_name,
+                     Nuitka_String_AsString(tmp_arg_name));
+
+        Py_DECREF(tmp_arg_name);
+    }
+#endif
+}
+
+static void formatErrorMultipleValuesGiven(struct Nuitka_FunctionObject const *function, Py_ssize_t index) {
+#if PYTHON_VERSION < 0x390
+    char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+    char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+    PyErr_Format(PyExc_TypeError,
+#if PYTHON_VERSION < 0x300
+                 "%s() got multiple values for keyword argument '%s'",
+#else
+                 "%s() got multiple values for argument '%s'",
+#endif
+                 function_name, Nuitka_String_AsString(function->m_varnames[index]));
+}
+
+#if PYTHON_VERSION < 0x300
+static void formatErrorTooFewArguments(struct Nuitka_FunctionObject const *function,
+#if PYTHON_VERSION < 0x270
+                                       Py_ssize_t kw_size,
+#endif
+                                       Py_ssize_t given) {
+    Py_ssize_t required_parameter_count = function->m_args_positional_count - function->m_defaults_given;
+
+#if PYTHON_VERSION < 0x390
+    char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+    char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+    char const *violation =
+        (function->m_defaults != Py_None || function->m_args_star_list_index != -1) ? "at least" : "exactly";
+    char const *plural = required_parameter_count == 1 ? "" : "s";
+
+#if PYTHON_VERSION < 0x270
+    if (kw_size > 0) {
+        PyErr_Format(PyExc_TypeError, "%s() takes %s %zd non-keyword argument%s (%zd given)", function_name, violation,
+                     required_parameter_count, plural, given - function->m_defaults_given);
+    } else {
+        PyErr_Format(PyExc_TypeError, "%s() takes %s %zd argument%s (%zd given)", function_name, violation,
+                     required_parameter_count, plural, given);
+    }
+#else
+    PyErr_Format(PyExc_TypeError, "%s() takes %s %zd argument%s (%zd given)", function_name, violation,
+                 required_parameter_count, plural, given);
+#endif
+}
+#else
+static void formatErrorTooFewArguments(struct Nuitka_FunctionObject const *function, PyObject **values) {
+#if PYTHON_VERSION < 0x3a0
+    char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+    char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+    Py_ssize_t max_missing = 0;
+
+    for (Py_ssize_t i = function->m_args_positional_count - 1 - function->m_defaults_given; i >= 0; --i) {
+        if (values[i] == NULL) {
+            max_missing += 1;
+        }
+    }
+
+    PyObject *list_str = PyUnicode_FromString("");
+
+    PyObject *comma_str = PyUnicode_FromString(", ");
+    PyObject *and_str = PyUnicode_FromString(max_missing == 2 ? " and " : ", and ");
+
+    Py_ssize_t missing = 0;
+    for (Py_ssize_t i = function->m_args_positional_count - 1 - function->m_defaults_given; i >= 0; --i) {
+        if (values[i] == NULL) {
+            PyObject *current_str = function->m_varnames[i];
+
+            PyObject *current = PyObject_Repr(current_str);
+
+            if (missing == 0) {
+                PyObject *old = list_str;
+
+                list_str = UNICODE_CONCAT(list_str, current);
+
+                Py_DECREF(old);
+            } else if (missing == 1) {
+                PyObject *old = list_str;
+
+                list_str = UNICODE_CONCAT(and_str, list_str);
+
+                Py_DECREF(old);
+                old = list_str;
+
+                list_str = UNICODE_CONCAT(current, list_str);
+
+                Py_DECREF(old);
+            } else {
+                PyObject *old = list_str;
+
+                list_str = UNICODE_CONCAT(comma_str, list_str);
+
+                Py_DECREF(old);
+                old = list_str;
+
+                list_str = UNICODE_CONCAT(current, list_str);
+
+                Py_DECREF(old);
+            }
+
+            Py_DECREF(current);
+
+            missing += 1;
+        }
+    }
+
+    Py_DECREF(comma_str);
+    Py_DECREF(and_str);
+
+    PyErr_Format(PyExc_TypeError, "%s() missing %zd required positional argument%s: %s", function_name, max_missing,
+                 max_missing > 1 ? "s" : "", Nuitka_String_AsString(list_str));
+
+    Py_DECREF(list_str);
+}
+#endif
+
+static void formatErrorTooManyArguments(struct Nuitka_FunctionObject const *function, Py_ssize_t given
+#if PYTHON_VERSION < 0x270
+                                        ,
+                                        Py_ssize_t kw_size
+
+#endif
+#if PYTHON_VERSION >= 0x300
+                                        ,
+                                        Py_ssize_t kw_only
+#endif
+) {
+    Py_ssize_t top_level_parameter_count = function->m_args_positional_count;
+
+#if PYTHON_VERSION < 0x3a0
+    char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+    char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+#if PYTHON_VERSION < 0x300
+    char const *violation = function->m_defaults != Py_None ? "at most" : "exactly";
+#endif
+    char const *plural = top_level_parameter_count == 1 ? "" : "s";
+
+#if PYTHON_VERSION < 0x270
+    PyErr_Format(PyExc_TypeError, "%s() takes %s %zd%s argument%s (%zd given)", function_name, violation,
+                 top_level_parameter_count, kw_size > 0 ? " non-keyword" : "", plural, given);
+#elif PYTHON_VERSION < 0x300
+    PyErr_Format(PyExc_TypeError, "%s() takes %s %zd argument%s (%zd given)", function_name, violation,
+                 top_level_parameter_count, plural, given);
+#else
+    char keyword_only_part[100];
+
+    if (kw_only > 0) {
+        snprintf(keyword_only_part, sizeof(keyword_only_part) - 1,
+                 " positional argument%s (and %" PY_FORMAT_SIZE_T "d keyword-only argument%s)", given != 1 ? "s" : "",
+                 kw_only, kw_only != 1 ? "s" : "");
+    } else {
+        keyword_only_part[0] = 0;
+    }
+
+    if (function->m_defaults_given == 0) {
+        PyErr_Format(PyExc_TypeError, "%s() takes %zd positional argument%s but %zd%s were given", function_name,
+                     top_level_parameter_count, plural, given, keyword_only_part);
+    } else {
+        PyErr_Format(PyExc_TypeError, "%s() takes from %zd to %zd positional argument%s but %zd%s were given",
+                     function_name, top_level_parameter_count - function->m_defaults_given, top_level_parameter_count,
+                     plural, given, keyword_only_part);
+    }
+#endif
+}
+
+#if PYTHON_VERSION >= 0x300
+static void formatErrorTooFewKwOnlyArguments(struct Nuitka_FunctionObject const *function, PyObject **kw_vars) {
+#if PYTHON_VERSION < 0x3a0
+    char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+    char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+    Py_ssize_t kwonlyargcount = function->m_code_object->co_kwonlyargcount;
+
+    Py_ssize_t max_missing = 0;
+
+    for (Py_ssize_t i = kwonlyargcount - 1; i >= 0; --i) {
+        if (kw_vars[i] == NULL) {
+            max_missing += 1;
+        }
+    }
+
+    PyObject *list_str = PyUnicode_FromString("");
+
+    PyObject *comma_str = PyUnicode_FromString(", ");
+    PyObject *and_str = PyUnicode_FromString(max_missing == 2 ? " and " : ", and ");
+
+    Py_ssize_t missing = 0;
+    for (Py_ssize_t i = kwonlyargcount - 1; i >= 0; --i) {
+        if (kw_vars[i] == NULL) {
+            PyObject *current_str = function->m_varnames[function->m_args_positional_count + i];
+
+            PyObject *current = PyObject_Repr(current_str);
+
+            if (missing == 0) {
+                PyObject *old = list_str;
+
+                list_str = UNICODE_CONCAT(list_str, current);
+
+                Py_DECREF(old);
+            } else if (missing == 1) {
+                PyObject *old = list_str;
+
+                list_str = UNICODE_CONCAT(and_str, list_str);
+
+                Py_DECREF(old);
+                old = list_str;
+
+                list_str = UNICODE_CONCAT(current, list_str);
+
+                Py_DECREF(old);
+            } else {
+                PyObject *old = list_str;
+
+                list_str = UNICODE_CONCAT(comma_str, list_str);
+
+                Py_DECREF(old);
+                old = list_str;
+
+                list_str = UNICODE_CONCAT(current, list_str);
+
+                Py_DECREF(old);
+            }
+
+            Py_DECREF(current);
+
+            missing += 1;
+        }
+    }
+
+    Py_DECREF(comma_str);
+    Py_DECREF(and_str);
+
+    PyErr_Format(PyExc_TypeError, "%s() missing %zd required keyword-only argument%s: %s", function_name, max_missing,
+                 max_missing > 1 ? "s" : "", Nuitka_String_AsString(list_str));
+
+    Py_DECREF(list_str);
+}
+#endif
+
+static void formatErrorKeywordsMustBeString(struct Nuitka_FunctionObject const *function) {
+#if PYTHON_VERSION < 0x390
+    char const *function_name = Nuitka_String_AsString(function->m_name);
+    SET_CURRENT_EXCEPTION_TYPE0_FORMAT1(PyExc_TypeError, "%s() keywords must be strings", function_name);
+#else
+    SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "keywords must be strings");
+#endif
+}
+
+static inline bool checkKeywordType(PyObject *arg_name) {
+#if PYTHON_VERSION < 0x300
+    return (PyString_Check(arg_name) || PyUnicode_Check(arg_name));
+#else
+    return PyUnicode_Check(arg_name) != 0;
+#endif
+}
+
+static inline bool RICH_COMPARE_EQ_CBOOL_ARG_NAMES(PyObject *operand1, PyObject *operand2) {
+    // Compare with argument name. We know our type, but from the outside, it
+    // can be a derived type, or in case of Python2, a unicode value to compare
+    // with a string. These half sided comparisons will make the switch to the
+    // special one immediately if possible though.
+
+#if PYTHON_VERSION < 0x300
+    nuitka_bool result = RICH_COMPARE_EQ_NBOOL_STR_OBJECT(operand1, operand2);
+#else
+    nuitka_bool result = RICH_COMPARE_EQ_NBOOL_UNICODE_OBJECT(operand1, operand2);
+#endif
+
+    // Should be close to impossible, we will have to ignore it though.
+    if (unlikely(result == NUITKA_BOOL_EXCEPTION)) {
+        DROP_ERROR_OCCURRED();
+        return false;
+    }
+
+    return result == NUITKA_BOOL_TRUE;
+}
+
+#if PYTHON_VERSION < 0x300
+static Py_ssize_t handleKeywordArgs(struct Nuitka_FunctionObject const *function, PyObject **python_pars, PyObject *kw)
+#else
+static Py_ssize_t handleKeywordArgs(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                    Py_ssize_t *kw_only_found, PyObject *kw)
+#endif
+{
+    Py_ssize_t keywords_count = function->m_args_keywords_count;
+
+#if PYTHON_VERSION >= 0x300
+    Py_ssize_t keyword_after_index = function->m_args_positional_count;
+#endif
+
+    assert(function->m_args_star_dict_index == -1);
+
+    Py_ssize_t kw_found = 0;
+    Py_ssize_t pos = 0;
+    PyObject *key, *value;
+
+    while (Nuitka_DictNext(kw, &pos, &key, &value)) {
+        if (unlikely(!checkKeywordType(key))) {
+            formatErrorKeywordsMustBeString(function);
+            return -1;
+        }
+
+        NUITKA_MAY_BE_UNUSED bool found = false;
+
+        Py_INCREF(key);
+        Py_INCREF(value);
+
+#if PYTHON_VERSION < 0x380
+        Py_ssize_t kw_arg_start = 0;
+#else
+        Py_ssize_t kw_arg_start = function->m_args_pos_only_count;
+#endif
+
+        for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+            if (function->m_varnames[i] == key) {
+                assert(python_pars[i] == NULL);
+                python_pars[i] = value;
+
+#if PYTHON_VERSION >= 0x300
+                if (i >= keyword_after_index) {
+                    *kw_only_found += 1;
+                }
+#endif
+
+                found = true;
+                break;
+            }
+        }
+
+        if (found == false) {
+            PyObject **varnames = function->m_varnames;
+
+            for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+                if (RICH_COMPARE_EQ_CBOOL_ARG_NAMES(varnames[i], key)) {
+                    assert(python_pars[i] == NULL);
+                    python_pars[i] = value;
+
+#if PYTHON_VERSION >= 0x300
+                    if (i >= keyword_after_index) {
+                        *kw_only_found += 1;
+                    }
+#endif
+
+                    found = true;
+                    break;
+                }
+            }
+        }
+
+        if (unlikely(found == false)) {
+            bool pos_only_error = false;
+
+            for (Py_ssize_t i = 0; i < kw_arg_start; i++) {
+                PyObject **varnames = function->m_varnames;
+
+                if (RICH_COMPARE_EQ_CBOOL_ARG_NAMES(varnames[i], key)) {
+                    pos_only_error = true;
+                    break;
+                }
+            }
+
+#if PYTHON_VERSION < 0x3a0
+            char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+            char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+            if (pos_only_error == true) {
+                PyErr_Format(PyExc_TypeError,
+                             "%s() got some positional-only arguments passed as keyword arguments: '%s'", function_name,
+                             Nuitka_String_Check(key) ? Nuitka_String_AsString(key) : "<non-string>");
+
+            } else {
+                PyErr_Format(PyExc_TypeError, "%s() got an unexpected keyword argument '%s'", function_name,
+                             Nuitka_String_Check(key) ? Nuitka_String_AsString(key) : "<non-string>");
+            }
+
+            Py_DECREF(key);
+            Py_DECREF(value);
+
+            return -1;
+        }
+
+        Py_DECREF(key);
+
+        kw_found += 1;
+    }
+
+    return kw_found;
+}
+
+#if PYTHON_VERSION < 0x300
+static Py_ssize_t handleKeywordArgsSplit(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                         PyObject *const *kw_values, PyObject *kw_names)
+#else
+static Py_ssize_t handleKeywordArgsSplit(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                         Py_ssize_t *kw_only_found, PyObject *const *kw_values, PyObject *kw_names)
+#endif
+{
+    Py_ssize_t keywords_count = function->m_args_keywords_count;
+
+#if PYTHON_VERSION >= 0x300
+    Py_ssize_t keyword_after_index = function->m_args_positional_count;
+#endif
+
+    assert(function->m_args_star_dict_index == -1);
+
+    Py_ssize_t kw_found = 0;
+
+    Py_ssize_t kw_names_size = PyTuple_GET_SIZE(kw_names);
+
+    for (Py_ssize_t kw_index = 0; kw_index < kw_names_size; kw_index++) {
+        PyObject *key = PyTuple_GET_ITEM(kw_names, kw_index);
+        PyObject *value = kw_values[kw_index];
+
+        assert(checkKeywordType(key));
+
+        NUITKA_MAY_BE_UNUSED bool found = false;
+
+#if PYTHON_VERSION < 0x380
+        Py_ssize_t kw_arg_start = 0;
+#else
+        Py_ssize_t kw_arg_start = function->m_args_pos_only_count;
+#endif
+
+        Py_INCREF(value);
+
+        for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+            if (function->m_varnames[i] == key) {
+                assert(python_pars[i] == NULL);
+                python_pars[i] = value;
+
+#if PYTHON_VERSION >= 0x300
+                if (i >= keyword_after_index) {
+                    *kw_only_found += 1;
+                }
+#endif
+
+                found = true;
+                break;
+            }
+        }
+
+        if (found == false) {
+            PyObject **varnames = function->m_varnames;
+
+            for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+                // TODO: Could do better here, STR/UNICODE key knowledge being there.
+                if (RICH_COMPARE_EQ_CBOOL_ARG_NAMES(varnames[i], key)) {
+                    assert(python_pars[i] == NULL);
+                    python_pars[i] = value;
+
+#if PYTHON_VERSION >= 0x300
+                    if (i >= keyword_after_index) {
+                        *kw_only_found += 1;
+                    }
+#endif
+
+                    found = true;
+                    break;
+                }
+            }
+        }
+
+        if (unlikely(found == false)) {
+            bool pos_only_error = false;
+
+            for (Py_ssize_t i = 0; i < kw_arg_start; i++) {
+                PyObject **varnames = function->m_varnames;
+
+                if (RICH_COMPARE_EQ_CBOOL_ARG_NAMES(varnames[i], key)) {
+                    pos_only_error = true;
+                    break;
+                }
+            }
+
+#if PYTHON_VERSION < 0x3a0
+            char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+            char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+            if (pos_only_error == true) {
+                PyErr_Format(PyExc_TypeError,
+                             "%s() got some positional-only arguments passed as keyword arguments: '%s'", function_name,
+                             Nuitka_String_Check(key) ? Nuitka_String_AsString(key) : "<non-string>");
+
+            } else {
+                PyErr_Format(PyExc_TypeError, "%s() got an unexpected keyword argument '%s'", function_name,
+                             Nuitka_String_Check(key) ? Nuitka_String_AsString(key) : "<non-string>");
+            }
+
+            Py_DECREF(value);
+
+            return -1;
+        }
+
+        kw_found += 1;
+    }
+
+    return kw_found;
+}
+
+static PyObject *COPY_DICT_KW(PyObject *dict_value);
+
+static bool MAKE_STAR_DICT_DICTIONARY_COPY(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                           PyObject *kw) {
+    Py_ssize_t star_dict_index = function->m_args_star_dict_index;
+    assert(star_dict_index != -1);
+
+    if (kw == NULL || ((PyDictObject *)kw)->ma_used == 0) {
+        python_pars[star_dict_index] = MAKE_DICT_EMPTY();
+    } else {
+        python_pars[star_dict_index] = COPY_DICT_KW(kw);
+
+        if (unlikely(python_pars[star_dict_index] == NULL)) {
+            formatErrorKeywordsMustBeString(function);
+            return false;
+        }
+    }
+
+    return true;
+}
+
+#if PYTHON_VERSION < 0x300
+static Py_ssize_t handleKeywordArgsWithStarDict(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                                PyObject *kw)
+#else
+static Py_ssize_t handleKeywordArgsWithStarDict(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                                Py_ssize_t *kw_only_found, PyObject *kw)
+#endif
+{
+    assert(function->m_args_star_dict_index != -1);
+
+    if (unlikely(MAKE_STAR_DICT_DICTIONARY_COPY(function, python_pars, kw) == false)) {
+        return -1;
+    }
+
+    Py_ssize_t kw_found = 0;
+    Py_ssize_t keywords_count = function->m_args_keywords_count;
+#if PYTHON_VERSION >= 0x300
+    Py_ssize_t keyword_after_index = function->m_args_positional_count;
+#endif
+
+    Py_ssize_t star_dict_index = function->m_args_star_dict_index;
+
+    PyObject **varnames = function->m_varnames;
+
+#if PYTHON_VERSION < 0x380
+    Py_ssize_t kw_arg_start = 0;
+#else
+    Py_ssize_t kw_arg_start = function->m_args_pos_only_count;
+#endif
+
+    for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+        PyObject *arg_name = varnames[i];
+
+        PyObject *kw_arg_value = DICT_GET_ITEM1(python_pars[star_dict_index], arg_name);
+
+        if (kw_arg_value != NULL) {
+            assert(python_pars[i] == NULL);
+
+            python_pars[i] = kw_arg_value;
+
+            PyDict_DelItem(python_pars[star_dict_index], arg_name);
+
+            kw_found += 1;
+
+#if PYTHON_VERSION >= 0x300
+            if (i >= keyword_after_index) {
+                *kw_only_found += 1;
+            }
+#endif
+        }
+    }
+
+    return kw_found;
+}
+
+#if PYTHON_VERSION < 0x300
+static Py_ssize_t handleKeywordArgsSplitWithStarDict(struct Nuitka_FunctionObject const *function,
+                                                     PyObject **python_pars, PyObject *const *kw_values,
+                                                     PyObject *kw_names)
+#else
+static Py_ssize_t handleKeywordArgsSplitWithStarDict(struct Nuitka_FunctionObject const *function,
+                                                     PyObject **python_pars, Py_ssize_t *kw_only_found,
+                                                     PyObject *const *kw_values, PyObject *kw_names)
+#endif
+{
+
+    Py_ssize_t star_dict_index = function->m_args_star_dict_index;
+    assert(star_dict_index != -1);
+
+    Py_ssize_t kw_names_size = PyTuple_GET_SIZE(kw_names);
+
+    python_pars[star_dict_index] = _PyDict_NewPresized(kw_names_size);
+
+    for (Py_ssize_t i = 0; i < kw_names_size; i++) {
+        PyObject *key = PyTuple_GET_ITEM(kw_names, i);
+        PyObject *value = kw_values[i];
+
+        PyDict_SetItem(python_pars[star_dict_index], key, value);
+    }
+
+    Py_ssize_t kw_found = 0;
+    Py_ssize_t keywords_count = function->m_args_keywords_count;
+#if PYTHON_VERSION >= 0x300
+    Py_ssize_t keyword_after_index = function->m_args_positional_count;
+#endif
+
+    PyObject **varnames = function->m_varnames;
+
+#if PYTHON_VERSION < 0x380
+    Py_ssize_t kw_arg_start = 0;
+#else
+    Py_ssize_t kw_arg_start = function->m_args_pos_only_count;
+#endif
+
+    for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+        PyObject *arg_name = varnames[i];
+
+        PyObject *kw_arg_value = DICT_GET_ITEM1(python_pars[star_dict_index], arg_name);
+
+        if (kw_arg_value != NULL) {
+            assert(python_pars[i] == NULL);
+
+            python_pars[i] = kw_arg_value;
+
+            PyDict_DelItem(python_pars[star_dict_index], arg_name);
+
+            kw_found += 1;
+
+#if PYTHON_VERSION >= 0x300
+            if (i >= keyword_after_index) {
+                *kw_only_found += 1;
+            }
+#endif
+        }
+    }
+
+    return kw_found;
+}
+
+static void makeStarListTupleCopy(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                  PyObject *const *args, Py_ssize_t args_size) {
+    assert(function->m_args_star_list_index != -1);
+    Py_ssize_t list_star_index = function->m_args_star_list_index;
+
+    // Copy left-over argument values to the star list parameter given.
+    if (args_size > function->m_args_positional_count) {
+        python_pars[list_star_index] =
+            MAKE_TUPLE(&args[function->m_args_positional_count], args_size - function->m_args_positional_count);
+    } else {
+        python_pars[list_star_index] = const_tuple_empty;
+        Py_INCREF(const_tuple_empty);
+    }
+}
+
+static void makeStarListTupleCopyMethod(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                        PyObject *const *args, Py_ssize_t args_size) {
+    assert(function->m_args_star_list_index != -1);
+    Py_ssize_t list_star_index = function->m_args_star_list_index;
+
+    // Copy left-over argument values to the star list parameter given.
+    if (args_size + 1 > function->m_args_positional_count) {
+        python_pars[list_star_index] =
+            MAKE_TUPLE(&args[function->m_args_positional_count - 1], args_size + 1 - function->m_args_positional_count);
+    } else {
+        python_pars[list_star_index] = const_tuple_empty;
+        Py_INCREF(const_tuple_empty);
+    }
+}
+
+static bool _handleArgumentsPlainOnly(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                      PyObject *const *args, Py_ssize_t args_size) {
+    Py_ssize_t arg_count = function->m_args_positional_count;
+
+    // Check if too many arguments were given in case of non list star arg.
+    // For Python3.3 it's done only later, when more knowledge has
+    // been gained. TODO: Could be done this way for improved mode
+    // on all versions.
+#if PYTHON_VERSION < 0x300
+    if (function->m_args_star_list_index == -1) {
+        if (unlikely(args_size > arg_count)) {
+#if PYTHON_VERSION < 0x270
+            formatErrorTooManyArguments(function, args_size, 0);
+#else
+            formatErrorTooManyArguments(function, args_size);
+#endif
+            return false;
+        }
+    }
+#endif
+
+#if PYTHON_VERSION >= 0x300
+    bool parameter_error = false;
+#endif
+
+    Py_ssize_t defaults_given = function->m_defaults_given;
+
+    if (args_size + defaults_given < arg_count) {
+#if PYTHON_VERSION < 0x270
+        formatErrorTooFewArguments(function, 0, args_size);
+        return false;
+#elif PYTHON_VERSION < 0x300
+        formatErrorTooFewArguments(function, args_size);
+        return false;
+#else
+        parameter_error = true;
+#endif
+    }
+
+    for (Py_ssize_t i = 0; i < args_size; i++) {
+        if (i >= arg_count)
+            break;
+
+        assert(python_pars[i] == NULL);
+
+        python_pars[i] = args[i];
+        Py_INCREF(python_pars[i]);
+    }
+
+#if PYTHON_VERSION >= 0x300
+    if (parameter_error == false) {
+#endif
+        PyObject *source = function->m_defaults;
+
+        for (Py_ssize_t i = args_size; i < arg_count; i++) {
+            assert(python_pars[i] == NULL);
+            assert(i + defaults_given >= arg_count);
+
+            python_pars[i] = PyTuple_GET_ITEM(source, defaults_given + i - arg_count);
+            Py_INCREF(python_pars[i]);
+        }
+#if PYTHON_VERSION >= 0x300
+    }
+#endif
+
+#if PYTHON_VERSION >= 0x300
+    if (unlikely(parameter_error)) {
+        formatErrorTooFewArguments(function, python_pars);
+        return false;
+    }
+
+    if (function->m_args_star_list_index == -1) {
+        // Check if too many arguments were given in case of non list star arg
+        if (unlikely(args_size > arg_count)) {
+            formatErrorTooManyArguments(function, args_size, 0);
+            return false;
+        }
+    }
+#endif
+
+    if (function->m_args_star_list_index != -1) {
+        makeStarListTupleCopy(function, python_pars, args, args_size);
+    }
+
+    return true;
+}
+
+static bool handleMethodArgumentsPlainOnly(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                           PyObject *object, PyObject *const *args, Py_ssize_t args_size) {
+    Py_ssize_t arg_count = function->m_args_positional_count;
+
+    // There may be no self, otherwise we can directly assign it.
+    if (arg_count >= 1) {
+        python_pars[0] = object;
+        Py_INCREF(object);
+    } else {
+        // Without self, there can only be star list to get the object as its
+        // first element. Or we complain about illegal arguments.
+        if (function->m_args_star_list_index == 0) {
+            python_pars[0] = MAKE_TUPLE_EMPTY(args_size + 1);
+            PyTuple_SET_ITEM0(python_pars[0], 0, object);
+
+            for (Py_ssize_t i = 0; i < args_size; i++) {
+                PyTuple_SET_ITEM0(python_pars[0], i + 1, args[i]);
+            }
+
+            return true;
+        }
+    }
+
+    // Check if too many arguments were given in case of non list star arg.
+    // For Python3.3 it's done only later, when more knowledge has
+    // been gained. TODO: Could be done this way for improved mode
+    // on all versions.
+#if PYTHON_VERSION < 0x300
+    if (function->m_args_star_list_index == -1) {
+        if (unlikely(args_size + 1 > arg_count)) {
+#if PYTHON_VERSION < 0x270
+            formatErrorTooManyArguments(function, args_size + 1, 0);
+#else
+            formatErrorTooManyArguments(function, args_size + 1);
+#endif
+            return false;
+        }
+    }
+#endif
+
+#if PYTHON_VERSION >= 0x300
+    bool parameter_error = false;
+#endif
+    Py_ssize_t defaults_given = function->m_defaults_given;
+
+    if (args_size + 1 + defaults_given < arg_count) {
+#if PYTHON_VERSION < 0x270
+        formatErrorTooFewArguments(function, 0, args_size + 1);
+        return false;
+#elif PYTHON_VERSION < 0x300
+        formatErrorTooFewArguments(function, args_size + 1);
+        return false;
+#else
+        parameter_error = true;
+#endif
+    }
+
+    for (Py_ssize_t i = 0; i < args_size; i++) {
+        if (i + 1 >= arg_count)
+            break;
+
+        assert(python_pars[i + 1] == NULL);
+
+        python_pars[i + 1] = args[i];
+        Py_INCREF(python_pars[i + 1]);
+    }
+
+#if PYTHON_VERSION >= 0x300
+    if (parameter_error == false) {
+#endif
+        for (Py_ssize_t i = args_size + 1; i < arg_count; i++) {
+            assert(python_pars[i] == NULL);
+            assert(i + defaults_given >= arg_count);
+
+            python_pars[i] = PyTuple_GET_ITEM(function->m_defaults, defaults_given + i - arg_count);
+            Py_INCREF(python_pars[i]);
+        }
+#if PYTHON_VERSION >= 0x300
+    }
+#endif
+
+#if PYTHON_VERSION >= 0x300
+    if (unlikely(parameter_error)) {
+        formatErrorTooFewArguments(function, python_pars);
+        return false;
+    }
+
+    if (function->m_args_star_list_index == -1) {
+        // Check if too many arguments were given in case of non list star arg
+        if (unlikely(args_size + 1 > arg_count)) {
+            formatErrorTooManyArguments(function, args_size + 1, 0);
+            return false;
+        }
+    }
+#endif
+
+    if (function->m_args_star_list_index != -1) {
+        makeStarListTupleCopyMethod(function, python_pars, args, args_size);
+    }
+
+    return true;
+}
+
+#if PYTHON_VERSION < 0x270
+static bool _handleArgumentsPlain(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                  PyObject *const *args, Py_ssize_t args_size, Py_ssize_t kw_found, Py_ssize_t kw_size)
+#elif PYTHON_VERSION < 0x300
+static bool _handleArgumentsPlain(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                  PyObject *const *args, Py_ssize_t args_size, Py_ssize_t kw_found)
+#else
+static bool _handleArgumentsPlain(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                  PyObject *const *args, Py_ssize_t args_size, Py_ssize_t kw_found,
+                                  Py_ssize_t kw_only_found)
+#endif
+{
+    Py_ssize_t arg_count = function->m_args_positional_count;
+
+    // Check if too many arguments were given in case of non list star arg.
+    // For Python3.3 it's done only later, when more knowledge has
+    // been gained. TODO: Could be done this way for improved mode
+    // on all versions.
+#if PYTHON_VERSION < 0x300
+    if (function->m_args_star_list_index == -1) {
+        if (unlikely(args_size > arg_count)) {
+#if PYTHON_VERSION < 0x270
+            formatErrorTooManyArguments(function, args_size, kw_size);
+#else
+            formatErrorTooManyArguments(function, args_size + kw_found);
+#endif
+            return false;
+        }
+    }
+#endif
+
+#if PYTHON_VERSION >= 0x300
+    bool parameter_error = false;
+#endif
+
+    if (kw_found > 0) {
+        Py_ssize_t i;
+        for (i = 0; i < (args_size < arg_count ? args_size : arg_count); i++) {
+            if (unlikely(python_pars[i] != NULL)) {
+                formatErrorMultipleValuesGiven(function, i);
+                return false;
+            }
+
+            python_pars[i] = args[i];
+            Py_INCREF(python_pars[i]);
+        }
+
+        Py_ssize_t defaults_given = function->m_defaults_given;
+
+        for (; i < arg_count; i++) {
+            if (python_pars[i] == NULL) {
+
+                if (i + defaults_given >= arg_count) {
+                    python_pars[i] = PyTuple_GET_ITEM(function->m_defaults, defaults_given + i - arg_count);
+                    Py_INCREF(python_pars[i]);
+                } else {
+#if PYTHON_VERSION < 0x270
+                    formatErrorTooFewArguments(function, kw_size, args_size + kw_found);
+                    return false;
+#elif PYTHON_VERSION < 0x300
+                    formatErrorTooFewArguments(function, args_size + kw_found);
+                    return false;
+#else
+                    parameter_error = true;
+#endif
+                }
+            }
+        }
+    } else {
+        Py_ssize_t usable = (args_size < arg_count ? args_size : arg_count);
+        Py_ssize_t defaults_given = function->m_defaults_given;
+
+        if (defaults_given < arg_count - usable) {
+#if PYTHON_VERSION < 0x270
+            formatErrorTooFewArguments(function, kw_size, args_size + kw_found);
+            return false;
+#elif PYTHON_VERSION < 0x300
+            formatErrorTooFewArguments(function, args_size + kw_found);
+            return false;
+#else
+            parameter_error = true;
+#endif
+        }
+
+        for (Py_ssize_t i = 0; i < usable; i++) {
+            assert(python_pars[i] == NULL);
+
+            python_pars[i] = args[i];
+            Py_INCREF(python_pars[i]);
+        }
+
+#if PYTHON_VERSION >= 0x300
+        if (parameter_error == false) {
+#endif
+            for (Py_ssize_t i = usable; i < arg_count; i++) {
+                assert(python_pars[i] == NULL);
+                assert(i + defaults_given >= arg_count);
+
+                python_pars[i] = PyTuple_GET_ITEM(function->m_defaults, defaults_given + i - arg_count);
+                Py_INCREF(python_pars[i]);
+            }
+#if PYTHON_VERSION >= 0x300
+        }
+#endif
+    }
+
+#if PYTHON_VERSION >= 0x300
+    if (unlikely(parameter_error)) {
+        formatErrorTooFewArguments(function, python_pars);
+        return false;
+    }
+
+    if (function->m_args_star_list_index == -1) {
+        // Check if too many arguments were given in case of non list star arg
+        if (unlikely(args_size > arg_count)) {
+            formatErrorTooManyArguments(function, args_size, kw_only_found);
+            return false;
+        }
+    }
+#endif
+
+    if (function->m_args_star_list_index != -1) {
+        makeStarListTupleCopy(function, python_pars, args, args_size);
+    }
+
+    return true;
+}
+
+// Release them all in case of an error.
+static void releaseParameters(struct Nuitka_FunctionObject const *function, PyObject *const *python_pars) {
+    Py_ssize_t arg_count = function->m_args_overall_count;
+
+    for (Py_ssize_t i = 0; i < arg_count; i++) {
+        Py_XDECREF(python_pars[i]);
+    }
+}
+
+static bool parseArgumentsPos(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                              PyObject *const *args, Py_ssize_t args_size) {
+    bool result;
+
+    Py_ssize_t arg_count = function->m_args_positional_count;
+
+    if (unlikely(arg_count == 0 && function->m_args_simple && args_size != 0)) {
+#if PYTHON_VERSION < 0x300
+        formatErrorNoArgumentAllowed(function, args_size);
+#else
+        formatErrorNoArgumentAllowed(function, NULL, args_size);
+#endif
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+    result = _handleArgumentsPlainOnly(function, python_pars, args, args_size);
+
+    if (result == false) {
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#if PYTHON_VERSION >= 0x300
+    // For Python3.3 the keyword only errors are all reported at once.
+    bool kw_only_error = false;
+
+    for (Py_ssize_t i = function->m_args_positional_count; i < function->m_args_keywords_count; i++) {
+        if (python_pars[i] == NULL) {
+            PyObject *arg_name = function->m_varnames[i];
+
+            if (function->m_kwdefaults != NULL) {
+                python_pars[i] = DICT_GET_ITEM1(function->m_kwdefaults, arg_name);
+            }
+
+            if (unlikely(python_pars[i] == NULL)) {
+                kw_only_error = true;
+            }
+        }
+    }
+
+    if (unlikely(kw_only_error)) {
+        formatErrorTooFewKwOnlyArguments(function, &python_pars[function->m_args_positional_count]);
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#endif
+
+    if (function->m_args_star_dict_index != -1) {
+        python_pars[function->m_args_star_dict_index] = MAKE_DICT_EMPTY();
+    }
+
+    return true;
+}
+
+// We leave it to partial inlining to specialize this.
+static bool parseArgumentsEmpty(struct Nuitka_FunctionObject const *function, PyObject **python_pars) {
+    return parseArgumentsPos(function, python_pars, NULL, 0);
+}
+
+static bool parseArgumentsMethodPos(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                    PyObject *object, PyObject *const *args, Py_ssize_t args_size) {
+    bool result;
+
+    result = handleMethodArgumentsPlainOnly(function, python_pars, object, args, args_size);
+
+    if (result == false) {
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#if PYTHON_VERSION >= 0x300
+    // For Python3 the keyword only errors are all reported at once.
+    bool kw_only_error = false;
+
+    for (Py_ssize_t i = function->m_args_positional_count; i < function->m_args_keywords_count; i++) {
+        if (python_pars[i] == NULL) {
+            PyObject *arg_name = function->m_varnames[i];
+
+            if (function->m_kwdefaults != NULL) {
+                python_pars[i] = DICT_GET_ITEM1(function->m_kwdefaults, arg_name);
+            }
+
+            if (unlikely(python_pars[i] == NULL)) {
+                kw_only_error = true;
+            }
+        }
+    }
+
+    if (unlikely(kw_only_error)) {
+        formatErrorTooFewKwOnlyArguments(function, &python_pars[function->m_args_positional_count]);
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#endif
+
+    if (function->m_args_star_dict_index != -1) {
+        python_pars[function->m_args_star_dict_index] = MAKE_DICT_EMPTY();
+    }
+
+    return true;
+}
+
+static bool parseArgumentsFullKwSplit(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                      PyObject *const *args, Py_ssize_t args_size, PyObject *const *kw_values,
+                                      PyObject *kw_names) {
+    Py_ssize_t kw_size = PyTuple_GET_SIZE(kw_names);
+    Py_ssize_t kw_found;
+    bool result;
+
+    Py_ssize_t arg_count = function->m_args_keywords_count;
+
+    if (unlikely(arg_count == 0 && function->m_args_simple && args_size + kw_size > 0)) {
+#if PYTHON_VERSION < 0x300
+        formatErrorNoArgumentAllowed(function, args_size + kw_size);
+#else
+        formatErrorNoArgumentAllowedKwSplit(function, PyTuple_GET_ITEM(kw_names, 0), args_size);
+#endif
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#if PYTHON_VERSION >= 0x300
+    Py_ssize_t kw_only_found = 0;
+#endif
+    if (function->m_args_star_dict_index != -1) {
+#if PYTHON_VERSION < 0x300
+        kw_found = handleKeywordArgsSplitWithStarDict(function, python_pars, kw_values, kw_names);
+#else
+        kw_found = handleKeywordArgsSplitWithStarDict(function, python_pars, &kw_only_found, kw_values, kw_names);
+#endif
+        if (unlikely(kw_found == -1)) {
+            releaseParameters(function, python_pars);
+            return false;
+        }
+    } else {
+#if PYTHON_VERSION < 0x300
+        kw_found = handleKeywordArgsSplit(function, python_pars, kw_values, kw_names);
+#else
+        kw_found = handleKeywordArgsSplit(function, python_pars, &kw_only_found, kw_values, kw_names);
+#endif
+        if (unlikely(kw_found == -1)) {
+            releaseParameters(function, python_pars);
+            return false;
+        }
+    }
+
+#if PYTHON_VERSION < 0x270
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found, kw_size);
+#elif PYTHON_VERSION < 0x300
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found);
+#else
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found, kw_only_found);
+#endif
+
+    if (result == false) {
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#if PYTHON_VERSION >= 0x300
+    // For Python3.3 the keyword only errors are all reported at once.
+    bool kw_only_error = false;
+
+    for (Py_ssize_t i = function->m_args_positional_count; i < function->m_args_keywords_count; i++) {
+        if (python_pars[i] == NULL) {
+            PyObject *arg_name = function->m_varnames[i];
+
+            if (function->m_kwdefaults != NULL) {
+                python_pars[i] = DICT_GET_ITEM1(function->m_kwdefaults, arg_name);
+            }
+
+            if (unlikely(python_pars[i] == NULL)) {
+                kw_only_error = true;
+            }
+        }
+    }
+
+    if (unlikely(kw_only_error)) {
+        formatErrorTooFewKwOnlyArguments(function, &python_pars[function->m_args_positional_count]);
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#endif
+
+    return true;
+}
+
+static bool parseArgumentsFull(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                               PyObject *const *args, Py_ssize_t args_size, PyObject *kw) {
+    Py_ssize_t kw_size = kw ? DICT_SIZE(kw) : 0;
+    Py_ssize_t kw_found;
+    bool result;
+
+    Py_ssize_t arg_count = function->m_args_keywords_count;
+
+    assert(kw == NULL || PyDict_CheckExact(kw));
+
+    if (unlikely(arg_count == 0 && function->m_args_simple && args_size + kw_size > 0)) {
+#if PYTHON_VERSION < 0x300
+        formatErrorNoArgumentAllowed(function, args_size + kw_size);
+#else
+        formatErrorNoArgumentAllowed(function, kw_size > 0 ? kw : NULL, args_size);
+#endif
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#if PYTHON_VERSION >= 0x300
+    Py_ssize_t kw_only_found = 0;
+#endif
+    if (function->m_args_star_dict_index != -1) {
+#if PYTHON_VERSION < 0x300
+        kw_found = handleKeywordArgsWithStarDict(function, python_pars, kw);
+#else
+        kw_found = handleKeywordArgsWithStarDict(function, python_pars, &kw_only_found, kw);
+#endif
+        if (unlikely(kw_found == -1)) {
+            releaseParameters(function, python_pars);
+            return false;
+        }
+    } else if (kw == NULL || DICT_SIZE(kw) == 0) {
+        kw_found = 0;
+    } else {
+#if PYTHON_VERSION < 0x300
+        kw_found = handleKeywordArgs(function, python_pars, kw);
+#else
+        kw_found = handleKeywordArgs(function, python_pars, &kw_only_found, kw);
+#endif
+        if (unlikely(kw_found == -1)) {
+            releaseParameters(function, python_pars);
+            return false;
+        }
+    }
+
+#if PYTHON_VERSION < 0x270
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found, kw_size);
+#elif PYTHON_VERSION < 0x300
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found);
+#else
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found, kw_only_found);
+#endif
+
+    if (result == false) {
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#if PYTHON_VERSION >= 0x300
+    // For Python3.3 the keyword only errors are all reported at once.
+    bool kw_only_error = false;
+
+    for (Py_ssize_t i = function->m_args_positional_count; i < function->m_args_keywords_count; i++) {
+        if (python_pars[i] == NULL) {
+            PyObject *arg_name = function->m_varnames[i];
+
+            if (function->m_kwdefaults != NULL) {
+                python_pars[i] = DICT_GET_ITEM1(function->m_kwdefaults, arg_name);
+            }
+
+            if (unlikely(python_pars[i] == NULL)) {
+                kw_only_error = true;
+            }
+        }
+    }
+
+    if (unlikely(kw_only_error)) {
+        formatErrorTooFewKwOnlyArguments(function, &python_pars[function->m_args_positional_count]);
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#endif
+
+    return true;
+}
+
+PyObject *Nuitka_CallFunctionNoArgs(struct Nuitka_FunctionObject const *function) {
+    NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+    memset(python_pars, 0, function->m_args_overall_count * sizeof(PyObject *));
+
+    if (unlikely(!parseArgumentsEmpty(function, python_pars))) {
+        return NULL;
+    }
+
+    return function->m_c_code(function, python_pars);
+}
+
+PyObject *Nuitka_CallFunctionPosArgs(struct Nuitka_FunctionObject const *function, PyObject *const *args,
+                                     Py_ssize_t args_size) {
+    NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+    memset(python_pars, 0, function->m_args_overall_count * sizeof(PyObject *));
+
+    if (unlikely(!parseArgumentsPos(function, python_pars, args, args_size))) {
+        return NULL;
+    }
+
+    return function->m_c_code(function, python_pars);
+}
+
+PyObject *Nuitka_CallFunctionPosArgsKwArgs(struct Nuitka_FunctionObject const *function, PyObject *const *args,
+                                           Py_ssize_t args_size, PyObject *kw) {
+    NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+    memset(python_pars, 0, function->m_args_overall_count * sizeof(PyObject *));
+
+    if (unlikely(!parseArgumentsFull(function, python_pars, args, args_size, kw))) {
+        return NULL;
+    }
+
+    return function->m_c_code(function, python_pars);
+}
+
+PyObject *Nuitka_CallFunctionPosArgsKwSplit(struct Nuitka_FunctionObject const *function, PyObject *const *args,
+                                            Py_ssize_t args_size, PyObject *const *kw_values, PyObject *kw_names) {
+    NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+    memset(python_pars, 0, function->m_args_overall_count * sizeof(PyObject *));
+
+    if (unlikely(!parseArgumentsFullKwSplit(function, python_pars, args, args_size, kw_values, kw_names))) {
+        return NULL;
+    }
+
+    return function->m_c_code(function, python_pars);
+}
+
+PyObject *Nuitka_CallMethodFunctionNoArgs(struct Nuitka_FunctionObject const *function, PyObject *object) {
+    NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+    memset(python_pars, 0, function->m_args_overall_count * sizeof(PyObject *));
+
+    if (unlikely(!parseArgumentsMethodPos(function, python_pars, object, NULL, 0))) {
+        return NULL;
+    }
+
+    return function->m_c_code(function, python_pars);
+}
+
+PyObject *Nuitka_CallMethodFunctionPosArgs(struct Nuitka_FunctionObject const *function, PyObject *object,
+                                           PyObject *const *args, Py_ssize_t args_size) {
+    NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+    memset(python_pars, 0, function->m_args_overall_count * sizeof(PyObject *));
+
+    if (unlikely(!parseArgumentsMethodPos(function, python_pars, object, args, args_size))) {
+        return NULL;
+    }
+
+    return function->m_c_code(function, python_pars);
+}
+
+PyObject *Nuitka_CallMethodFunctionPosArgsKwArgs(struct Nuitka_FunctionObject const *function, PyObject *object,
+                                                 PyObject *const *args, Py_ssize_t args_size, PyObject *kw) {
+    NUITKA_DYNAMIC_ARRAY_DECL(new_args, PyObject *, args_size + 1);
+
+    new_args[0] = object;
+    memcpy(new_args + 1, args, args_size * sizeof(PyObject *));
+
+    // TODO: Specialize implementation for massive gains.
+    return Nuitka_CallFunctionPosArgsKwArgs(function, new_args, args_size + 1, kw);
+}
+
+static Py_ssize_t handleVectorcallKeywordArgs(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                              Py_ssize_t *kw_only_found, PyObject *const *kw_names,
+                                              PyObject *const *kw_values, Py_ssize_t kw_size) {
+    Py_ssize_t keywords_count = function->m_args_keywords_count;
+
+    Py_ssize_t keyword_after_index = function->m_args_positional_count;
+
+    assert(function->m_args_star_dict_index == -1);
+
+    Py_ssize_t kw_found = 0;
+
+    for (Py_ssize_t pos = 0; pos < kw_size; pos++) {
+        PyObject *key = kw_names[pos];
+
+        if (unlikely(!checkKeywordType(key))) {
+            formatErrorKeywordsMustBeString(function);
+            return -1;
+        }
+
+        NUITKA_MAY_BE_UNUSED bool found = false;
+
+#if PYTHON_VERSION < 0x380
+        Py_ssize_t kw_arg_start = 0;
+#else
+        Py_ssize_t kw_arg_start = function->m_args_pos_only_count;
+#endif
+
+        for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+            if (function->m_varnames[i] == key) {
+                assert(python_pars[i] == NULL);
+                python_pars[i] = kw_values[pos];
+                Py_INCREF(python_pars[i]);
+
+                if (i >= keyword_after_index) {
+                    *kw_only_found += 1;
+                }
+
+                found = true;
+                break;
+            }
+        }
+
+        if (found == false) {
+            PyObject **varnames = function->m_varnames;
+
+            for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+                if (RICH_COMPARE_EQ_CBOOL_ARG_NAMES(varnames[i], key)) {
+                    assert(python_pars[i] == NULL);
+                    python_pars[i] = kw_values[pos];
+                    Py_INCREF(python_pars[i]);
+
+                    if (i >= keyword_after_index) {
+                        *kw_only_found += 1;
+                    }
+
+                    found = true;
+                    break;
+                }
+            }
+        }
+
+        if (unlikely(found == false)) {
+            bool pos_only_error = false;
+
+            for (Py_ssize_t i = 0; i < kw_arg_start; i++) {
+                PyObject **varnames = function->m_varnames;
+
+                if (RICH_COMPARE_EQ_CBOOL_ARG_NAMES(varnames[i], key)) {
+                    pos_only_error = true;
+                    break;
+                }
+            }
+
+#if PYTHON_VERSION < 0x3a0
+            char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+            char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+            if (pos_only_error == true) {
+                PyErr_Format(PyExc_TypeError,
+                             "%s() got some positional-only arguments passed as keyword arguments: '%s'", function_name,
+                             Nuitka_String_Check(key) ? Nuitka_String_AsString(key) : "<non-string>");
+
+            } else {
+                PyErr_Format(PyExc_TypeError, "%s() got an unexpected keyword argument '%s'", function_name,
+                             Nuitka_String_Check(key) ? Nuitka_String_AsString(key) : "<non-string>");
+            }
+
+            return -1;
+        }
+
+        kw_found += 1;
+    }
+
+    return kw_found;
+}
+
+static bool MAKE_STAR_DICT_DICTIONARY_COPY38(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                             PyObject *const *kw_names, PyObject *const *kw_values,
+                                             Py_ssize_t kw_size) {
+    Py_ssize_t star_dict_index = function->m_args_star_dict_index;
+    assert(star_dict_index != -1);
+
+    python_pars[star_dict_index] = _PyDict_NewPresized(kw_size);
+
+    for (int i = 0; i < kw_size; i++) {
+        PyObject *key = kw_names[i];
+
+        if (unlikely(!checkKeywordType(key))) {
+            formatErrorKeywordsMustBeString(function);
+            return false;
+        }
+
+        int res = PyDict_SetItem(python_pars[star_dict_index], key, kw_values[i]);
+
+        if (unlikely(res != 0)) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+static Py_ssize_t handleVectorcallKeywordArgsWithStarDict(struct Nuitka_FunctionObject const *function,
+                                                          PyObject **python_pars, Py_ssize_t *kw_only_found,
+                                                          PyObject *const *kw_names, PyObject *const *kw_values,
+                                                          Py_ssize_t kw_size) {
+    assert(function->m_args_star_dict_index != -1);
+
+    if (unlikely(MAKE_STAR_DICT_DICTIONARY_COPY38(function, python_pars, kw_names, kw_values, kw_size) == false)) {
+        return -1;
+    }
+
+    Py_ssize_t kw_found = 0;
+    Py_ssize_t keywords_count = function->m_args_keywords_count;
+    Py_ssize_t keyword_after_index = function->m_args_positional_count;
+
+    Py_ssize_t star_dict_index = function->m_args_star_dict_index;
+
+    PyObject **varnames = function->m_varnames;
+
+#if PYTHON_VERSION < 0x380
+    Py_ssize_t kw_arg_start = 0;
+#else
+    Py_ssize_t kw_arg_start = function->m_args_pos_only_count;
+#endif
+
+    for (Py_ssize_t i = kw_arg_start; i < keywords_count; i++) {
+        PyObject *arg_name = varnames[i];
+
+        PyObject *kw_arg_value = DICT_GET_ITEM1(python_pars[star_dict_index], arg_name);
+
+        if (kw_arg_value != NULL) {
+            assert(python_pars[i] == NULL);
+
+            python_pars[i] = kw_arg_value;
+
+            PyDict_DelItem(python_pars[star_dict_index], arg_name);
+
+            kw_found += 1;
+
+            if (i >= keyword_after_index) {
+                *kw_only_found += 1;
+            }
+        }
+    }
+
+    return kw_found;
+}
+
+static bool parseArgumentsVectorcall(struct Nuitka_FunctionObject const *function, PyObject **python_pars,
+                                     PyObject *const *args, Py_ssize_t args_size, PyObject *const *kw_names,
+                                     Py_ssize_t kw_size) {
+    Py_ssize_t kw_found;
+    bool result;
+    Py_ssize_t kw_only_found;
+
+    Py_ssize_t arg_count = function->m_args_keywords_count;
+
+    // TODO: Create different the vector call slot entries for different function types for extra
+    // performance.
+
+    if (unlikely(arg_count == 0 && function->m_args_simple && args_size + kw_size > 0)) {
+#if PYTHON_VERSION < 0x3a0
+        char const *function_name = Nuitka_String_AsString(function->m_name);
+#else
+        char const *function_name = Nuitka_String_AsString(function->m_qualname);
+#endif
+
+        if (kw_size == 0) {
+            PyErr_Format(PyExc_TypeError, "%s() takes 0 positional arguments but %zd was given", function_name,
+                         args_size);
+        } else {
+            PyErr_Format(PyExc_TypeError, "%s() got an unexpected keyword argument '%s'", function_name,
+                         Nuitka_String_AsString(kw_names[0]));
+        }
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+    kw_only_found = 0;
+    if (function->m_args_star_dict_index != -1) {
+        kw_found = handleVectorcallKeywordArgsWithStarDict(function, python_pars, &kw_only_found, kw_names,
+                                                           &args[args_size], kw_size);
+        if (unlikely(kw_found == -1)) {
+            releaseParameters(function, python_pars);
+            return false;
+        }
+    } else if (kw_size == 0) {
+        kw_found = 0;
+    } else {
+        kw_found =
+            handleVectorcallKeywordArgs(function, python_pars, &kw_only_found, kw_names, &args[args_size], kw_size);
+
+        if (unlikely(kw_found == -1)) {
+            releaseParameters(function, python_pars);
+            return false;
+        }
+    }
+
+#if PYTHON_VERSION < 0x270
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found, kw_size);
+#elif PYTHON_VERSION < 0x300
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found);
+#else
+    result = _handleArgumentsPlain(function, python_pars, args, args_size, kw_found, kw_only_found);
+#endif
+
+    if (result == false) {
+        releaseParameters(function, python_pars);
+        return false;
+    }
+
+#if PYTHON_VERSION >= 0x300
+    // For Python3 the keyword only errors are all reported at once.
+    bool kw_only_error = false;
+
+    for (Py_ssize_t i = function->m_args_positional_count; i < function->m_args_keywords_count; i++) {
+        if (python_pars[i] == NULL) {
+            PyObject *arg_name = function->m_varnames[i];
+
+            if (function->m_kwdefaults != NULL) {
+                python_pars[i] = DICT_GET_ITEM1(function->m_kwdefaults, arg_name);
+            }
+
+            if (unlikely(python_pars[i] == NULL)) {
+                kw_only_error = true;
+            }
+        }
+    }
+
+    if (unlikely(kw_only_error)) {
+        formatErrorTooFewKwOnlyArguments(function, &python_pars[function->m_args_positional_count]);
+
+        releaseParameters(function, python_pars);
+        return false;
+    }
+#endif
+
+    return true;
+}
+
+PyObject *Nuitka_CallFunctionVectorcall(struct Nuitka_FunctionObject const *function, PyObject *const *args,
+                                        Py_ssize_t args_size, PyObject *const *kw_names, Py_ssize_t kw_size) {
+    NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+    memset(python_pars, 0, function->m_args_overall_count * sizeof(PyObject *));
+
+    if (unlikely(!parseArgumentsVectorcall(function, python_pars, args, args_size, kw_names, kw_size))) {
+        return NULL;
+    }
+    return function->m_c_code(function, python_pars);
+}
+
+static PyObject *Nuitka_Function_tp_call(struct Nuitka_FunctionObject *function, PyObject *tuple_args, PyObject *kw) {
+    CHECK_OBJECT(tuple_args);
+    assert(PyTuple_CheckExact(tuple_args));
+
+    if (kw == NULL) {
+        PyObject **args = &PyTuple_GET_ITEM(tuple_args, 0);
+        Py_ssize_t args_size = PyTuple_GET_SIZE(tuple_args);
+
+        if (function->m_args_simple && args_size == function->m_args_positional_count) {
+            for (Py_ssize_t i = 0; i < args_size; i++) {
+                Py_INCREF(args[i]);
+            }
+
+            return function->m_c_code(function, args);
+        } else if (function->m_args_simple &&
+                   args_size + function->m_defaults_given == function->m_args_positional_count) {
+            NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+            memcpy(python_pars, args, args_size * sizeof(PyObject *));
+            memcpy(python_pars + args_size, &PyTuple_GET_ITEM(function->m_defaults, 0),
+                   function->m_defaults_given * sizeof(PyObject *));
+
+            for (Py_ssize_t i = 0; i < function->m_args_overall_count; i++) {
+                Py_INCREF(python_pars[i]);
+            }
+
+            return function->m_c_code(function, python_pars);
+        } else {
+            NUITKA_DYNAMIC_ARRAY_DECL(python_pars, PyObject *, function->m_args_overall_count);
+            memset(python_pars, 0, function->m_args_overall_count * sizeof(PyObject *));
+
+            if (parseArgumentsPos(function, python_pars, args, args_size)) {
+                return function->m_c_code(function, python_pars);
+            } else {
+                return NULL;
+            }
+        }
+    } else {
+        return Nuitka_CallFunctionPosArgsKwArgs(function, &PyTuple_GET_ITEM(tuple_args, 0),
+                                                PyTuple_GET_SIZE(tuple_args), kw);
+    }
+}
+
+#if PYTHON_VERSION >= 0x380 && !defined(_NUITKA_EXPERIMENTAL_DISABLE_VECTORCALL_SLOT)
+static PyObject *Nuitka_Function_tp_vectorcall(struct Nuitka_FunctionObject *function, PyObject *const *stack,
+                                               size_t nargsf, PyObject *kw_names) {
+    assert(kw_names == NULL || PyTuple_CheckExact(kw_names));
+    Py_ssize_t nkwargs = (kw_names == NULL) ? 0 : PyTuple_GET_SIZE(kw_names);
+
+    Py_ssize_t nargs = PyVectorcall_NARGS(nargsf);
+    assert(nargs >= 0);
+    assert((nargs == 0 && nkwargs == 0) || stack != NULL);
+
+    return Nuitka_CallFunctionVectorcall(function, stack, nargs, kw_names ? &PyTuple_GET_ITEM(kw_names, 0) : NULL,
+                                         nkwargs);
+}
+#endif
+
+#include "CompiledMethodType.c"
+
+#include "CompiledCodeHelpers.c"
\ No newline at end of file
Index: lab15/Lab_15/task_1.build/static_src/CompiledGeneratorType.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/static_src/CompiledGeneratorType.c b/lab15/Lab_15/task_1.build/static_src/CompiledGeneratorType.c
new file mode 100644
--- /dev/null	(date 1673971982063)
+++ b/lab15/Lab_15/task_1.build/static_src/CompiledGeneratorType.c	(date 1673971982063)
@@ -0,0 +1,1710 @@
+//     Copyright 2022, Kay Hayen, mailto:kay.hayen@gmail.com
+//
+//     Part of "Nuitka", an optimizing Python compiler that is compatible and
+//     integrates with CPython, but also works on its own.
+//
+//     Licensed under the Apache License, Version 2.0 (the "License");
+//     you may not use this file except in compliance with the License.
+//     You may obtain a copy of the License at
+//
+//        http://www.apache.org/licenses/LICENSE-2.0
+//
+//     Unless required by applicable law or agreed to in writing, software
+//     distributed under the License is distributed on an "AS IS" BASIS,
+//     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//     See the License for the specific language governing permissions and
+//     limitations under the License.
+//
+/** Compiled Generators.
+ *
+ * Unlike in CPython, we have one type for just generators, this doesn't do coroutines
+ * nor asyncgen.
+ *
+ * It strives to be full replacement for normal generators, while providing also an
+ * interface for quick iteration from compiled code.
+ *
+ */
+
+#include "nuitka/prelude.h"
+
+#include "nuitka/freelists.h"
+
+// In a separate file, code to interact with uncompiled generators, that does
+// all the quirks necessary to get those working.
+#include "CompiledGeneratorTypeUncompiledIntegration.c"
+
+// Debugging output tools
+#if _DEBUG_GENERATOR
+NUITKA_MAY_BE_UNUSED static void _PRINT_GENERATOR_STATUS(char const *descriptor, char const *context,
+                                                         struct Nuitka_GeneratorObject *generator) {
+    char const *status;
+
+    switch (generator->m_status) {
+    case status_Finished:
+        status = "(finished)";
+        break;
+    case status_Running:
+        status = "(running)";
+        break;
+    case status_Unused:
+        status = "(unused)";
+        break;
+    default:
+        status = "(ILLEGAL)";
+        break;
+    }
+
+    PRINT_STRING(descriptor);
+    PRINT_STRING(" : ");
+    PRINT_STRING(context);
+    PRINT_STRING(" ");
+    PRINT_ITEM((PyObject *)generator);
+    PRINT_STRING(" ");
+    PRINT_STRING(status);
+    PRINT_STRING(" ");
+    PRINT_REFCOUNT((PyObject *)generator);
+    PRINT_NEW_LINE();
+}
+
+#define PRINT_GENERATOR_STATUS(context, generator) _PRINT_GENERATOR_STATUS(__FUNCTION__, context, generator)
+
+#endif
+
+#if _DEBUG_GENERATOR || _DEBUG_COROUTINE || _DEBUG_ASYNCGEN
+
+NUITKA_MAY_BE_UNUSED static void PRINT_COROUTINE_VALUE(char const *name, PyObject *value) {
+    PRINT_STRING(name);
+    PRINT_STRING("=");
+    PRINT_ITEM(value);
+    if (value) {
+        PRINT_REFCOUNT(value);
+    }
+    PRINT_NEW_LINE();
+}
+
+NUITKA_MAY_BE_UNUSED static void PRINT_COROUTINE_STRING(char const *name, char const *value) {
+    PRINT_STRING(name);
+    PRINT_STRING("=");
+    PRINT_STRING(value);
+    PRINT_NEW_LINE();
+}
+
+#endif
+
+static PyObject *Nuitka_Generator_tp_repr(struct Nuitka_GeneratorObject *generator) {
+    return Nuitka_String_FromFormat("<compiled_generator object %s at %p>",
+#if PYTHON_VERSION < 0x350
+                                    Nuitka_String_AsString(generator->m_name),
+#else
+                                    Nuitka_String_AsString(generator->m_qualname),
+#endif
+                                    generator);
+}
+
+static long Nuitka_Generator_tp_traverse(struct Nuitka_GeneratorObject *generator, visitproc visit, void *arg) {
+    CHECK_OBJECT(generator);
+
+    // TODO: Identify the impact of not visiting owned objects like module.
+#if PYTHON_VERSION >= 0x300
+    Py_VISIT(generator->m_yieldfrom);
+#endif
+
+    for (Py_ssize_t i = 0; i < generator->m_closure_given; i++) {
+        Py_VISIT(generator->m_closure[i]);
+    }
+
+    Py_VISIT(generator->m_frame);
+
+    return 0;
+}
+
+static void Nuitka_Generator_release_closure(struct Nuitka_GeneratorObject *generator) {
+    for (Py_ssize_t i = 0; i < generator->m_closure_given; i++) {
+        CHECK_OBJECT(generator->m_closure[i]);
+        Py_DECREF(generator->m_closure[i]);
+    }
+
+    generator->m_closure_given = 0;
+}
+
+#if PYTHON_VERSION >= 0x300
+
+// Note: Shared with coroutines and asyncgen code.
+static PyObject *ERROR_GET_STOP_ITERATION_VALUE(void) {
+    assert(PyErr_ExceptionMatches(PyExc_StopIteration));
+
+    PyObject *exception_type, *exception_value;
+    PyTracebackObject *exception_tb;
+    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+    Py_DECREF(exception_type);
+    Py_XDECREF(exception_tb);
+
+    PyObject *value = NULL;
+
+    if (exception_value) {
+        if (EXCEPTION_MATCH_BOOL_SINGLE(exception_value, PyExc_StopIteration)) {
+            value = ((PyStopIterationObject *)exception_value)->value;
+            Py_XINCREF(value);
+            Py_DECREF(exception_value);
+        } else {
+            value = exception_value;
+        }
+    }
+
+    if (value == NULL) {
+        Py_INCREF(Py_None);
+        value = Py_None;
+    }
+
+    return value;
+}
+
+static PyObject *_Nuitka_Generator_throw2(struct Nuitka_GeneratorObject *generator, PyObject *exception_type,
+                                          PyObject *exception_value, PyTracebackObject *exception_tb);
+#if PYTHON_VERSION >= 0x350
+static PyObject *_Nuitka_Coroutine_throw2(struct Nuitka_CoroutineObject *coroutine, bool closing,
+                                          PyObject *exception_type, PyObject *exception_value,
+                                          PyTracebackObject *exception_tb);
+#endif
+
+static PyObject *_Nuitka_YieldFromPassExceptionTo(PyObject *value, PyObject *exception_type, PyObject *exception_value,
+                                                  PyTracebackObject *exception_tb) {
+    // The yielding generator is being closed, but we also are tasked to
+    // immediately close the currently running sub-generator.
+    if (EXCEPTION_MATCH_BOOL_SINGLE(exception_type, PyExc_GeneratorExit)) {
+        PyObject *close_method = PyObject_GetAttr(value, const_str_plain_close);
+
+        if (close_method) {
+            PyObject *close_value = PyObject_Call(close_method, const_tuple_empty, NULL);
+            Py_DECREF(close_method);
+
+            if (unlikely(close_value == NULL)) {
+                // Release exception, we are done with it, raising the one from close instead.
+                Py_DECREF(exception_type);
+                Py_XDECREF(exception_value);
+                Py_XDECREF(exception_tb);
+
+                return NULL;
+            }
+
+            Py_DECREF(close_value);
+        } else {
+            PyObject *error = GET_ERROR_OCCURRED();
+
+            if (error != NULL && !EXCEPTION_MATCH_BOOL_SINGLE(error, PyExc_AttributeError)) {
+                PyErr_WriteUnraisable((PyObject *)value);
+            }
+        }
+
+        // Transfer exception ownership to pusblished.
+        RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+        return NULL;
+    }
+
+#if NUITKA_UNCOMPILED_THROW_INTEGRATION
+    if (PyGen_CheckExact(value)
+#if PYTHON_VERSION >= 0x350
+        || PyCoro_CheckExact(value)
+#endif
+    ) {
+        PyGenObject *gen = (PyGenObject *)value;
+
+        // Handing exception ownership over.
+        PyObject *result = Nuitka_UncompiledGenerator_throw(gen, 1, exception_type, exception_value, exception_tb);
+
+        return result;
+    }
+#endif
+
+    if (Nuitka_Generator_Check(value)) {
+        struct Nuitka_GeneratorObject *gen = ((struct Nuitka_GeneratorObject *)value);
+
+        return _Nuitka_Generator_throw2(gen, exception_type, exception_value, exception_tb);
+    }
+
+#if PYTHON_VERSION >= 0x350
+    if (Nuitka_Coroutine_Check(value)) {
+        struct Nuitka_CoroutineObject *coro = ((struct Nuitka_CoroutineObject *)value);
+        // Handing exception ownership over.
+        return _Nuitka_Coroutine_throw2(coro, true, exception_type, exception_value, exception_tb);
+    }
+
+    if (Nuitka_CoroutineWrapper_Check(value)) {
+        struct Nuitka_CoroutineObject *coro = ((struct Nuitka_CoroutineWrapperObject *)value)->m_coroutine;
+        // Handing exception ownership over.
+        return _Nuitka_Coroutine_throw2(coro, true, exception_type, exception_value, exception_tb);
+    }
+#endif
+
+    PyObject *throw_method = PyObject_GetAttr(value, const_str_plain_throw);
+
+    if (throw_method) {
+        PyObject *result =
+            PyObject_CallFunctionObjArgs(throw_method, exception_type, exception_value, exception_tb, NULL);
+        Py_DECREF(throw_method);
+
+        // Releasing exception we own.
+        Py_DECREF(exception_type);
+        Py_XDECREF(exception_value);
+        Py_XDECREF(exception_tb);
+
+        return result;
+    } else if (EXCEPTION_MATCH_BOOL_SINGLE(GET_ERROR_OCCURRED(), PyExc_AttributeError)) {
+        // Restoring the exception we own, to be released when handling it.
+        RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+        return NULL;
+    } else {
+        assert(ERROR_OCCURRED());
+
+        // Releasing exception we own.
+        Py_DECREF(exception_type);
+        Py_XDECREF(exception_value);
+        Py_XDECREF(exception_tb);
+
+        return NULL;
+    }
+}
+
+static PyObject *_Nuitka_YieldFromGeneratorCore(struct Nuitka_GeneratorObject *generator, PyObject *yieldfrom,
+                                                PyObject *send_value) {
+    // Send iteration value to the sub-generator, which may be a CPython
+    // generator object, something with an iterator next, or a send method,
+    // where the later is only required if values other than "None" need to
+    // be passed in.
+    CHECK_OBJECT(yieldfrom);
+    assert(send_value != NULL || ERROR_OCCURRED());
+
+    PyObject *retval;
+
+#if 0
+    PRINT_STRING("YIELD CORE:");
+    PRINT_ITEM( value );
+    PRINT_ITEM( send_value );
+
+    PRINT_NEW_LINE();
+#endif
+
+    assert(send_value != NULL || ERROR_OCCURRED());
+
+    PyObject *exception_type, *exception_value;
+    PyTracebackObject *exception_tb;
+    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+    // Exception, was thrown into us, need to send that to sub-generator.
+    if (exception_type != NULL) {
+        // Passing ownership of exception fetch to it.
+        retval = _Nuitka_YieldFromPassExceptionTo(yieldfrom, exception_type, exception_value, exception_tb);
+
+        if (unlikely(send_value == NULL)) {
+            PyObject *error = GET_ERROR_OCCURRED();
+
+            if (error != NULL && EXCEPTION_MATCH_BOOL_SINGLE(error, PyExc_StopIteration)) {
+                generator->m_returned = ERROR_GET_STOP_ITERATION_VALUE();
+
+                assert(!ERROR_OCCURRED());
+                return NULL;
+            }
+        }
+    } else if (PyGen_CheckExact(yieldfrom)) {
+        retval = Nuitka_PyGen_Send((PyGenObject *)yieldfrom, Py_None);
+    }
+#if PYTHON_VERSION >= 0x350
+    else if (PyCoro_CheckExact(yieldfrom)) {
+        retval = Nuitka_PyGen_Send((PyGenObject *)yieldfrom, Py_None);
+    }
+#endif
+    else if (send_value == Py_None && Py_TYPE(yieldfrom)->tp_iternext != NULL) {
+        retval = Py_TYPE(yieldfrom)->tp_iternext(yieldfrom);
+    } else {
+        // Bug compatibility here, before 3.3 tuples were unrolled in calls, which is what
+        // PyObject_CallMethod does.
+#if PYTHON_VERSION >= 0x340
+        retval = PyObject_CallMethodObjArgs(yieldfrom, const_str_plain_send, send_value, NULL);
+#else
+        retval = PyObject_CallMethod(yieldfrom, (char *)"send", (char *)"O", send_value);
+#endif
+    }
+
+    // Check the sub-generator result
+    if (retval == NULL) {
+        PyObject *error = GET_ERROR_OCCURRED();
+
+        if (error == NULL) {
+            Py_INCREF(Py_None);
+            generator->m_returned = Py_None;
+        } else if (likely(EXCEPTION_MATCH_BOOL_SINGLE(error, PyExc_StopIteration))) {
+            // The sub-generator has given an exception. In case of
+            // StopIteration, we need to check the value, as it is going to be
+            // the expression value of this "yield from", and we are done. All
+            // other errors, we need to raise.
+            generator->m_returned = ERROR_GET_STOP_ITERATION_VALUE();
+            assert(!ERROR_OCCURRED());
+        }
+
+        return NULL;
+    } else {
+        return retval;
+    }
+}
+
+static PyObject *Nuitka_YieldFromGeneratorCore(struct Nuitka_GeneratorObject *generator, PyObject *send_value) {
+    CHECK_OBJECT(generator);
+    CHECK_OBJECT_X(send_value);
+
+    PyObject *yieldfrom = generator->m_yieldfrom;
+    CHECK_OBJECT(yieldfrom);
+
+    // Need to make it unaccessible while using it.
+    generator->m_yieldfrom = NULL;
+    PyObject *yielded = _Nuitka_YieldFromGeneratorCore(generator, yieldfrom, send_value);
+
+    if (yielded == NULL) {
+        Py_DECREF(yieldfrom);
+
+        if (generator->m_returned != NULL) {
+            PyObject *yield_from_result = generator->m_returned;
+            generator->m_returned = NULL;
+
+            yielded = ((generator_code)generator->m_code)(generator, yield_from_result);
+        } else {
+            assert(ERROR_OCCURRED());
+            yielded = ((generator_code)generator->m_code)(generator, NULL);
+        }
+
+    } else {
+        generator->m_yieldfrom = yieldfrom;
+    }
+
+    return yielded;
+}
+
+static PyObject *Nuitka_YieldFromGeneratorNext(struct Nuitka_GeneratorObject *generator) {
+    CHECK_OBJECT(generator);
+
+    // Coroutines are already perfect for yielding from.
+#if PYTHON_VERSION >= 0x350
+    if (PyCoro_CheckExact(generator->m_yieldfrom) || Nuitka_Coroutine_Check(generator->m_yieldfrom)) {
+        if (unlikely((generator->m_code_object->co_flags & CO_ITERABLE_COROUTINE) == 0)) {
+            SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError,
+                                            "cannot 'yield from' a coroutine object in a non-coroutine generator");
+        }
+    } else
+#endif
+    {
+        PyObject *new_iterator = MAKE_ITERATOR(generator->m_yieldfrom);
+        if (new_iterator != NULL) {
+            Py_DECREF(generator->m_yieldfrom);
+            generator->m_yieldfrom = new_iterator;
+        }
+    }
+
+    return Nuitka_YieldFromGeneratorCore(generator, Py_None);
+}
+
+static PyObject *Nuitka_YieldFromGeneratorInitial(struct Nuitka_GeneratorObject *generator, PyObject *send_value) {
+    PyObject *result = Nuitka_YieldFromGeneratorCore(generator, send_value);
+
+#if 0
+    PRINT_STRING("RES:");
+    PRINT_ITEM( result );
+    PRINT_NEW_LINE();
+#endif
+
+    return result;
+}
+
+#endif
+
+static Nuitka_ThreadStateFrameType *_Nuitka_GeneratorPushFrame(PyThreadState *thread_state,
+                                                               Nuitka_ThreadStateFrameType *generator_frame) {
+    // First take of running frame from the stack, owning a reference.
+#if PYTHON_VERSION < 0x3b0
+    PyFrameObject *return_frame = thread_state->frame;
+#ifndef __NUITKA_NO_ASSERT__
+    if (return_frame) {
+        assertFrameObject((struct Nuitka_FrameObject *)return_frame);
+    }
+#endif
+#else
+    _PyInterpreterFrame *return_frame = thread_state->cframe->current_frame;
+#endif
+
+    if (generator_frame != NULL) {
+
+        // It's not supposed to be on the top right now.
+#if PYTHON_VERSION < 0x3b0
+        // It would be nice if our frame were still alive. Nobody had the
+        // right to release it.
+        assertFrameObject((struct Nuitka_FrameObject *)generator_frame);
+
+        // Link frames
+        assert(return_frame != generator_frame);
+        Py_XINCREF(return_frame);
+        generator_frame->f_back = return_frame;
+
+        // Make generator frame active
+        thread_state->frame = generator_frame;
+#else
+        // It would be nice if our frame were still alive. Nobody had the
+        // right to release it.
+        assertFrameObject((struct Nuitka_FrameObject *)(generator_frame->frame_obj));
+
+        // Link frames
+        if (return_frame) {
+            // Connect frames if possible.
+            PyFrameObject *back_frame = return_frame->frame_obj;
+
+            generator_frame->frame_obj->f_back = back_frame;
+            Py_INCREF(back_frame);
+        }
+        generator_frame->previous = return_frame;
+
+        // Make generator frame active
+        thread_state->cframe->current_frame = generator_frame;
+#endif
+    }
+
+    return return_frame;
+}
+
+static Nuitka_ThreadStateFrameType *_Nuitka_GeneratorPushFrameObject(PyThreadState *thread_state,
+                                                                     struct Nuitka_FrameObject *generator_frame) {
+#if PYTHON_VERSION < 0x3b0
+    Nuitka_ThreadStateFrameType *thread_frame = &generator_frame->m_frame;
+#else
+    Nuitka_ThreadStateFrameType *thread_frame = NULL;
+    if (generator_frame != NULL) {
+        thread_frame = &generator_frame->m_interpreter_frame;
+    }
+#endif
+
+    return _Nuitka_GeneratorPushFrame(thread_state, thread_frame);
+}
+
+static void _Nuitka_GeneratorPopFrame(PyThreadState *thread_state, Nuitka_ThreadStateFrameType *return_frame) {
+#if PYTHON_VERSION < 0x3b0
+    thread_state->frame = return_frame;
+#else
+    thread_state->cframe->current_frame = return_frame;
+
+    if (return_frame != NULL) {
+        return_frame->previous = NULL;
+    }
+#endif
+}
+
+static PyObject *_Nuitka_Generator_send(struct Nuitka_GeneratorObject *generator, PyObject *value,
+                                        PyObject *exception_type, PyObject *exception_value,
+                                        PyTracebackObject *exception_tb) {
+    CHECK_OBJECT(generator);
+    assert(Nuitka_Generator_Check((PyObject *)generator));
+    CHECK_OBJECT_X(exception_type);
+    CHECK_OBJECT_X(exception_value);
+    CHECK_OBJECT_X(exception_tb);
+    CHECK_OBJECT_X(value);
+
+#if _DEBUG_GENERATOR
+    PRINT_GENERATOR_STATUS("Enter", generator);
+    PRINT_COROUTINE_VALUE("value", value);
+    PRINT_EXCEPTION(exception_type, exception_value, exception_tb);
+    PRINT_CURRENT_EXCEPTION();
+    PRINT_NEW_LINE();
+#endif
+
+    if (value != NULL) {
+        assert(exception_type == NULL);
+        assert(exception_value == NULL);
+        assert(exception_tb == NULL);
+    }
+
+    if (generator->m_status != status_Finished) {
+        if (generator->m_running) {
+            SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_ValueError, "generator already executing");
+            return NULL;
+        }
+
+        PyThreadState *thread_state = PyThreadState_GET();
+
+#if PYTHON_VERSION < 0x300
+        PyObject *saved_exception_type = thread_state->exc_type;
+        PyObject *saved_exception_value = NULL;
+        PyTracebackObject *saved_exception_traceback = NULL;
+
+        if (saved_exception_type != Py_None && saved_exception_type != NULL) {
+            saved_exception_value = thread_state->exc_value;
+            Py_INCREF(saved_exception_type);
+            Py_XINCREF(saved_exception_value);
+            saved_exception_traceback = (PyTracebackObject *)thread_state->exc_traceback;
+            Py_XINCREF(saved_exception_traceback);
+        }
+#endif
+
+        // Put the generator back on the frame stack.
+        Nuitka_ThreadStateFrameType *return_frame = _Nuitka_GeneratorPushFrameObject(thread_state, generator->m_frame);
+
+        if (generator->m_status == status_Unused) {
+            generator->m_status = status_Running;
+        }
+
+        // Continue the yielder function while preventing recursion.
+        generator->m_running = true;
+
+        // Check for thrown exception, publish it to the generator code.
+        if (unlikely(exception_type)) {
+            assert(value == NULL);
+
+            // Transfer exception ownership to published.
+            RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+        }
+
+        if (generator->m_frame) {
+            Nuitka_Frame_MarkAsExecuting(generator->m_frame);
+        }
+
+#if _DEBUG_GENERATOR
+        PRINT_GENERATOR_STATUS("Switching to coroutine", generator);
+        PRINT_COROUTINE_VALUE("value", value);
+        PRINT_CURRENT_EXCEPTION();
+        PRINT_NEW_LINE();
+        // dumpFrameStack();
+#endif
+
+        PyObject *yielded;
+
+#if PYTHON_VERSION >= 0x300
+        if (generator->m_yieldfrom == NULL) {
+            yielded = ((generator_code)generator->m_code)(generator, value);
+        } else {
+            yielded = Nuitka_YieldFromGeneratorInitial(generator, value);
+        }
+#else
+        yielded = ((generator_code)generator->m_code)(generator, value);
+#endif
+
+#if PYTHON_VERSION >= 0x300
+        // If the generator returns with m_yieldfrom set, it wants us to yield
+        // from that value from now on.
+        while (yielded == NULL && generator->m_yieldfrom != NULL) {
+            yielded = Nuitka_YieldFromGeneratorNext(generator);
+        }
+#endif
+        if (generator->m_frame) {
+            Nuitka_Frame_MarkAsNotExecuting(generator->m_frame);
+        }
+
+        generator->m_running = false;
+
+        thread_state = PyThreadState_GET();
+
+        // Remove the generator from the frame stack.
+        if (generator->m_frame) {
+            // assert(thread_state->frame == &generator->m_frame->m_frame);
+            assertFrameObject(generator->m_frame);
+
+            Py_CLEAR(generator->m_frame->m_frame.f_back);
+        }
+
+        // Return back to the frame that called us.
+        _Nuitka_GeneratorPopFrame(thread_state, return_frame);
+
+#if _DEBUG_GENERATOR
+        PRINT_GENERATOR_STATUS("Returned from generator", generator);
+        // dumpFrameStack();
+#endif
+
+        if (yielded == NULL) {
+#if _DEBUG_GENERATOR
+            PRINT_GENERATOR_STATUS("finishing from yield", generator);
+            PRINT_STRING("-> finishing generator sets status_Finished\n");
+            PRINT_COROUTINE_VALUE("return_value", generator->m_returned);
+            PRINT_CURRENT_EXCEPTION();
+            PRINT_NEW_LINE();
+#endif
+            generator->m_status = status_Finished;
+
+            if (generator->m_frame != NULL) {
+#if PYTHON_VERSION >= 0x340
+                Nuitka_SetFrameGenerator(generator->m_frame, NULL);
+#endif
+                Py_DECREF(generator->m_frame);
+                generator->m_frame = NULL;
+            }
+
+            Nuitka_Generator_release_closure(generator);
+
+#if PYTHON_VERSION < 0x300
+            if (saved_exception_type != NULL && saved_exception_type != Py_None) {
+                Py_DECREF(saved_exception_type);
+                Py_XDECREF(saved_exception_value);
+                Py_XDECREF(saved_exception_traceback);
+            }
+#endif
+
+#if PYTHON_VERSION >= 0x350
+            if (
+#if PYTHON_VERSION < 0x370
+                generator->m_code_object->co_flags & CO_FUTURE_GENERATOR_STOP &&
+#endif
+                GET_ERROR_OCCURRED() == PyExc_StopIteration) {
+                PyObject *saved_exception_type, *saved_exception_value;
+                PyTracebackObject *saved_exception_tb;
+
+                FETCH_ERROR_OCCURRED(&saved_exception_type, &saved_exception_value, &saved_exception_tb);
+                NORMALIZE_EXCEPTION(&saved_exception_type, &saved_exception_value, &saved_exception_tb);
+
+                SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_RuntimeError, "generator raised StopIteration");
+
+                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+
+                RAISE_EXCEPTION_WITH_CAUSE(&exception_type, &exception_value, &exception_tb, saved_exception_value);
+
+                CHECK_OBJECT(exception_value);
+                CHECK_OBJECT(saved_exception_value);
+
+                Py_INCREF(saved_exception_value);
+                PyException_SetContext(exception_value, saved_exception_value);
+
+                Py_DECREF(saved_exception_type);
+                Py_XDECREF(saved_exception_tb);
+
+                RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+                return NULL;
+            }
+#endif
+
+            // Create StopIteration if necessary, i.e. return value that is not "None" was
+            // given. TODO: Push this further down the user line, we might be able to avoid
+            // it for some uses, e.g. quick iteration entirely.
+#if PYTHON_VERSION >= 0x300
+            if (generator->m_returned) {
+                if (generator->m_returned != Py_None) {
+                    Nuitka_SetStopIterationValue(generator->m_returned);
+                }
+
+                Py_DECREF(generator->m_returned);
+                generator->m_returned = NULL;
+
+#if _DEBUG_GENERATOR
+                PRINT_GENERATOR_STATUS("Return value to exception set", generator);
+                PRINT_CURRENT_EXCEPTION();
+                PRINT_NEW_LINE();
+#endif
+            }
+#endif
+
+            return NULL;
+        } else {
+#if _NUITKA_MAINTAIN_SYS_EXC_VARS
+            PyObject *old_type = thread_state->exc_type;
+            PyObject *old_value = thread_state->exc_value;
+            PyTracebackObject *old_tb = (PyTracebackObject *)thread_state->exc_traceback;
+
+            // Set sys attributes in the fastest possible way.
+            PyObject *sys_dict = thread_state->interp->sysdict;
+            CHECK_OBJECT(sys_dict);
+
+            if (saved_exception_type != NULL && saved_exception_type != Py_None) {
+                thread_state->exc_type = saved_exception_type;
+                thread_state->exc_value = saved_exception_value;
+                thread_state->exc_traceback = (PyObject *)saved_exception_traceback;
+
+                Py_XDECREF(old_type);
+                Py_XDECREF(old_value);
+                Py_XDECREF(old_tb);
+
+                if (old_type != saved_exception_type) {
+                    PyDict_SetItem(sys_dict, const_str_plain_exc_type, saved_exception_type);
+                }
+                if (saved_exception_value != old_value) {
+                    PyDict_SetItem(sys_dict, const_str_plain_exc_value,
+                                   saved_exception_value ? saved_exception_value : Py_None);
+                }
+                if (saved_exception_traceback != old_tb) {
+                    PyDict_SetItem(sys_dict, const_str_plain_exc_traceback,
+                                   saved_exception_traceback ? (PyObject *)saved_exception_traceback : Py_None);
+                }
+            } else {
+                thread_state->exc_type = Py_None;
+                thread_state->exc_value = Py_None;
+                thread_state->exc_traceback = (PyObject *)Py_None;
+
+                Py_INCREF(Py_None);
+                Py_INCREF(Py_None);
+                Py_INCREF(Py_None);
+
+                Py_XDECREF(old_type);
+                Py_XDECREF(old_value);
+                Py_XDECREF(old_tb);
+
+                if (old_type != Py_None) {
+                    PyDict_SetItem(sys_dict, const_str_plain_exc_type, Py_None);
+                }
+                if (old_value != Py_None) {
+                    PyDict_SetItem(sys_dict, const_str_plain_exc_value, Py_None);
+                }
+                if (old_tb != (PyTracebackObject *)Py_None) {
+                    PyDict_SetItem(sys_dict, const_str_plain_exc_traceback, Py_None);
+                }
+            }
+#endif
+
+            return yielded;
+        }
+    } else {
+        return NULL;
+    }
+}
+
+static PyObject *Nuitka_Generator_send(struct Nuitka_GeneratorObject *generator, PyObject *value) {
+    if (generator->m_status == status_Unused && value != NULL && value != Py_None) {
+        // Buggy CPython 3.10 refuses to allow later usage.
+#if PYTHON_VERSION >= 0x3a0 && PYTHON_VERSION < 0x3a2
+        generator->m_status = status_Finished;
+#endif
+
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "can't send non-None value to a just-started generator");
+        return NULL;
+    }
+
+    PyObject *result = _Nuitka_Generator_send(generator, value, NULL, NULL, NULL);
+
+    if (result == NULL) {
+        if (GET_ERROR_OCCURRED() == NULL) {
+            SET_CURRENT_EXCEPTION_TYPE0(PyExc_StopIteration);
+        }
+    }
+
+    return result;
+}
+
+static PyObject *Nuitka_Generator_tp_iternext(struct Nuitka_GeneratorObject *generator) {
+    return _Nuitka_Generator_send(generator, Py_None, NULL, NULL, NULL);
+}
+
+/* Our own qiter interface, which is for quicker simple loop style iteration,
+   that does not send anything in. */
+PyObject *Nuitka_Generator_qiter(struct Nuitka_GeneratorObject *generator, bool *finished) {
+    PyObject *result = _Nuitka_Generator_send(generator, Py_None, NULL, NULL, NULL);
+
+    if (result == NULL) {
+        if (unlikely(!CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED())) {
+            *finished = false;
+            return NULL;
+        }
+
+        *finished = true;
+        return NULL;
+    }
+
+    *finished = false;
+    return result;
+}
+
+// Note: Used by compiled frames.
+static bool _Nuitka_Generator_close(struct Nuitka_GeneratorObject *generator) {
+#if _DEBUG_GENERATOR
+    PRINT_GENERATOR_STATUS("Enter", generator);
+#endif
+    CHECK_OBJECT(generator);
+
+    if (generator->m_status == status_Running) {
+        Py_INCREF(PyExc_GeneratorExit);
+
+        PyObject *result = _Nuitka_Generator_send(generator, NULL, PyExc_GeneratorExit, NULL, NULL);
+
+        if (unlikely(result)) {
+            Py_DECREF(result);
+
+            SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_RuntimeError, "generator ignored GeneratorExit");
+            return false;
+        } else {
+            PyObject *error = GET_ERROR_OCCURRED();
+
+            // StopIteration as exception.
+            if (error == NULL) {
+                return true;
+            }
+
+            // Maybe another acceptable exception for generator exit.
+            if (EXCEPTION_MATCH_GENERATOR(error)) {
+                CLEAR_ERROR_OCCURRED();
+
+                return true;
+            }
+
+            return false;
+        }
+    }
+
+    return true;
+}
+
+static PyObject *Nuitka_Generator_close(struct Nuitka_GeneratorObject *generator) {
+    bool r = _Nuitka_Generator_close(generator);
+
+    if (unlikely(r == false)) {
+        return NULL;
+    } else {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+}
+
+// Shared code for checking a thrown exception, coroutines, asyncgen, uncompiled ones do this too.
+static bool _Nuitka_Generator_check_throw2(PyObject **exception_type, PyObject **exception_value,
+                                           PyTracebackObject **exception_tb) {
+    CHECK_OBJECT(*exception_type);
+    CHECK_OBJECT_X(*exception_value);
+    CHECK_OBJECT_X(*exception_tb);
+
+    if (*exception_tb == (PyTracebackObject *)Py_None) {
+        Py_DECREF(*exception_tb);
+        *exception_tb = NULL;
+    } else if (*exception_tb != NULL && !PyTraceBack_Check(*exception_tb)) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "throw() third argument must be a traceback object");
+        goto failed_throw;
+    }
+
+    if (PyExceptionClass_Check(*exception_type)) {
+        // TODO: Must not normalize here.
+        NORMALIZE_EXCEPTION(exception_type, exception_value, exception_tb);
+    } else if (PyExceptionInstance_Check(*exception_type)) {
+        if (*exception_value != NULL && *exception_value != Py_None) {
+            SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "instance exception may not have a separate value");
+            goto failed_throw;
+        }
+
+        // Release old None value and replace it with the object, then set the exception type
+        // from the class.
+        Py_XDECREF(*exception_value);
+        *exception_value = *exception_type;
+
+        *exception_type = PyExceptionInstance_Class(*exception_type);
+        Py_INCREF(*exception_type);
+    } else {
+#if PYTHON_VERSION < 0x300
+        PyErr_Format(PyExc_TypeError, "exceptions must be classes, or instances, not %s",
+                     Py_TYPE(*exception_type)->tp_name);
+#else
+        PyErr_Format(PyExc_TypeError, "exceptions must be classes or instances deriving from BaseException, not %s",
+                     Py_TYPE(*exception_type)->tp_name);
+#endif
+
+        goto failed_throw;
+    }
+
+    return true;
+
+failed_throw:
+    // Release exception, we are done with it now.
+    Py_DECREF(*exception_type);
+    Py_XDECREF(*exception_value);
+    Py_XDECREF(*exception_tb);
+
+    return false;
+}
+
+#if PYTHON_VERSION >= 0x300
+
+static bool _Nuitka_Generator_close(struct Nuitka_GeneratorObject *generator);
+#if PYTHON_VERSION >= 0x350
+static bool _Nuitka_Coroutine_close(struct Nuitka_CoroutineObject *coroutine);
+#if PYTHON_VERSION >= 0x360
+static bool _Nuitka_Asyncgen_close(struct Nuitka_AsyncgenObject *asyncgen);
+#endif
+#endif
+
+// Note: This is also used for coroutines and asyncgen
+static bool Nuitka_gen_close_iter(PyObject *yieldfrom) {
+#if _DEBUG_GENERATOR
+    PRINT_STRING("Nuitka_gen_close_iter: Enter\n");
+#endif
+
+    CHECK_OBJECT(yieldfrom);
+
+    // TODO: Could specialize depending in yieldfrom type for performance. Many
+    // times these will be our own ones, or known ones like uncompiled
+    // generators.
+    if (Nuitka_Generator_Check(yieldfrom)) {
+#if _DEBUG_GENERATOR
+        PRINT_STRING("Nuitka_gen_close_iter: Defer to _Nuitka_Generator_close\n");
+#endif
+        return _Nuitka_Generator_close((struct Nuitka_GeneratorObject *)yieldfrom);
+    }
+
+#if PYTHON_VERSION >= 0x350
+    if (Nuitka_Coroutine_Check(yieldfrom)) {
+#if _DEBUG_GENERATOR
+        PRINT_STRING("Nuitka_gen_close_iter: Defer to _Nuitka_Coroutine_close\n");
+#endif
+        return _Nuitka_Coroutine_close((struct Nuitka_CoroutineObject *)yieldfrom);
+    }
+#endif
+
+#if PYTHON_VERSION >= 0x360
+    if (Nuitka_Asyncgen_Check(yieldfrom)) {
+#if _DEBUG_GENERATOR
+        PRINT_STRING("Nuitka_gen_close_iter: Defer to _Nuitka_Asyncgen_close\n");
+#endif
+        return _Nuitka_Asyncgen_close((struct Nuitka_AsyncgenObject *)yieldfrom);
+    }
+#endif
+
+    PyObject *meth = PyObject_GetAttr(yieldfrom, const_str_plain_close);
+
+    if (unlikely(meth == NULL)) {
+        if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError))) {
+#if _DEBUG_GENERATOR
+            PRINT_STRING("Nuitka_gen_close_iter: Strange error while looking up close method.\n");
+#endif
+            PyErr_WriteUnraisable(yieldfrom);
+        }
+
+        CLEAR_ERROR_OCCURRED();
+
+#if _DEBUG_GENERATOR
+        PRINT_STRING("Nuitka_gen_close_iter: Leave, has no close method.\n");
+#endif
+        return true;
+    }
+
+    PyObject *retval = CALL_FUNCTION_NO_ARGS(meth);
+    Py_DECREF(meth);
+
+    if (unlikely(retval == NULL)) {
+#if _DEBUG_GENERATOR
+        PRINT_STRING("Nuitka_gen_close_iter: Leave, exception from close.\n");
+#endif
+        return false;
+    }
+
+    CHECK_OBJECT(retval);
+    Py_DECREF(retval);
+
+#if _DEBUG_GENERATOR
+    PRINT_STRING("Nuitka_gen_close_iter: Leave, closed.\n");
+#endif
+
+    return true;
+}
+#endif
+
+#if PYTHON_VERSION >= 0x360
+static bool Nuitka_AsyncgenAsend_Check(PyObject *object);
+struct Nuitka_AsyncgenAsendObject;
+static PyObject *_Nuitka_AsyncgenAsend_throw2(struct Nuitka_AsyncgenAsendObject *asyncgen_asend,
+                                              PyObject *exception_type, PyObject *exception_value,
+                                              PyTracebackObject *exception_tb);
+#endif
+
+static PyObject *_Nuitka_Generator_throw2(struct Nuitka_GeneratorObject *generator, PyObject *exception_type,
+                                          PyObject *exception_value, PyTracebackObject *exception_tb) {
+#if _DEBUG_GENERATOR
+    PRINT_GENERATOR_STATUS("Enter", generator);
+    PRINT_COROUTINE_VALUE("yieldfrom", generator->m_yieldfrom);
+    PRINT_EXCEPTION(exception_type, exception_value, exception_tb);
+    PRINT_NEW_LINE();
+#endif
+
+    CHECK_OBJECT(generator);
+    assert(Nuitka_Generator_Check((PyObject *)generator));
+    CHECK_OBJECT(exception_type);
+    CHECK_OBJECT_X(exception_value);
+    CHECK_OBJECT_X(exception_tb);
+
+#if PYTHON_VERSION >= 0x300
+    if (generator->m_yieldfrom != NULL) {
+        if (EXCEPTION_MATCH_BOOL_SINGLE(exception_type, PyExc_GeneratorExit)) {
+            // Generators need to close the yield_from.
+            generator->m_running = 1;
+            bool res = Nuitka_gen_close_iter(generator->m_yieldfrom);
+            generator->m_running = 0;
+
+            if (res == false) {
+                // Release exception, we are done with it now and pick up the new one.
+                Py_DECREF(exception_type);
+                Py_XDECREF(exception_value);
+                Py_XDECREF(exception_tb);
+
+                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
+            }
+
+            // Transferred exception ownership to "_Nuitka_Generator_send".
+            return _Nuitka_Generator_send(generator, NULL, exception_type, exception_value, exception_tb);
+        }
+
+        PyObject *ret;
+
+#if _DEBUG_GENERATOR
+        PRINT_GENERATOR_STATUS("Passing to yielded from", generator);
+        PRINT_COROUTINE_VALUE("m_yieldfrom", generator->m_yieldfrom);
+        PRINT_NEW_LINE();
+#endif
+
+        if (Nuitka_Generator_Check(generator->m_yieldfrom)) {
+            struct Nuitka_GeneratorObject *gen = ((struct Nuitka_GeneratorObject *)generator->m_yieldfrom);
+            // Transferred exception ownership to "_Nuitka_Generator_throw2".
+            generator->m_running = 1;
+            ret = _Nuitka_Generator_throw2(gen, exception_type, exception_value, exception_tb);
+            generator->m_running = 0;
+#if NUITKA_UNCOMPILED_THROW_INTEGRATION
+        } else if (PyGen_CheckExact(generator->m_yieldfrom)) {
+            PyGenObject *gen = (PyGenObject *)generator->m_yieldfrom;
+
+            // Transferred exception ownership to "Nuitka_UncompiledGenerator_throw".
+            generator->m_running = 1;
+            ret = Nuitka_UncompiledGenerator_throw(gen, 1, exception_type, exception_value, exception_tb);
+            generator->m_running = 0;
+#endif
+#if PYTHON_VERSION >= 0x350
+        } else if (Nuitka_Coroutine_Check(generator->m_yieldfrom)) {
+            struct Nuitka_CoroutineObject *coro = ((struct Nuitka_CoroutineObject *)generator->m_yieldfrom);
+            // Transferred exception ownership to "_Nuitka_Coroutine_throw2".
+            generator->m_running = 1;
+            ret = _Nuitka_Coroutine_throw2(coro, true, exception_type, exception_value, exception_tb);
+            generator->m_running = 0;
+        } else if (Nuitka_CoroutineWrapper_Check(generator->m_yieldfrom)) {
+            struct Nuitka_CoroutineObject *coro =
+                ((struct Nuitka_CoroutineWrapperObject *)generator->m_yieldfrom)->m_coroutine;
+
+            // Transferred exception ownership to "_Nuitka_Coroutine_throw2".
+            generator->m_running = 1;
+            ret = _Nuitka_Coroutine_throw2(coro, true, exception_type, exception_value, exception_tb);
+            generator->m_running = 0;
+#if NUITKA_UNCOMPILED_THROW_INTEGRATION
+        } else if (PyCoro_CheckExact(generator->m_yieldfrom)) {
+            PyGenObject *gen = (PyGenObject *)generator->m_yieldfrom;
+
+            // Transferred exception ownership to "Nuitka_UncompiledGenerator_throw".
+            generator->m_running = 1;
+            ret = Nuitka_UncompiledGenerator_throw(gen, 1, exception_type, exception_value, exception_tb);
+            generator->m_running = 0;
+#endif
+#if PYTHON_VERSION >= 0x360
+        } else if (Nuitka_AsyncgenAsend_Check(generator->m_yieldfrom)) {
+            struct Nuitka_AsyncgenAsendObject *asyncgen_asend =
+                ((struct Nuitka_AsyncgenAsendObject *)generator->m_yieldfrom);
+
+            // Transferred exception ownership to "_Nuitka_AsyncgenAsend_throw2".
+            generator->m_running = 1;
+            ret = _Nuitka_AsyncgenAsend_throw2(asyncgen_asend, exception_type, exception_value, exception_tb);
+            generator->m_running = 0;
+#endif
+#endif
+        } else {
+            PyObject *meth = PyObject_GetAttr(generator->m_yieldfrom, const_str_plain_throw);
+            if (unlikely(meth == NULL)) {
+                if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
+                    // Release exception, we are done with it now.
+                    Py_DECREF(exception_type);
+                    Py_XDECREF(exception_value);
+                    Py_XDECREF(exception_tb);
+
+                    return NULL;
+                }
+
+                CLEAR_ERROR_OCCURRED();
+
+                // Passing exception ownership to that code.
+                goto throw_here;
+            }
+
+            CHECK_OBJECT(exception_type);
+
+#if 0
+            // TODO: Add slow mode traces.
+            PRINT_ITEM(coroutine->m_yieldfrom);
+            PRINT_NEW_LINE();
+#endif
+            generator->m_running = 1;
+            ret = PyObject_CallFunctionObjArgs(meth, exception_type, exception_value, exception_tb, NULL);
+            generator->m_running = 0;
+
+            Py_DECREF(meth);
+
+            // Release exception, we are done with it now.
+            Py_DECREF(exception_type);
+            Py_XDECREF(exception_value);
+            Py_XDECREF(exception_tb);
+        }
+
+        if (unlikely(ret == NULL)) {
+            // Return value or exception, not to continue with yielding from.
+            if (generator->m_yieldfrom != NULL) {
+                CHECK_OBJECT(generator->m_yieldfrom);
+#if _DEBUG_GENERATOR
+                PRINT_GENERATOR_STATUS("Null return, yield from removal:", generator);
+                PRINT_COROUTINE_VALUE("yieldfrom", generator->m_yieldfrom);
+#endif
+                Py_DECREF(generator->m_yieldfrom);
+                generator->m_yieldfrom = NULL;
+            }
+
+            PyObject *val;
+            if (_PyGen_FetchStopIterationValue(&val) == 0) {
+                CHECK_OBJECT(val);
+
+#if _DEBUG_GENERATOR
+                PRINT_GENERATOR_STATUS("Sending return value into ourselves", generator);
+                PRINT_COROUTINE_VALUE("value", val);
+                PRINT_NEW_LINE();
+#endif
+
+                ret = _Nuitka_Generator_send(generator, val, NULL, NULL, NULL);
+            } else {
+#if _DEBUG_GENERATOR
+                PRINT_GENERATOR_STATUS("Sending exception value into ourselves", generator);
+                PRINT_CURRENT_EXCEPTION();
+                PRINT_NEW_LINE();
+#endif
+                ret = _Nuitka_Generator_send(generator, NULL, NULL, NULL, NULL);
+            }
+
+#if _DEBUG_GENERATOR
+            PRINT_GENERATOR_STATUS("Leave with value/exception from sending into ourselves:", generator);
+            PRINT_COROUTINE_VALUE("return_value", ret);
+            PRINT_CURRENT_EXCEPTION();
+            PRINT_NEW_LINE();
+#endif
+        } else {
+#if _DEBUG_GENERATOR
+            PRINT_GENERATOR_STATUS("Leave with return value:", generator);
+            PRINT_COROUTINE_VALUE("return_value", ret);
+            PRINT_CURRENT_EXCEPTION();
+            PRINT_NEW_LINE();
+#endif
+        }
+
+        return ret;
+    }
+
+throw_here:
+#endif
+
+    // We continue to have exception ownership here.
+
+    if (unlikely(_Nuitka_Generator_check_throw2(&exception_type, &exception_value, &exception_tb) == false)) {
+        // Exception was released by _Nuitka_Generator_check_throw2 already.
+        return NULL;
+    }
+
+    if (generator->m_status == status_Running) {
+        // Passing exception ownership to _Nuitka_Generator_send
+        PyObject *result = _Nuitka_Generator_send(generator, NULL, exception_type, exception_value, exception_tb);
+
+        if (result == NULL) {
+            if (GET_ERROR_OCCURRED() == NULL) {
+                SET_CURRENT_EXCEPTION_TYPE0(PyExc_StopIteration);
+            }
+        }
+
+        return result;
+    } else if (generator->m_status == status_Finished) {
+        RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+        return NULL;
+    } else {
+        if (exception_tb == NULL) {
+            // TODO: Our compiled objects really need a way to store common
+            // stuff in a "shared" part across all instances, and outside of
+            // run time, so we could reuse this.
+            struct Nuitka_FrameObject *frame = MAKE_FUNCTION_FRAME(generator->m_code_object, generator->m_module, 0);
+            exception_tb = MAKE_TRACEBACK(frame, generator->m_code_object->co_firstlineno);
+            Py_DECREF(frame);
+        }
+
+        RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
+
+        generator->m_status = status_Finished;
+
+        return NULL;
+    }
+}
+
+static PyObject *Nuitka_Generator_throw(struct Nuitka_GeneratorObject *generator, PyObject *args) {
+    PyObject *exception_type;
+    PyObject *exception_value = NULL;
+    PyTracebackObject *exception_tb = NULL;
+
+    // This takes no references, that is for us to do.
+    int res = PyArg_UnpackTuple(args, "throw", 1, 3, &exception_type, &exception_value, &exception_tb);
+
+    if (unlikely(res == 0)) {
+        return NULL;
+    }
+
+    // Handing ownership of exception over, we need not release it ourselves
+    Py_INCREF(exception_type);
+    Py_XINCREF(exception_value);
+    Py_XINCREF(exception_tb);
+
+    PyObject *result = _Nuitka_Generator_throw2(generator, exception_type, exception_value, exception_tb);
+
+    if (result == NULL) {
+        if (GET_ERROR_OCCURRED() == NULL) {
+            SET_CURRENT_EXCEPTION_TYPE0(PyExc_StopIteration);
+        }
+    }
+
+#if _DEBUG_GENERATOR
+    PRINT_GENERATOR_STATUS("Leave", generator);
+    PRINT_EXCEPTION(exception_type, exception_value, exception_tb);
+    PRINT_COROUTINE_VALUE("return value", result);
+    PRINT_CURRENT_EXCEPTION();
+#endif
+
+    return result;
+}
+
+#if PYTHON_VERSION >= 0x340
+static void Nuitka_Generator_tp_finalizer(struct Nuitka_GeneratorObject *generator) {
+    if (generator->m_status != status_Running) {
+        return;
+    }
+
+    PyObject *save_exception_type, *save_exception_value;
+    PyTracebackObject *save_exception_tb;
+    FETCH_ERROR_OCCURRED(&save_exception_type, &save_exception_value, &save_exception_tb);
+
+    bool close_result = _Nuitka_Generator_close(generator);
+
+    if (unlikely(close_result == false)) {
+        PyErr_WriteUnraisable((PyObject *)generator);
+    }
+
+    /* Restore the saved exception if any. */
+    RESTORE_ERROR_OCCURRED(save_exception_type, save_exception_value, save_exception_tb);
+}
+#endif
+
+#define MAX_GENERATOR_FREE_LIST_COUNT 100
+static struct Nuitka_GeneratorObject *free_list_generators = NULL;
+static int free_list_generators_count = 0;
+
+static void Nuitka_Generator_tp_dealloc(struct Nuitka_GeneratorObject *generator) {
+    // Revive temporarily.
+    assert(Py_REFCNT(generator) == 0);
+    Py_SET_REFCNT(generator, 1);
+
+    // Save the current exception, if any, we must preserve it.
+    PyObject *save_exception_type, *save_exception_value;
+    PyTracebackObject *save_exception_tb;
+    FETCH_ERROR_OCCURRED(&save_exception_type, &save_exception_value, &save_exception_tb);
+
+    if (generator->m_status == status_Running) {
+        bool close_result = _Nuitka_Generator_close(generator);
+        CHECK_OBJECT(generator);
+
+        if (unlikely(close_result == false)) {
+            PyErr_WriteUnraisable((PyObject *)generator);
+        }
+    }
+
+    Nuitka_Generator_release_closure(generator);
+
+    // Allow for above code to resurrect the generator.
+    Py_SET_REFCNT(generator, Py_REFCNT(generator) - 1);
+    if (Py_REFCNT(generator) >= 1) {
+        return;
+    }
+
+    if (generator->m_frame != NULL) {
+#if PYTHON_VERSION >= 0x340
+        Nuitka_SetFrameGenerator(generator->m_frame, NULL);
+#endif
+        Py_DECREF(generator->m_frame);
+        generator->m_frame = NULL;
+    }
+
+    // Now it is safe to release references and memory for it.
+    Nuitka_GC_UnTrack(generator);
+
+    if (generator->m_weakrefs != NULL) {
+        PyObject_ClearWeakRefs((PyObject *)generator);
+        assert(!ERROR_OCCURRED());
+    }
+
+    Py_DECREF(generator->m_name);
+
+#if PYTHON_VERSION >= 0x350
+    Py_DECREF(generator->m_qualname);
+#endif
+
+    /* Put the object into free list or release to GC */
+    releaseToFreeList(free_list_generators, generator, MAX_GENERATOR_FREE_LIST_COUNT);
+
+    RESTORE_ERROR_OCCURRED(save_exception_type, save_exception_value, save_exception_tb);
+}
+
+static long Nuitka_Generator_tp_hash(struct Nuitka_GeneratorObject *generator) { return generator->m_counter; }
+
+static PyObject *Nuitka_Generator_get_name(struct Nuitka_GeneratorObject *generator) {
+    PyObject *result = generator->m_name;
+    Py_INCREF(result);
+    return result;
+}
+
+#if PYTHON_VERSION >= 0x350
+static int Nuitka_Generator_set_name(struct Nuitka_GeneratorObject *generator, PyObject *value) {
+    // Cannot be deleted, not be non-unicode value.
+    if (unlikely((value == NULL) || !PyUnicode_Check(value))) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "__name__ must be set to a string object");
+
+        return -1;
+    }
+
+    PyObject *tmp = generator->m_name;
+    Py_INCREF(value);
+    generator->m_name = value;
+    Py_DECREF(tmp);
+
+    return 0;
+}
+
+static PyObject *Nuitka_Generator_get_qualname(struct Nuitka_GeneratorObject *generator) {
+    PyObject *result = generator->m_qualname;
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Generator_set_qualname(struct Nuitka_GeneratorObject *generator, PyObject *value) {
+    // Cannot be deleted, not be non-unicode value.
+    if (unlikely((value == NULL) || !PyUnicode_Check(value))) {
+        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "__qualname__ must be set to a string object");
+
+        return -1;
+    }
+
+    PyObject *tmp = generator->m_qualname;
+    Py_INCREF(value);
+    generator->m_qualname = value;
+    Py_DECREF(tmp);
+
+    return 0;
+}
+
+static PyObject *Nuitka_Generator_get_yieldfrom(struct Nuitka_GeneratorObject *generator) {
+    if (generator->m_yieldfrom) {
+        Py_INCREF(generator->m_yieldfrom);
+        return generator->m_yieldfrom;
+    } else {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+}
+
+#endif
+
+static PyObject *Nuitka_Generator_get_code(struct Nuitka_GeneratorObject *generator) {
+    PyObject *result = (PyObject *)generator->m_code_object;
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Generator_set_code(struct Nuitka_GeneratorObject *generator, PyObject *value) {
+    SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_RuntimeError, "gi_code is not writable in Nuitka");
+    return -1;
+}
+
+static PyObject *Nuitka_Generator_get_frame(struct Nuitka_GeneratorObject *generator) {
+    PyObject *result;
+
+    if (generator->m_frame) {
+        result = (PyObject *)generator->m_frame;
+    } else {
+        result = Py_None;
+    }
+
+    Py_INCREF(result);
+    return result;
+}
+
+static int Nuitka_Generator_set_frame(struct Nuitka_GeneratorObject *generator, PyObject *value) {
+    SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_RuntimeError, "gi_frame is not writable in Nuitka");
+    return -1;
+}
+
+static PyObject *Nuitka_Generator_get_running(struct Nuitka_GeneratorObject *generator) {
+    PyObject *result;
+
+/* The type of "gi_running" changed in Python3. */
+#if PYTHON_VERSION < 0x300
+    result = PyInt_FromLong(generator->m_running);
+#else
+    result = BOOL_FROM(generator->m_running != 0);
+    Py_INCREF(result);
+#endif
+    return result;
+}
+
+static int Nuitka_Generator_set_running(struct Nuitka_GeneratorObject *generator, PyObject *value) {
+#if PYTHON_VERSION < 0x300
+    PyObject *exception_type = PyExc_TypeError;
+#else
+    PyObject *exception_type = PyExc_AttributeError;
+#endif
+
+#if !defined(_NUITKA_FULL_COMPAT) || PYTHON_VERSION >= 0x3a0
+    SET_CURRENT_EXCEPTION_TYPE0_STR(exception_type, "attribute 'gi_running' of 'generator' objects is not writable");
+#else
+    SET_CURRENT_EXCEPTION_TYPE0_STR(exception_type, "readonly attribute");
+#endif
+
+    return -1;
+}
+
+static PyGetSetDef Nuitka_Generator_getsetlist[] = {
+#if PYTHON_VERSION < 0x350
+    {(char *)"__name__", (getter)Nuitka_Generator_get_name, NULL, NULL},
+#else
+    {(char *)"__name__", (getter)Nuitka_Generator_get_name, (setter)Nuitka_Generator_set_name, NULL},
+    {(char *)"__qualname__", (getter)Nuitka_Generator_get_qualname, (setter)Nuitka_Generator_set_qualname, NULL},
+    {(char *)"gi_yieldfrom", (getter)Nuitka_Generator_get_yieldfrom, NULL, NULL},
+#endif
+    {(char *)"gi_code", (getter)Nuitka_Generator_get_code, (setter)Nuitka_Generator_set_code, NULL},
+    {(char *)"gi_frame", (getter)Nuitka_Generator_get_frame, (setter)Nuitka_Generator_set_frame, NULL},
+    {(char *)"gi_running", (getter)Nuitka_Generator_get_running, (setter)Nuitka_Generator_set_running, NULL},
+
+    {NULL}};
+
+static PyMethodDef Nuitka_Generator_methods[] = {{"send", (PyCFunction)Nuitka_Generator_send, METH_O, NULL},
+                                                 {"throw", (PyCFunction)Nuitka_Generator_throw, METH_VARARGS, NULL},
+                                                 {"close", (PyCFunction)Nuitka_Generator_close, METH_NOARGS, NULL},
+                                                 {NULL}};
+
+// This is only used.
+#if PYTHON_VERSION >= 0x3a0
+static PyAsyncMethods Nuitka_Generator_as_async = {
+    NULL, /* am_await */
+    NULL, /* am_aiter */
+    NULL, /* am_anext */
+    NULL  // TODO: have this too, (sendfunc)_Nuitka_Generator_amsend /* am_anext */
+};
+#endif
+
+#include <structmember.h>
+
+PyTypeObject Nuitka_Generator_Type = {
+    PyVarObject_HEAD_INIT(NULL, 0) "compiled_generator", /* tp_name */
+    sizeof(struct Nuitka_GeneratorObject),               /* tp_basicsize */
+    sizeof(struct Nuitka_CellObject *),                  /* tp_itemsize */
+    (destructor)Nuitka_Generator_tp_dealloc,             /* tp_dealloc */
+    0,                                                   /* tp_print */
+    0,                                                   /* tp_getattr */
+    0,                                                   /* tp_setattr */
+#if PYTHON_VERSION < 0x3a0
+    0, /* tp_as_async */
+#else
+    &Nuitka_Generator_as_async, /* tp_as_async */
+#endif
+    (reprfunc)Nuitka_Generator_tp_repr, /* tp_repr */
+    0,                                  /* tp_as_number */
+    0,                                  /* tp_as_sequence */
+    0,                                  /* tp_as_mapping */
+    (hashfunc)Nuitka_Generator_tp_hash, /* tp_hash */
+    0,                                  /* tp_call */
+    0,                                  /* tp_str */
+    PyObject_GenericGetAttr,            /* tp_getattro */
+    0,                                  /* tp_setattro */
+    0,                                  /* tp_as_buffer */
+#if PYTHON_VERSION < 0x340
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
+#else
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
+#endif
+    /* tp_flags */
+    0,                                                   /* tp_doc */
+    (traverseproc)Nuitka_Generator_tp_traverse,          /* tp_traverse */
+    0,                                                   /* tp_clear */
+    0,                                                   /* tp_richcompare */
+    offsetof(struct Nuitka_GeneratorObject, m_weakrefs), /* tp_weaklistoffset */
+    PyObject_SelfIter,                                   /* tp_iter */
+    (iternextfunc)Nuitka_Generator_tp_iternext,          /* tp_iternext */
+    Nuitka_Generator_methods,                            /* tp_methods */
+    NULL,                                                /* tp_members */
+    Nuitka_Generator_getsetlist,                         /* tp_getset */
+    0,                                                   /* tp_base */
+    0,                                                   /* tp_dict */
+    0,                                                   /* tp_descr_get */
+    0,                                                   /* tp_descr_set */
+    0,                                                   /* tp_dictoffset */
+    0,                                                   /* tp_init */
+    0,                                                   /* tp_alloc */
+    0,                                                   /* tp_new */
+    0,                                                   /* tp_free */
+    0,                                                   /* tp_is_gc */
+    0,                                                   /* tp_bases */
+    0,                                                   /* tp_mro */
+    0,                                                   /* tp_cache */
+    0,                                                   /* tp_subclasses */
+    0,                                                   /* tp_weaklist */
+    0,                                                   /* tp_del */
+    0                                                    /* tp_version_tag */
+#if PYTHON_VERSION >= 0x340
+    ,
+    (destructor)Nuitka_Generator_tp_finalizer /* tp_finalize */
+#endif
+};
+
+#if PYTHON_VERSION >= 0x350
+static void _initCompiledCoroutineTypes();
+#endif
+#if PYTHON_VERSION >= 0x360
+static void _initCompiledAsyncgenTypes();
+#endif
+
+void _initCompiledGeneratorType(void) {
+    Nuitka_Generator_Type.tp_base = &PyGen_Type;
+
+    PyType_Ready(&Nuitka_Generator_Type);
+
+    // Be a paranoid subtype of uncompiled function, we want nothing shared.
+    assert(Nuitka_Generator_Type.tp_doc != PyGen_Type.tp_doc || PyGen_Type.tp_doc == NULL);
+    assert(Nuitka_Generator_Type.tp_traverse != PyGen_Type.tp_traverse);
+    assert(Nuitka_Generator_Type.tp_clear != PyGen_Type.tp_clear || PyGen_Type.tp_clear == NULL);
+    assert(Nuitka_Generator_Type.tp_richcompare != PyGen_Type.tp_richcompare || PyGen_Type.tp_richcompare == NULL);
+    assert(Nuitka_Generator_Type.tp_iter != PyGen_Type.tp_iter || PyGen_Type.tp_iter == PyObject_SelfIter);
+    assert(Nuitka_Generator_Type.tp_iternext != PyGen_Type.tp_iternext || PyGen_Type.tp_iternext == NULL);
+#if PYTHON_VERSION >= 0x350
+    assert(Nuitka_Generator_Type.tp_as_async != PyGen_Type.tp_as_async || PyGen_Type.tp_as_async == NULL);
+#endif
+    assert(Nuitka_Generator_Type.tp_methods != PyGen_Type.tp_methods);
+    assert(Nuitka_Generator_Type.tp_members != PyGen_Type.tp_members);
+    assert(Nuitka_Generator_Type.tp_getset != PyGen_Type.tp_getset);
+    assert(Nuitka_Generator_Type.tp_base != PyGen_Type.tp_base);
+    assert(Nuitka_Generator_Type.tp_dict != PyGen_Type.tp_dict);
+    assert(Nuitka_Generator_Type.tp_descr_get != PyGen_Type.tp_descr_get || PyGen_Type.tp_descr_get == NULL);
+
+    assert(Nuitka_Generator_Type.tp_descr_set != PyGen_Type.tp_descr_set || PyGen_Type.tp_descr_set == NULL);
+    assert(Nuitka_Generator_Type.tp_dictoffset != PyGen_Type.tp_dictoffset || PyGen_Type.tp_dictoffset == 0);
+    // TODO: These get changed and into the same thing, not sure what to compare against, project something
+    // assert(Nuitka_Generator_Type.tp_init != PyGen_Type.tp_init || PyGen_Type.tp_init == NULL);
+    // assert(Nuitka_Generator_Type.tp_alloc != PyGen_Type.tp_alloc || PyGen_Type.tp_alloc == NULL);
+    // assert(Nuitka_Generator_Type.tp_new != PyGen_Type.tp_new || PyGen_Type.tp_new == NULL);
+    // assert(Nuitka_Generator_Type.tp_free != PyGen_Type.tp_free || PyGen_Type.tp_free == NULL);
+    assert(Nuitka_Generator_Type.tp_bases != PyGen_Type.tp_bases);
+    assert(Nuitka_Generator_Type.tp_mro != PyGen_Type.tp_mro);
+    assert(Nuitka_Generator_Type.tp_cache != PyGen_Type.tp_cache || PyGen_Type.tp_cache == NULL);
+    assert(Nuitka_Generator_Type.tp_subclasses != PyGen_Type.tp_subclasses || PyGen_Type.tp_cache == NULL);
+    assert(Nuitka_Generator_Type.tp_weaklist != PyGen_Type.tp_weaklist);
+    assert(Nuitka_Generator_Type.tp_del != PyGen_Type.tp_del || PyGen_Type.tp_del == NULL);
+#if PYTHON_VERSION >= 0x340
+    assert(Nuitka_Generator_Type.tp_finalize != PyGen_Type.tp_finalize || PyGen_Type.tp_finalize == NULL);
+#endif
+
+#if PYTHON_VERSION >= 0x350
+    // Also initialize coroutines if necessary
+    _initCompiledCoroutineTypes();
+#endif
+
+#if PYTHON_VERSION >= 0x360
+    // Also initialize asyncgen if necessary
+    _initCompiledAsyncgenTypes();
+#endif
+}
+
+PyObject *Nuitka_Generator_New(generator_code code, PyObject *module, PyObject *name,
+#if PYTHON_VERSION >= 0x350
+                               PyObject *qualname,
+#endif
+                               PyCodeObject *code_object, struct Nuitka_CellObject **closure, Py_ssize_t closure_given,
+                               Py_ssize_t heap_storage_size) {
+    struct Nuitka_GeneratorObject *result;
+
+    // TODO: Change the var part of the type to 1 maybe
+    Py_ssize_t full_size = closure_given + (heap_storage_size + sizeof(void *) - 1) / sizeof(void *);
+
+    // Macro to assign result memory from GC or free list.
+    allocateFromFreeList(free_list_generators, struct Nuitka_GeneratorObject, Nuitka_Generator_Type, full_size);
+
+    // For quicker access of generator heap.
+    result->m_heap_storage = &result->m_closure[closure_given];
+
+    assert(result != NULL);
+    CHECK_OBJECT(result);
+
+    assert(Py_SIZE(result) >= closure_given);
+
+    result->m_code = (void *)code;
+
+    CHECK_OBJECT(module);
+    result->m_module = module;
+
+    CHECK_OBJECT(name);
+    result->m_name = name;
+    Py_INCREF(name);
+
+#if PYTHON_VERSION >= 0x350
+    // The "qualname" defaults to NULL for most compact C code.
+    if (qualname == NULL) {
+        qualname = name;
+    }
+    CHECK_OBJECT(qualname);
+
+    result->m_qualname = qualname;
+    Py_INCREF(qualname);
+#endif
+
+#if PYTHON_VERSION >= 0x300
+    result->m_yieldfrom = NULL;
+#endif
+
+    memcpy(&result->m_closure[0], closure, closure_given * sizeof(struct Nuitka_CellObject *));
+    result->m_closure_given = closure_given;
+
+    result->m_weakrefs = NULL;
+
+    result->m_status = status_Unused;
+    result->m_running = false;
+
+    result->m_yield_return_index = 0;
+
+#if PYTHON_VERSION >= 0x300
+    result->m_returned = NULL;
+#endif
+
+    result->m_frame = NULL;
+    result->m_code_object = code_object;
+
+#if PYTHON_VERSION >= 0x370
+    result->m_exc_state = Nuitka_ExceptionStackItem_Empty;
+#endif
+
+    static long Nuitka_Generator_counter = 0;
+    result->m_counter = Nuitka_Generator_counter++;
+
+    Nuitka_GC_Track(result);
+    return (PyObject *)result;
+}
+
+static PyObject *_EMPTY_GENERATOR_CONTEXT(struct Nuitka_GeneratorObject *generator, PyObject *yield_return_value) {
+    return NULL;
+}
+
+PyObject *Nuitka_Generator_NewEmpty(PyObject *module, PyObject *name,
+#if PYTHON_VERSION >= 0x350
+                                    PyObject *qualname,
+#endif
+                                    PyCodeObject *code_object, struct Nuitka_CellObject **closure,
+                                    Py_ssize_t closure_given) {
+    return Nuitka_Generator_New(_EMPTY_GENERATOR_CONTEXT, module, name,
+#if PYTHON_VERSION >= 0x350
+                                qualname,
+#endif
+                                code_object, closure, closure_given, 0);
+}
+
+// Chain coroutine code to generator code, as it uses same functions, and then we can
+// have some things static if both are in the same compilation unit. This also loads
+// the asyncgen for 3.6 and higher.
+#if PYTHON_VERSION >= 0x350
+#include "CompiledCoroutineType.c"
+#endif
+
+// Chain frames to generator and asyncgen code, as they need to close them with access
+// to best functions.
+#include "CompiledFrameType.c"
\ No newline at end of file
Index: lab15/Lab_15/task_1.build/@link_input.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/@link_input.txt b/lab15/Lab_15/task_1.build/@link_input.txt
new file mode 100644
--- /dev/null	(date 1673971998616)
+++ b/lab15/Lab_15/task_1.build/@link_input.txt	(date 1673971998616)
@@ -0,0 +1,10 @@
+"./__constants.o"
+"./__constants_data.o"
+"./__helpers.o"
+"./__loader.o"
+"./module.__main__.o"
+"./static_src/MainProgram.o"
+"./static_src/CompiledCellType.o"
+"./static_src/CompiledFunctionType.o"
+"./static_src/CompiledGeneratorType.o"
+"./static_src/InspectPatcher.o"
Index: lab15/Lab_15/task_1.build/__constants.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lab15/Lab_15/task_1.build/__constants.c b/lab15/Lab_15/task_1.build/__constants.c
new file mode 100644
--- /dev/null	(date 1673971998336)
+++ b/lab15/Lab_15/task_1.build/__constants.c	(date 1673971998336)
@@ -0,0 +1,145 @@
+
+#include "nuitka/prelude.h"
+#include "structseq.h"
+
+// Global constants storage
+PyObject *global_constants[79];
+
+// Sentinel PyObject to be used for all our call iterator endings. It will
+// become a PyCObject pointing to NULL. It's address is unique, and that's
+// enough for us to use it as sentinel value.
+PyObject *_sentinel_value = NULL;
+
+PyObject *Nuitka_dunder_compiled_value = NULL;
+
+
+#ifdef _NUITKA_STANDALONE
+extern PyObject *getStandaloneSysExecutablePath(PyObject *basename);
+#endif
+
+// We provide the sys.version info shortcut as a global value here for ease of use.
+PyObject *Py_SysVersionInfo = NULL;
+
+static void _createGlobalConstants(void) {
+    // We provide the sys.version info shortcut as a global value here for ease of use.
+    Py_SysVersionInfo = Nuitka_SysGetObject("version_info");
+
+    // The empty name means global.
+    loadConstantsBlob(&global_constants[0], "");
+
+#if _NUITKA_EXE
+    /* Set the "sys.executable" path to the original CPython executable or point to inside the
+       distribution for standalone. */
+    Nuitka_SysSetObject(
+        "executable",
+#ifndef _NUITKA_STANDALONE
+        global_constants[77]
+#else
+        getStandaloneSysExecutablePath(global_constants[77])
+#endif
+    );
+
+#ifndef _NUITKA_STANDALONE
+    /* Set the "sys.prefix" path to the original one. */
+    Nuitka_SysSetObject(
+        "prefix",
+        global_constants[78]
+    );
+
+    /* Set the "sys.prefix" path to the original one. */
+    Nuitka_SysSetObject(
+        "exec_prefix",
+        global_constants[78]
+    );
+
+
+#if PYTHON_VERSION >= 0x300
+    /* Set the "sys.base_prefix" path to the original one. */
+    Nuitka_SysSetObject(
+        "base_prefix",
+        global_constants[78]
+    );
+
+    /* Set the "sys.exec_base_prefix" path to the original one. */
+    Nuitka_SysSetObject(
+        "base_exec_prefix",
+        global_constants[78]
+    );
+
+#endif
+#endif
+#endif
+
+    static PyTypeObject Nuitka_VersionInfoType;
+
+    // Same fields as "sys.version_info" except no serial number.
+    static PyStructSequence_Field Nuitka_VersionInfoFields[] = {
+        {(char *)"major", (char *)"Major release number"},
+        {(char *)"minor", (char *)"Minor release number"},
+        {(char *)"micro", (char *)"Micro release number"},
+        {(char *)"releaselevel", (char *)"'alpha', 'beta', 'candidate', or 'release'"},
+        {(char *)"standalone", (char *)"boolean indicating standalone mode usage"},
+        {(char *)"onefile", (char *)"boolean indicating standalone mode usage"},
+        {0}
+    };
+
+    static PyStructSequence_Desc Nuitka_VersionInfoDesc = {
+        (char *)"__nuitka_version__",                                    /* name */
+        (char *)"__compiled__\\n\\nVersion information as a named tuple.", /* doc */
+        Nuitka_VersionInfoFields,                                        /* fields */
+        6
+    };
+
+    PyStructSequence_InitType(&Nuitka_VersionInfoType, &Nuitka_VersionInfoDesc);
+
+    Nuitka_dunder_compiled_value = PyStructSequence_New(&Nuitka_VersionInfoType);
+    assert(Nuitka_dunder_compiled_value != NULL);
+
+    PyStructSequence_SET_ITEM(Nuitka_dunder_compiled_value, 0, PyInt_FromLong(1));
+    PyStructSequence_SET_ITEM(Nuitka_dunder_compiled_value, 1, PyInt_FromLong(3));
+    PyStructSequence_SET_ITEM(Nuitka_dunder_compiled_value, 2, PyInt_FromLong(8));
+
+    PyStructSequence_SET_ITEM(Nuitka_dunder_compiled_value, 3, Nuitka_String_FromString("release"));
+
+#ifdef _NUITKA_STANDALONE
+    PyObject *is_standalone_mode = Py_True;
+#else
+    PyObject *is_standalone_mode = Py_False;
+#endif
+#ifdef _NUITKA_ONEFILE_MODE
+    PyObject *is_onefile_mode = Py_True;
+#else
+    PyObject *is_onefile_mode = Py_False;
+#endif
+
+    PyStructSequence_SET_ITEM(Nuitka_dunder_compiled_value, 4, is_standalone_mode);
+    PyStructSequence_SET_ITEM(Nuitka_dunder_compiled_value, 5, is_onefile_mode);
+
+    // Prevent users from creating the Nuitka version type object.
+    Nuitka_VersionInfoType.tp_init = NULL;
+    Nuitka_VersionInfoType.tp_new = NULL;
+}
+
+// In debug mode we can check that the constants were not tampered with in any
+// given moment. We typically do it at program exit, but we can add extra calls
+// for sanity.
+#ifndef __NUITKA_NO_ASSERT__
+void checkGlobalConstants(void) {
+// TODO: Ask constant code to check values.
+
+}
+#endif
+
+void createGlobalConstants(void) {
+    if (_sentinel_value == NULL) {
+#if PYTHON_VERSION < 0x300
+        _sentinel_value = PyCObject_FromVoidPtr(NULL, NULL);
+#else
+        // The NULL value is not allowed for a capsule, so use something else.
+        _sentinel_value = PyCapsule_New((void *)27, "sentinel", NULL);
+#endif
+        assert(_sentinel_value);
+
+        _createGlobalConstants();
+    }
+}
diff --git a/lab15/Lab_15/task_1.build/__bytecode.const b/lab15/Lab_15/task_1.build/__bytecode.const
new file mode 100644
diff --git a/lab15/Lab_15/task_1.build/.sconsign-310.dblite b/lab15/Lab_15/task_1.build/.sconsign-310.dblite
new file mode 100644

### Разбор алгоритма IDEA на простом примере

**Исходные данные:**
- Блок данных: `0x123456789ABCDEF0` (64 бита)
- Ключ: `0x2BD6459F82C5B300952C49104881FF48` (128 бит)

### **1. Генерация ключей**
Из ключа длиной 128 бит создаются 52 под-ключа по 16 бит:
- Первые 8 под-ключей берутся напрямую из ключа.
- Оставшиеся вычисляются путем циклического сдвига ключа и деления на 16-битные блоки.

Пример:
```
Ключ: 2BD6 459F 82C5 B300 952C 4910 4881 FF48
Ключи раундов: 
Раунд 1: 2BD6 459F 82C5 B300 952C 4910
Раунд 2: 4881 FF48 6D3E 67BC 9182 5DA6
...
```

### **2. Разделение данных**
64-битный блок делится на четыре 16-битных подблока:
```
P1 = 0x1234, P2 = 0x5678, P3 = 0x9ABC, P4 = 0xDEF0
```

### **3. Раунды (8 итераций)**  
В каждом раунде применяются 6 ключей и выполняются основные операции:

#### *Шаги в каждом раунде:*
1. **Мультипликативное умножение по модулю 0x10001** (65537)  
   - `P1 = P1 * K1 mod 65537`
   - `P4 = P4 * K4 mod 65537`
  
2. **Аддитивное сложение по модулю 0x10000** (65536)  
   - `P2 = (P2 + K2) mod 65536`
   - `P3 = (P3 + K3) mod 65536`

3. **XOR (исключающее ИЛИ) между частями данных**  
   - `X1 = P1 ⊕ P3`
   - `X2 = P2 ⊕ P4`

4. **Мультипликативное умножение X1 с K5**  
   - `X3 = X1 * K5 mod 65537`

5. **Аддитивное сложение X2 и X3, умножение результата с K6**  
   - `X4 = (X3 + X2) mod 65536`
   - `X5 = X4 * K6 mod 65537`

6. **Перестановка частей данных для следующего раунда**  
   - `P1 = P1 ⊕ X5`
   - `P4 = P4 ⊕ X3`
   - `P2 = P3 ⊕ X5`
   - `P3 = P2 ⊕ X3`

Пример для первого раунда:
```
P1 = 0x1234 * 0x2BD6 mod 65537 = 0x1A2F
P4 = 0xDEF0 * 0xB300 mod 65537 = 0x3C4D
P2 = (0x5678 + 0x459F) mod 65536 = 0x9C17
P3 = (0x9ABC + 0x82C5) mod 65536 = 0x1D81
...
```

### **4. Финальная трансформация**
После 8 раундов последние 4 части данных преобразуются с помощью оставшихся ключей, получая 64-битный зашифрованный блок.

### **5. Дешифрование**
Процесс аналогичен, но ключи используются в обратном порядке, и операции заменяются на обратные:
- Сложение заменяется на вычитание.
- Умножение заменяется на мультипликативное обратное.
- XOR остается без изменений.

### **Вывод**
Алгоритм IDEA использует комбинацию:
- **Мультипликативного умножения** (работает как нелинейная операция)
- **Аддитивного сложения** (простая линейная операция)
- **XOR** (перемешивает данные)

Такая схема делает алгоритм устойчивым к атаке дифференциального и линейного криптоанализа, что делает его надежным для защиты данных.

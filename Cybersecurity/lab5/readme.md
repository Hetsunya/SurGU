Алгоритм **SHA-256** из семейства **SHA-2** выполняет несколько важных шагов для того, чтобы получить хэш фиксированной длины (256 бит) для произвольного входного сообщения. Давай разберем процесс пошагово.

### 1. **Дополнение сообщения (Padding)**:
   В начале алгоритм добавляет дополнительные биты к сообщению, чтобы его длина стала кратной 512 битам. Алгоритм делает следующее:
   
   - **Добавление 1 бита**: В конце сообщения добавляется единица (`0x80` в шестнадцатеричной системе). Это сигнализирует, что далее будут идти дополнения.
   - **Добавление нулей**: После единицы добавляется столько нулей, чтобы длина сообщения стала равной 64 битам меньше от длины, кратной 512.
   - **Добавление длины исходного сообщения**: В конце добавляется 64-битная репрезентация длины исходного сообщения в битах. Это нужно для предотвращения атак на основе коллизий.

   Таким образом, на выходе получается, что длина сообщения станет кратной 512 битам.

### 2. **Разбиение на блоки (Message Blocks)**:
   После дополнения сообщение разбивается на блоки по 512 бит. Каждый такой блок будет обрабатываться отдельно в ходе алгоритма.

### 3. **Инициализация хэш-значений (Initial Hash Values)**:
   SHA-256 использует 8 хэш-значений, которые задаются константами. Эти значения используются в процессе вычисления хэша.

   Константы (h0, h1, ..., h7) задаются заранее:
   ```
   h0 = 0x6a09e667
   h1 = 0xbb67ae85
   h2 = 0x3c6ef372
   h3 = 0xa54ff53a
   h4 = 0x510e527f
   h5 = 0x9b05688c
   h6 = 0x1f83d9ab
   h7 = 0x5be0cd19
   ```

### 4. **Обработка каждого блока (Block Processing)**:
   Каждый 512-битный блок обрабатывается с использованием 64 раундов. В каждом раунде выполняются следующие шаги:

   - **Подготовка слов (Words)**: Блок разбивается на 16 слов по 32 бита. Дополнительно вычисляются ещё 48 слов с помощью специфических операций (сдвигов и побитовых операций).
   
   - **Инициализация временных значений**: В начале каждого раунда используются промежуточные значения хэша (a, b, c, d, e, f, g, h), которые инициализируются значениями (h0, h1, ..., h7).
   
   - **Вычисления на каждом раунде**: Для каждого раунда происходит вычисление нового значения для временных переменных. Это включает в себя несколько шагов:
     - Операции сдвигов (например, сдвиг вправо) и логических операций (XOR, AND).
     - Обновление временных значений с учетом текущего значения блока и констант для каждого раунда.
   
   Алгоритм работает с логическими операциями, такими как побитовые сдвиги и побитовые И/ИЛИ/ИСКЛЮЧАЮЩИЕ ИЛИ. Эти операции создают множество комбинаций значений, что делает хэширование устойчивым к попыткам взлома.

### 5. **Обновление хэш-значений (Updating Hash Values)**:
   После обработки каждого блока обновляются хэш-значения (h0, h1, ..., h7). Эти обновления происходят на основе промежуточных значений, которые были вычислены на каждом раунде.
   
   В конце каждого блока значения (a, b, c, d, e, f, g, h) суммируются с текущими хэш-значениями:
   ```
   h0 = (h0 + a) & 0xFFFFFFFF
   h1 = (h1 + b) & 0xFFFFFFFF
   h2 = (h2 + c) & 0xFFFFFFFF
   h3 = (h3 + d) & 0xFFFFFFFF
   h4 = (h4 + e) & 0xFFFFFFFF
   h5 = (h5 + f) & 0xFFFFFFFF
   h6 = (h6 + g) & 0xFFFFFFFF
   h7 = (h7 + h) & 0xFFFFFFFF
   ```

### 6. **Конечный результат**:
   После обработки всех блоков алгоритм возвращает итоговое значение хэша, которое состоит из 8 32-битных слов (всего 256 бит).

   Результат выводится как строка в шестнадцатеричном виде:
   ```
   h0h1h2h3h4h5h6h7
   ```
   Это и будет финальным SHA-256 хэшем сообщения.

### Пример процесса хэширования:

Предположим, что мы хотим захешировать строку "hello". Шаги будут следующими:
1. Дополнение строки до нужной длины.
2. Разбиение строки на блоки.
3. Инициализация хэш-значений.
4. Обработка каждого блока с использованием операций сдвигов, XOR и других.
5. Обновление хэш-значений.
6. Вывод итогового хэша.

### Преимущества SHA-256:
- **Безопасность**: Алгоритм устойчив к атакам с коллизиями (когда два разных сообщения дают одинаковый хэш) и имеет высокую стойкость к криптоанализу.
- **Низкие вычислительные затраты**: SHA-256 достаточно эффективен для большинства приложений, таких как цифровые подписи и проверки целостности данных.

### Недостатки:
- Алгоритм достаточно медленный для обработки очень больших объемов данных, но при этом это нормальное поведение для криптографических хэш-функций, которые должны обеспечивать безопасность.

Если остались вопросы по алгоритму или нужно что-то уточнить, дай знать!
